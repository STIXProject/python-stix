#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Dec 04 18:28:48 2012 by generateDS.py version 2.7c.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class PartyType(GeneratedsSuper):
    """A container for defining the unique characteristics of a party,
    which can be a person or organisationType of Party. e.g. Person
    or an organisation. An organisation could be university,
    college, club, association, company, etcA unique identifier for
    partyType of PartyIDA globally unique identifier assigned to
    partyType of use of party date. e.g. exchange, update,
    createStatus of the entity. e.g. Old, Current, Inactive, Active,
    etcA primary key to reference Party.A foreign key to reference
    attribute Key of Party."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, ValidFrom=None, DataQualityType=None, ValidTo=None, DateValidFrom=None, ID=None, PartyIDType=None, DateValidTo=None, href=None, PartyID=None, Usage=None, PartyKey=None, label=None, type_=None, PartyType=None, PartyKeyRef=None, FreeTextLines=None, PartyName=None, Addresses=None, Accounts=None, ContactNumbers=None, Documents=None, ElectronicAddressIdentifiers=None, Events=None, Identifiers=None, Memberships=None, Relationships=None, Revenues=None, Stocks=None, Vehicles=None, OrganisationInfo=None, PersonInfo=None, BirthInfo=None, CountriesOfResidence=None, Favourites=None, Habits=None, Hobbies=None, Languages=None, Nationalities=None, Occupations=None, PhysicalInfo=None, Preferences=None, Qualifications=None, Visas=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.ID = _cast(None, ID)
        self.PartyIDType = _cast(None, PartyIDType)
        self.DateValidTo = _cast(None, DateValidTo)
        self.href = _cast(None, href)
        self.PartyID = _cast(None, PartyID)
        self.Usage = _cast(None, Usage)
        self.PartyKey = _cast(None, PartyKey)
        self.label = _cast(None, label)
        self.type_ = _cast(None, type_)
        self.PartyType = _cast(None, PartyType)
        self.PartyKeyRef = _cast(None, PartyKeyRef)
        self.FreeTextLines = FreeTextLines
        self.PartyName = PartyName
        self.Addresses = Addresses
        self.Accounts = Accounts
        self.ContactNumbers = ContactNumbers
        self.Documents = Documents
        self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
        self.Events = Events
        self.Identifiers = Identifiers
        self.Memberships = Memberships
        self.Relationships = Relationships
        self.Revenues = Revenues
        self.Stocks = Stocks
        self.Vehicles = Vehicles
        self.OrganisationInfo = OrganisationInfo
        self.PersonInfo = PersonInfo
        self.BirthInfo = BirthInfo
        self.CountriesOfResidence = CountriesOfResidence
        self.Favourites = Favourites
        self.Habits = Habits
        self.Hobbies = Hobbies
        self.Languages = Languages
        self.Nationalities = Nationalities
        self.Occupations = Occupations
        self.PhysicalInfo = PhysicalInfo
        self.Preferences = Preferences
        self.Qualifications = Qualifications
        self.Visas = Visas
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PartyType.subclass:
            return PartyType.subclass(*args_, **kwargs_)
        else:
            return PartyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeTextLines(self): return self.FreeTextLines
    def set_FreeTextLines(self, FreeTextLines): self.FreeTextLines = FreeTextLines
    def get_PartyName(self): return self.PartyName
    def set_PartyName(self, PartyName): self.PartyName = PartyName
    def get_Addresses(self): return self.Addresses
    def set_Addresses(self, Addresses): self.Addresses = Addresses
    def get_Accounts(self): return self.Accounts
    def set_Accounts(self, Accounts): self.Accounts = Accounts
    def get_ContactNumbers(self): return self.ContactNumbers
    def set_ContactNumbers(self, ContactNumbers): self.ContactNumbers = ContactNumbers
    def get_Documents(self): return self.Documents
    def set_Documents(self, Documents): self.Documents = Documents
    def get_ElectronicAddressIdentifiers(self): return self.ElectronicAddressIdentifiers
    def set_ElectronicAddressIdentifiers(self, ElectronicAddressIdentifiers): self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
    def get_Events(self): return self.Events
    def set_Events(self, Events): self.Events = Events
    def get_Identifiers(self): return self.Identifiers
    def set_Identifiers(self, Identifiers): self.Identifiers = Identifiers
    def get_Memberships(self): return self.Memberships
    def set_Memberships(self, Memberships): self.Memberships = Memberships
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_Revenues(self): return self.Revenues
    def set_Revenues(self, Revenues): self.Revenues = Revenues
    def get_Stocks(self): return self.Stocks
    def set_Stocks(self, Stocks): self.Stocks = Stocks
    def get_Vehicles(self): return self.Vehicles
    def set_Vehicles(self, Vehicles): self.Vehicles = Vehicles
    def get_OrganisationInfo(self): return self.OrganisationInfo
    def set_OrganisationInfo(self, OrganisationInfo): self.OrganisationInfo = OrganisationInfo
    def get_PersonInfo(self): return self.PersonInfo
    def set_PersonInfo(self, PersonInfo): self.PersonInfo = PersonInfo
    def get_BirthInfo(self): return self.BirthInfo
    def set_BirthInfo(self, BirthInfo): self.BirthInfo = BirthInfo
    def get_CountriesOfResidence(self): return self.CountriesOfResidence
    def set_CountriesOfResidence(self, CountriesOfResidence): self.CountriesOfResidence = CountriesOfResidence
    def get_Favourites(self): return self.Favourites
    def set_Favourites(self, Favourites): self.Favourites = Favourites
    def get_Habits(self): return self.Habits
    def set_Habits(self, Habits): self.Habits = Habits
    def get_Hobbies(self): return self.Hobbies
    def set_Hobbies(self, Hobbies): self.Hobbies = Hobbies
    def get_Languages(self): return self.Languages
    def set_Languages(self, Languages): self.Languages = Languages
    def get_Nationalities(self): return self.Nationalities
    def set_Nationalities(self, Nationalities): self.Nationalities = Nationalities
    def get_Occupations(self): return self.Occupations
    def set_Occupations(self, Occupations): self.Occupations = Occupations
    def get_PhysicalInfo(self): return self.PhysicalInfo
    def set_PhysicalInfo(self, PhysicalInfo): self.PhysicalInfo = PhysicalInfo
    def get_Preferences(self): return self.Preferences
    def set_Preferences(self, Preferences): self.Preferences = Preferences
    def get_Qualifications(self): return self.Qualifications
    def set_Qualifications(self, Qualifications): self.Qualifications = Qualifications
    def get_Visas(self): return self.Visas
    def set_Visas(self, Visas): self.Visas = Visas
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_PartyIDType(self): return self.PartyIDType
    def set_PartyIDType(self, PartyIDType): self.PartyIDType = PartyIDType
    def validate_PartyIDTypeList(self, value):
        # Validate type PartyIDTypeList, a restriction on xs:normalizedString.
        pass
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_PartyID(self): return self.PartyID
    def set_PartyID(self, PartyID): self.PartyID = PartyID
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_PartyUsageList(self, value):
        # Validate type PartyUsageList, a restriction on xs:string.
        pass
    def get_PartyKey(self): return self.PartyKey
    def set_PartyKey(self, PartyKey): self.PartyKey = PartyKey
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_PartyType(self): return self.PartyType
    def set_PartyType(self, PartyType): self.PartyType = PartyType
    def validate_PartyTypeList(self, value):
        # Validate type PartyTypeList, a restriction on xs:normalizedString.
        pass
    def get_PartyKeyRef(self): return self.PartyKeyRef
    def set_PartyKeyRef(self, PartyKeyRef): self.PartyKeyRef = PartyKeyRef
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PartyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.PartyIDType is not None and 'PartyIDType' not in already_processed:
            already_processed.append('PartyIDType')
            outfile.write(' PartyIDType=%s' % (quote_attrib(self.PartyIDType), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.PartyID is not None and 'PartyID' not in already_processed:
            already_processed.append('PartyID')
            outfile.write(' PartyID=%s' % (quote_attrib(self.PartyID), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.PartyKey is not None and 'PartyKey' not in already_processed:
            already_processed.append('PartyKey')
            outfile.write(' PartyKey=%s' % (quote_attrib(self.PartyKey), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.PartyType is not None and 'PartyType' not in already_processed:
            already_processed.append('PartyType')
            outfile.write(' PartyType=%s' % (quote_attrib(self.PartyType), ))
        if self.PartyKeyRef is not None and 'PartyKeyRef' not in already_processed:
            already_processed.append('PartyKeyRef')
            outfile.write(' PartyKeyRef=%s' % (quote_attrib(self.PartyKeyRef), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreeTextLines is not None:
            self.FreeTextLines.export(outfile, level, namespace_, name_='FreeTextLines', pretty_print=pretty_print)
        if self.PartyName is not None:
            self.PartyName.export(outfile, level, namespace_="n:", name_='PartyName', pretty_print=pretty_print)
        if self.Addresses is not None:
            self.Addresses.export(outfile, level, namespace_, name_='Addresses', pretty_print=pretty_print)
        if self.Accounts is not None:
            self.Accounts.export(outfile, level, namespace_, name_='Accounts', pretty_print=pretty_print)
        if self.ContactNumbers is not None:
            self.ContactNumbers.export(outfile, level, namespace_, name_='ContactNumbers', pretty_print=pretty_print)
        if self.Documents is not None:
            self.Documents.export(outfile, level, namespace_, name_='Documents', pretty_print=pretty_print)
        if self.ElectronicAddressIdentifiers is not None:
            self.ElectronicAddressIdentifiers.export(outfile, level, namespace_, name_='ElectronicAddressIdentifiers', pretty_print=pretty_print)
        if self.Events is not None:
            self.Events.export(outfile, level, namespace_, name_='Events', pretty_print=pretty_print)
        if self.Identifiers is not None:
            self.Identifiers.export(outfile, level, namespace_, name_='Identifiers', pretty_print=pretty_print)
        if self.Memberships is not None:
            self.Memberships.export(outfile, level, namespace_, name_='Memberships', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
        if self.Revenues is not None:
            self.Revenues.export(outfile, level, namespace_, name_='Revenues', pretty_print=pretty_print)
        if self.Stocks is not None:
            self.Stocks.export(outfile, level, namespace_, name_='Stocks', pretty_print=pretty_print)
        if self.Vehicles is not None:
            self.Vehicles.export(outfile, level, namespace_, name_='Vehicles', pretty_print=pretty_print)
        if self.OrganisationInfo is not None:
            self.OrganisationInfo.export(outfile, level, namespace_, name_='OrganisationInfo', pretty_print=pretty_print)
        if self.PersonInfo is not None:
            self.PersonInfo.export(outfile, level, namespace_, name_='PersonInfo', pretty_print=pretty_print)
        if self.BirthInfo is not None:
            self.BirthInfo.export(outfile, level, namespace_, name_='BirthInfo', pretty_print=pretty_print)
        if self.CountriesOfResidence is not None:
            self.CountriesOfResidence.export(outfile, level, namespace_, name_='CountriesOfResidence', pretty_print=pretty_print)
        if self.Favourites is not None:
            self.Favourites.export(outfile, level, namespace_, name_='Favourites', pretty_print=pretty_print)
        if self.Habits is not None:
            self.Habits.export(outfile, level, namespace_, name_='Habits', pretty_print=pretty_print)
        if self.Hobbies is not None:
            self.Hobbies.export(outfile, level, namespace_, name_='Hobbies', pretty_print=pretty_print)
        if self.Languages is not None:
            self.Languages.export(outfile, level, namespace_, name_='Languages', pretty_print=pretty_print)
        if self.Nationalities is not None:
            self.Nationalities.export(outfile, level, namespace_, name_='Nationalities', pretty_print=pretty_print)
        if self.Occupations is not None:
            self.Occupations.export(outfile, level, namespace_, name_='Occupations', pretty_print=pretty_print)
        if self.PhysicalInfo is not None:
            self.PhysicalInfo.export(outfile, level, namespace_, name_='PhysicalInfo', pretty_print=pretty_print)
        if self.Preferences is not None:
            self.Preferences.export(outfile, level, namespace_, name_='Preferences', pretty_print=pretty_print)
        if self.Qualifications is not None:
            self.Qualifications.export(outfile, level, namespace_, name_='Qualifications', pretty_print=pretty_print)
        if self.Visas is not None:
            self.Visas.export(outfile, level, namespace_, name_='Visas', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FreeTextLines is not None or
            self.PartyName is not None or
            self.Addresses is not None or
            self.Accounts is not None or
            self.ContactNumbers is not None or
            self.Documents is not None or
            self.ElectronicAddressIdentifiers is not None or
            self.Events is not None or
            self.Identifiers is not None or
            self.Memberships is not None or
            self.Relationships is not None or
            self.Revenues is not None or
            self.Stocks is not None or
            self.Vehicles is not None or
            self.OrganisationInfo is not None or
            self.PersonInfo is not None or
            self.BirthInfo is not None or
            self.CountriesOfResidence is not None or
            self.Favourites is not None or
            self.Habits is not None or
            self.Hobbies is not None or
            self.Languages is not None or
            self.Nationalities is not None or
            self.Occupations is not None or
            self.PhysicalInfo is not None or
            self.Preferences is not None or
            self.Qualifications is not None or
            self.Visas is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PartyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %s,\n' % (self.ID,))
        if self.PartyIDType is not None and 'PartyIDType' not in already_processed:
            already_processed.append('PartyIDType')
            showIndent(outfile, level)
            outfile.write('PartyIDType = "%s",\n' % (self.PartyIDType,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.PartyID is not None and 'PartyID' not in already_processed:
            already_processed.append('PartyID')
            showIndent(outfile, level)
            outfile.write('PartyID = %s,\n' % (self.PartyID,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.PartyKey is not None and 'PartyKey' not in already_processed:
            already_processed.append('PartyKey')
            showIndent(outfile, level)
            outfile.write('PartyKey = %s,\n' % (self.PartyKey,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.PartyType is not None and 'PartyType' not in already_processed:
            already_processed.append('PartyType')
            showIndent(outfile, level)
            outfile.write('PartyType = "%s",\n' % (self.PartyType,))
        if self.PartyKeyRef is not None and 'PartyKeyRef' not in already_processed:
            already_processed.append('PartyKeyRef')
            showIndent(outfile, level)
            outfile.write('PartyKeyRef = %s,\n' % (self.PartyKeyRef,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FreeTextLines is not None:
            showIndent(outfile, level)
            outfile.write('FreeTextLines=model_.FreeTextLines(\n')
            self.FreeTextLines.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PartyName is not None:
            showIndent(outfile, level)
            outfile.write('PartyName=model_.PartyName(\n')
            self.PartyName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Addresses is not None:
            showIndent(outfile, level)
            outfile.write('Addresses=model_.Addresses(\n')
            self.Addresses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accounts is not None:
            showIndent(outfile, level)
            outfile.write('Accounts=model_.Accounts(\n')
            self.Accounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactNumbers is not None:
            showIndent(outfile, level)
            outfile.write('ContactNumbers=model_.ContactNumbers(\n')
            self.ContactNumbers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Documents is not None:
            showIndent(outfile, level)
            outfile.write('Documents=model_.Documents(\n')
            self.Documents.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElectronicAddressIdentifiers is not None:
            showIndent(outfile, level)
            outfile.write('ElectronicAddressIdentifiers=model_.ElectronicAddressIdentifiers(\n')
            self.ElectronicAddressIdentifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Events is not None:
            showIndent(outfile, level)
            outfile.write('Events=model_.Events(\n')
            self.Events.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Identifiers is not None:
            showIndent(outfile, level)
            outfile.write('Identifiers=model_.Identifiers(\n')
            self.Identifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Memberships is not None:
            showIndent(outfile, level)
            outfile.write('Memberships=model_.Memberships(\n')
            self.Memberships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.Relationships(\n')
            self.Relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Revenues is not None:
            showIndent(outfile, level)
            outfile.write('Revenues=model_.Revenues(\n')
            self.Revenues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Stocks is not None:
            showIndent(outfile, level)
            outfile.write('Stocks=model_.Stocks(\n')
            self.Stocks.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vehicles is not None:
            showIndent(outfile, level)
            outfile.write('Vehicles=model_.Vehicles(\n')
            self.Vehicles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrganisationInfo is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationInfo=model_.OrganisationInfo(\n')
            self.OrganisationInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PersonInfo is not None:
            showIndent(outfile, level)
            outfile.write('PersonInfo=model_.PersonInfo(\n')
            self.PersonInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BirthInfo is not None:
            showIndent(outfile, level)
            outfile.write('BirthInfo=model_.BirthInfo(\n')
            self.BirthInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CountriesOfResidence is not None:
            showIndent(outfile, level)
            outfile.write('CountriesOfResidence=model_.CountriesOfResidence(\n')
            self.CountriesOfResidence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Favourites is not None:
            showIndent(outfile, level)
            outfile.write('Favourites=model_.Favourites(\n')
            self.Favourites.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Habits is not None:
            showIndent(outfile, level)
            outfile.write('Habits=model_.Habits(\n')
            self.Habits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hobbies is not None:
            showIndent(outfile, level)
            outfile.write('Hobbies=model_.Hobbies(\n')
            self.Hobbies.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Languages is not None:
            showIndent(outfile, level)
            outfile.write('Languages=model_.Languages(\n')
            self.Languages.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Nationalities is not None:
            showIndent(outfile, level)
            outfile.write('Nationalities=model_.Nationalities(\n')
            self.Nationalities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Occupations is not None:
            showIndent(outfile, level)
            outfile.write('Occupations=model_.Occupations(\n')
            self.Occupations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PhysicalInfo is not None:
            showIndent(outfile, level)
            outfile.write('PhysicalInfo=model_.PhysicalInfo(\n')
            self.PhysicalInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Preferences is not None:
            showIndent(outfile, level)
            outfile.write('Preferences=model_.Preferences(\n')
            self.Preferences.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Qualifications is not None:
            showIndent(outfile, level)
            outfile.write('Qualifications=model_.Qualifications(\n')
            self.Qualifications.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Visas is not None:
            showIndent(outfile, level)
            outfile.write('Visas=model_.Visas(\n')
            self.Visas.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('PartyIDType', node)
        if value is not None and 'PartyIDType' not in already_processed:
            already_processed.append('PartyIDType')
            self.PartyIDType = value
            self.validate_PartyIDTypeList(self.PartyIDType)    # validate type PartyIDTypeList
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('PartyID', node)
        if value is not None and 'PartyID' not in already_processed:
            already_processed.append('PartyID')
            self.PartyID = value
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_PartyUsageList(self.Usage)    # validate type PartyUsageList
        value = find_attr_value_('PartyKey', node)
        if value is not None and 'PartyKey' not in already_processed:
            already_processed.append('PartyKey')
            self.PartyKey = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('PartyType', node)
        if value is not None and 'PartyType' not in already_processed:
            already_processed.append('PartyType')
            self.PartyType = value
            self.validate_PartyTypeList(self.PartyType)    # validate type PartyTypeList
        value = find_attr_value_('PartyKeyRef', node)
        if value is not None and 'PartyKeyRef' not in already_processed:
            already_processed.append('PartyKeyRef')
            self.PartyKeyRef = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeTextLines':
            obj_ = FreeTextLines.factory()
            obj_.build(child_)
            self.set_FreeTextLines(obj_)
        elif nodeName_ == 'PartyName':
            obj_ = PartyNameType.factory()
            obj_.build(child_)
            self.set_PartyName(obj_)
        elif nodeName_ == 'Addresses':
            obj_ = Addresses.factory()
            obj_.build(child_)
            self.set_Addresses(obj_)
        elif nodeName_ == 'Accounts':
            obj_ = Accounts.factory()
            obj_.build(child_)
            self.set_Accounts(obj_)
        elif nodeName_ == 'ContactNumbers':
            obj_ = ContactNumbers.factory()
            obj_.build(child_)
            self.set_ContactNumbers(obj_)
        elif nodeName_ == 'Documents':
            obj_ = Documents.factory()
            obj_.build(child_)
            self.set_Documents(obj_)
        elif nodeName_ == 'ElectronicAddressIdentifiers':
            obj_ = ElectronicAddressIdentifiers.factory()
            obj_.build(child_)
            self.set_ElectronicAddressIdentifiers(obj_)
        elif nodeName_ == 'Events':
            obj_ = Events.factory()
            obj_.build(child_)
            self.set_Events(obj_)
        elif nodeName_ == 'Identifiers':
            obj_ = Identifiers.factory()
            obj_.build(child_)
            self.set_Identifiers(obj_)
        elif nodeName_ == 'Memberships':
            obj_ = Memberships.factory()
            obj_.build(child_)
            self.set_Memberships(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = Relationships.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
        elif nodeName_ == 'Revenues':
            obj_ = Revenues.factory()
            obj_.build(child_)
            self.set_Revenues(obj_)
        elif nodeName_ == 'Stocks':
            obj_ = Stocks.factory()
            obj_.build(child_)
            self.set_Stocks(obj_)
        elif nodeName_ == 'Vehicles':
            obj_ = Vehicles.factory()
            obj_.build(child_)
            self.set_Vehicles(obj_)
        elif nodeName_ == 'OrganisationInfo':
            obj_ = OrganisationInfo.factory()
            obj_.build(child_)
            self.set_OrganisationInfo(obj_)
        elif nodeName_ == 'PersonInfo':
            obj_ = PersonInfo.factory()
            obj_.build(child_)
            self.set_PersonInfo(obj_)
        elif nodeName_ == 'BirthInfo':
            obj_ = BirthInfo.factory()
            obj_.build(child_)
            self.set_BirthInfo(obj_)
        elif nodeName_ == 'CountriesOfResidence':
            obj_ = CountriesOfResidence.factory()
            obj_.build(child_)
            self.set_CountriesOfResidence(obj_)
        elif nodeName_ == 'Favourites':
            obj_ = Favourites.factory()
            obj_.build(child_)
            self.set_Favourites(obj_)
        elif nodeName_ == 'Habits':
            obj_ = Habits.factory()
            obj_.build(child_)
            self.set_Habits(obj_)
        elif nodeName_ == 'Hobbies':
            obj_ = Hobbies.factory()
            obj_.build(child_)
            self.set_Hobbies(obj_)
        elif nodeName_ == 'Languages':
            obj_ = Languages.factory()
            obj_.build(child_)
            self.set_Languages(obj_)
        elif nodeName_ == 'Nationalities':
            obj_ = Nationalities.factory()
            obj_.build(child_)
            self.set_Nationalities(obj_)
        elif nodeName_ == 'Occupations':
            obj_ = Occupations.factory()
            obj_.build(child_)
            self.set_Occupations(obj_)
        elif nodeName_ == 'PhysicalInfo':
            obj_ = PhysicalInfo.factory()
            obj_.build(child_)
            self.set_PhysicalInfo(obj_)
        elif nodeName_ == 'Preferences':
            obj_ = Preferences.factory()
            obj_.build(child_)
            self.set_Preferences(obj_)
        elif nodeName_ == 'Qualifications':
            obj_ = Qualifications.factory()
            obj_.build(child_)
            self.set_Qualifications(obj_)
        elif nodeName_ == 'Visas':
            obj_ = Visas.factory()
            obj_.build(child_)
            self.set_Visas(obj_)
# end class PartyType


class PersonDetailsType(GeneratedsSuper):
    """A container for defining the unique characteristics of a person
    onlyType of use of this data. e.g. data exchange, contact,
    update, createStatus of the organisation detailsA primary key to
    reference Person Details.A foreign key to reference attribute
    Key of Person Details."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, PersonDetailsKeyRef=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, PersonDetailsKey=None, Usage=None, DataQualityType=None, ValidFrom=None, FreeTextLines=None, PersonName=None, Addresses=None, Accounts=None, ContactNumbers=None, Documents=None, ElectronicAddressIdentifiers=None, Events=None, Identifiers=None, Memberships=None, Relationships=None, Revenues=None, Stocks=None, Vehicles=None, PersonInfo=None, BirthInfo=None, CountriesOfResidence=None, Favourites=None, Habits=None, Hobbies=None, Languages=None, Nationalities=None, Occupations=None, PhysicalInfo=None, Preferences=None, Qualifications=None, Visas=None, extensiontype_=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.PersonDetailsKeyRef = _cast(None, PersonDetailsKeyRef)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.PersonDetailsKey = _cast(None, PersonDetailsKey)
        self.Usage = _cast(None, Usage)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.FreeTextLines = FreeTextLines
        if PersonName is None:
            self.PersonName = []
        else:
            self.PersonName = PersonName
        self.Addresses = Addresses
        self.Accounts = Accounts
        self.ContactNumbers = ContactNumbers
        self.Documents = Documents
        self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
        self.Events = Events
        self.Identifiers = Identifiers
        self.Memberships = Memberships
        self.Relationships = Relationships
        self.Revenues = Revenues
        self.Stocks = Stocks
        self.Vehicles = Vehicles
        self.PersonInfo = PersonInfo
        self.BirthInfo = BirthInfo
        self.CountriesOfResidence = CountriesOfResidence
        self.Favourites = Favourites
        self.Habits = Habits
        self.Hobbies = Hobbies
        self.Languages = Languages
        self.Nationalities = Nationalities
        self.Occupations = Occupations
        self.PhysicalInfo = PhysicalInfo
        self.Preferences = Preferences
        self.Qualifications = Qualifications
        self.Visas = Visas
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PersonDetailsType.subclass:
            return PersonDetailsType.subclass(*args_, **kwargs_)
        else:
            return PersonDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeTextLines(self): return self.FreeTextLines
    def set_FreeTextLines(self, FreeTextLines): self.FreeTextLines = FreeTextLines
    def get_PersonName(self): return self.PersonName
    def set_PersonName(self, PersonName): self.PersonName = PersonName
    def add_PersonName(self, value): self.PersonName.append(value)
    def insert_PersonName(self, index, value): self.PersonName[index] = value
    def get_Addresses(self): return self.Addresses
    def set_Addresses(self, Addresses): self.Addresses = Addresses
    def get_Accounts(self): return self.Accounts
    def set_Accounts(self, Accounts): self.Accounts = Accounts
    def get_ContactNumbers(self): return self.ContactNumbers
    def set_ContactNumbers(self, ContactNumbers): self.ContactNumbers = ContactNumbers
    def get_Documents(self): return self.Documents
    def set_Documents(self, Documents): self.Documents = Documents
    def get_ElectronicAddressIdentifiers(self): return self.ElectronicAddressIdentifiers
    def set_ElectronicAddressIdentifiers(self, ElectronicAddressIdentifiers): self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
    def get_Events(self): return self.Events
    def set_Events(self, Events): self.Events = Events
    def get_Identifiers(self): return self.Identifiers
    def set_Identifiers(self, Identifiers): self.Identifiers = Identifiers
    def get_Memberships(self): return self.Memberships
    def set_Memberships(self, Memberships): self.Memberships = Memberships
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_Revenues(self): return self.Revenues
    def set_Revenues(self, Revenues): self.Revenues = Revenues
    def get_Stocks(self): return self.Stocks
    def set_Stocks(self, Stocks): self.Stocks = Stocks
    def get_Vehicles(self): return self.Vehicles
    def set_Vehicles(self, Vehicles): self.Vehicles = Vehicles
    def get_PersonInfo(self): return self.PersonInfo
    def set_PersonInfo(self, PersonInfo): self.PersonInfo = PersonInfo
    def get_BirthInfo(self): return self.BirthInfo
    def set_BirthInfo(self, BirthInfo): self.BirthInfo = BirthInfo
    def get_CountriesOfResidence(self): return self.CountriesOfResidence
    def set_CountriesOfResidence(self, CountriesOfResidence): self.CountriesOfResidence = CountriesOfResidence
    def get_Favourites(self): return self.Favourites
    def set_Favourites(self, Favourites): self.Favourites = Favourites
    def get_Habits(self): return self.Habits
    def set_Habits(self, Habits): self.Habits = Habits
    def get_Hobbies(self): return self.Hobbies
    def set_Hobbies(self, Hobbies): self.Hobbies = Hobbies
    def get_Languages(self): return self.Languages
    def set_Languages(self, Languages): self.Languages = Languages
    def get_Nationalities(self): return self.Nationalities
    def set_Nationalities(self, Nationalities): self.Nationalities = Nationalities
    def get_Occupations(self): return self.Occupations
    def set_Occupations(self, Occupations): self.Occupations = Occupations
    def get_PhysicalInfo(self): return self.PhysicalInfo
    def set_PhysicalInfo(self, PhysicalInfo): self.PhysicalInfo = PhysicalInfo
    def get_Preferences(self): return self.Preferences
    def set_Preferences(self, Preferences): self.Preferences = Preferences
    def get_Qualifications(self): return self.Qualifications
    def set_Qualifications(self, Qualifications): self.Qualifications = Qualifications
    def get_Visas(self): return self.Visas
    def set_Visas(self, Visas): self.Visas = Visas
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_PersonDetailsKeyRef(self): return self.PersonDetailsKeyRef
    def set_PersonDetailsKeyRef(self, PersonDetailsKeyRef): self.PersonDetailsKeyRef = PersonDetailsKeyRef
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_PersonDetailsKey(self): return self.PersonDetailsKey
    def set_PersonDetailsKey(self, PersonDetailsKey): self.PersonDetailsKey = PersonDetailsKey
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_PersonDetailsUsageList(self, value):
        # Validate type PersonDetailsUsageList, a restriction on xs:string.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='PersonDetailsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonDetailsType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.PersonDetailsKeyRef is not None and 'PersonDetailsKeyRef' not in already_processed:
            already_processed.append('PersonDetailsKeyRef')
            outfile.write(' PersonDetailsKeyRef=%s' % (quote_attrib(self.PersonDetailsKeyRef), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.PersonDetailsKey is not None and 'PersonDetailsKey' not in already_processed:
            already_processed.append('PersonDetailsKey')
            outfile.write(' PersonDetailsKey=%s' % (quote_attrib(self.PersonDetailsKey), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PersonDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreeTextLines is not None:
            self.FreeTextLines.export(outfile, level, namespace_, name_='FreeTextLines', pretty_print=pretty_print)
        for PersonName_ in self.PersonName:
            PersonName_.export(outfile, level, namespace_, name_='PersonName', pretty_print=pretty_print)
        if self.Addresses is not None:
            self.Addresses.export(outfile, level, namespace_, name_='Addresses', pretty_print=pretty_print)
        if self.Accounts is not None:
            self.Accounts.export(outfile, level, namespace_, name_='Accounts', pretty_print=pretty_print)
        if self.ContactNumbers is not None:
            self.ContactNumbers.export(outfile, level, namespace_, name_='ContactNumbers', pretty_print=pretty_print)
        if self.Documents is not None:
            self.Documents.export(outfile, level, namespace_, name_='Documents', pretty_print=pretty_print)
        if self.ElectronicAddressIdentifiers is not None:
            self.ElectronicAddressIdentifiers.export(outfile, level, namespace_, name_='ElectronicAddressIdentifiers', pretty_print=pretty_print)
        if self.Events is not None:
            self.Events.export(outfile, level, namespace_, name_='Events', pretty_print=pretty_print)
        if self.Identifiers is not None:
            self.Identifiers.export(outfile, level, namespace_, name_='Identifiers', pretty_print=pretty_print)
        if self.Memberships is not None:
            self.Memberships.export(outfile, level, namespace_, name_='Memberships', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
        if self.Revenues is not None:
            self.Revenues.export(outfile, level, namespace_, name_='Revenues', pretty_print=pretty_print)
        if self.Stocks is not None:
            self.Stocks.export(outfile, level, namespace_, name_='Stocks', pretty_print=pretty_print)
        if self.Vehicles is not None:
            self.Vehicles.export(outfile, level, namespace_, name_='Vehicles', pretty_print=pretty_print)
        if self.PersonInfo is not None:
            self.PersonInfo.export(outfile, level, namespace_, name_='PersonInfo', pretty_print=pretty_print)
        if self.BirthInfo is not None:
            self.BirthInfo.export(outfile, level, namespace_, name_='BirthInfo', pretty_print=pretty_print)
        if self.CountriesOfResidence is not None:
            self.CountriesOfResidence.export(outfile, level, namespace_, name_='CountriesOfResidence', pretty_print=pretty_print)
        if self.Favourites is not None:
            self.Favourites.export(outfile, level, namespace_, name_='Favourites', pretty_print=pretty_print)
        if self.Habits is not None:
            self.Habits.export(outfile, level, namespace_, name_='Habits', pretty_print=pretty_print)
        if self.Hobbies is not None:
            self.Hobbies.export(outfile, level, namespace_, name_='Hobbies', pretty_print=pretty_print)
        if self.Languages is not None:
            self.Languages.export(outfile, level, namespace_, name_='Languages', pretty_print=pretty_print)
        if self.Nationalities is not None:
            self.Nationalities.export(outfile, level, namespace_, name_='Nationalities', pretty_print=pretty_print)
        if self.Occupations is not None:
            self.Occupations.export(outfile, level, namespace_, name_='Occupations', pretty_print=pretty_print)
        if self.PhysicalInfo is not None:
            self.PhysicalInfo.export(outfile, level, namespace_, name_='PhysicalInfo', pretty_print=pretty_print)
        if self.Preferences is not None:
            self.Preferences.export(outfile, level, namespace_, name_='Preferences', pretty_print=pretty_print)
        if self.Qualifications is not None:
            self.Qualifications.export(outfile, level, namespace_, name_='Qualifications', pretty_print=pretty_print)
        if self.Visas is not None:
            self.Visas.export(outfile, level, namespace_, name_='Visas', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FreeTextLines is not None or
            self.PersonName or
            self.Addresses is not None or
            self.Accounts is not None or
            self.ContactNumbers is not None or
            self.Documents is not None or
            self.ElectronicAddressIdentifiers is not None or
            self.Events is not None or
            self.Identifiers is not None or
            self.Memberships is not None or
            self.Relationships is not None or
            self.Revenues is not None or
            self.Stocks is not None or
            self.Vehicles is not None or
            self.PersonInfo is not None or
            self.BirthInfo is not None or
            self.CountriesOfResidence is not None or
            self.Favourites is not None or
            self.Habits is not None or
            self.Hobbies is not None or
            self.Languages is not None or
            self.Nationalities is not None or
            self.Occupations is not None or
            self.PhysicalInfo is not None or
            self.Preferences is not None or
            self.Qualifications is not None or
            self.Visas is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonDetailsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.PersonDetailsKeyRef is not None and 'PersonDetailsKeyRef' not in already_processed:
            already_processed.append('PersonDetailsKeyRef')
            showIndent(outfile, level)
            outfile.write('PersonDetailsKeyRef = %s,\n' % (self.PersonDetailsKeyRef,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.PersonDetailsKey is not None and 'PersonDetailsKey' not in already_processed:
            already_processed.append('PersonDetailsKey')
            showIndent(outfile, level)
            outfile.write('PersonDetailsKey = %s,\n' % (self.PersonDetailsKey,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FreeTextLines is not None:
            showIndent(outfile, level)
            outfile.write('FreeTextLines=model_.FreeTextLines(\n')
            self.FreeTextLines.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('PersonName=[\n')
        level += 1
        for PersonName_ in self.PersonName:
            showIndent(outfile, level)
            outfile.write('model_.PersonName(\n')
            PersonName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Addresses is not None:
            showIndent(outfile, level)
            outfile.write('Addresses=model_.Addresses(\n')
            self.Addresses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accounts is not None:
            showIndent(outfile, level)
            outfile.write('Accounts=model_.Accounts(\n')
            self.Accounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactNumbers is not None:
            showIndent(outfile, level)
            outfile.write('ContactNumbers=model_.ContactNumbers(\n')
            self.ContactNumbers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Documents is not None:
            showIndent(outfile, level)
            outfile.write('Documents=model_.Documents(\n')
            self.Documents.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElectronicAddressIdentifiers is not None:
            showIndent(outfile, level)
            outfile.write('ElectronicAddressIdentifiers=model_.ElectronicAddressIdentifiers(\n')
            self.ElectronicAddressIdentifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Events is not None:
            showIndent(outfile, level)
            outfile.write('Events=model_.Events(\n')
            self.Events.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Identifiers is not None:
            showIndent(outfile, level)
            outfile.write('Identifiers=model_.Identifiers(\n')
            self.Identifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Memberships is not None:
            showIndent(outfile, level)
            outfile.write('Memberships=model_.Memberships(\n')
            self.Memberships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.Relationships(\n')
            self.Relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Revenues is not None:
            showIndent(outfile, level)
            outfile.write('Revenues=model_.Revenues(\n')
            self.Revenues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Stocks is not None:
            showIndent(outfile, level)
            outfile.write('Stocks=model_.Stocks(\n')
            self.Stocks.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vehicles is not None:
            showIndent(outfile, level)
            outfile.write('Vehicles=model_.Vehicles(\n')
            self.Vehicles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PersonInfo is not None:
            showIndent(outfile, level)
            outfile.write('PersonInfo=model_.PersonInfo(\n')
            self.PersonInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BirthInfo is not None:
            showIndent(outfile, level)
            outfile.write('BirthInfo=model_.BirthInfo(\n')
            self.BirthInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CountriesOfResidence is not None:
            showIndent(outfile, level)
            outfile.write('CountriesOfResidence=model_.CountriesOfResidence(\n')
            self.CountriesOfResidence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Favourites is not None:
            showIndent(outfile, level)
            outfile.write('Favourites=model_.Favourites(\n')
            self.Favourites.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Habits is not None:
            showIndent(outfile, level)
            outfile.write('Habits=model_.Habits(\n')
            self.Habits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Hobbies is not None:
            showIndent(outfile, level)
            outfile.write('Hobbies=model_.Hobbies(\n')
            self.Hobbies.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Languages is not None:
            showIndent(outfile, level)
            outfile.write('Languages=model_.Languages(\n')
            self.Languages.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Nationalities is not None:
            showIndent(outfile, level)
            outfile.write('Nationalities=model_.Nationalities(\n')
            self.Nationalities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Occupations is not None:
            showIndent(outfile, level)
            outfile.write('Occupations=model_.Occupations(\n')
            self.Occupations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PhysicalInfo is not None:
            showIndent(outfile, level)
            outfile.write('PhysicalInfo=model_.PhysicalInfo(\n')
            self.PhysicalInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Preferences is not None:
            showIndent(outfile, level)
            outfile.write('Preferences=model_.Preferences(\n')
            self.Preferences.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Qualifications is not None:
            showIndent(outfile, level)
            outfile.write('Qualifications=model_.Qualifications(\n')
            self.Qualifications.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Visas is not None:
            showIndent(outfile, level)
            outfile.write('Visas=model_.Visas(\n')
            self.Visas.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('PersonDetailsKeyRef', node)
        if value is not None and 'PersonDetailsKeyRef' not in already_processed:
            already_processed.append('PersonDetailsKeyRef')
            self.PersonDetailsKeyRef = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('PersonDetailsKey', node)
        if value is not None and 'PersonDetailsKey' not in already_processed:
            already_processed.append('PersonDetailsKey')
            self.PersonDetailsKey = value
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_PersonDetailsUsageList(self.Usage)    # validate type PersonDetailsUsageList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeTextLines':
            obj_ = FreeTextLines.factory()
            obj_.build(child_)
            self.set_FreeTextLines(obj_)
        elif nodeName_ == 'PersonName':
            class_obj_ = self.get_class_obj_(child_, PersonNameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PersonName.append(obj_)
        elif nodeName_ == 'Addresses':
            obj_ = Addresses.factory()
            obj_.build(child_)
            self.set_Addresses(obj_)
        elif nodeName_ == 'Accounts':
            obj_ = Accounts.factory()
            obj_.build(child_)
            self.set_Accounts(obj_)
        elif nodeName_ == 'ContactNumbers':
            obj_ = ContactNumbers.factory()
            obj_.build(child_)
            self.set_ContactNumbers(obj_)
        elif nodeName_ == 'Documents':
            obj_ = Documents.factory()
            obj_.build(child_)
            self.set_Documents(obj_)
        elif nodeName_ == 'ElectronicAddressIdentifiers':
            obj_ = ElectronicAddressIdentifiers.factory()
            obj_.build(child_)
            self.set_ElectronicAddressIdentifiers(obj_)
        elif nodeName_ == 'Events':
            obj_ = Events.factory()
            obj_.build(child_)
            self.set_Events(obj_)
        elif nodeName_ == 'Identifiers':
            obj_ = Identifiers.factory()
            obj_.build(child_)
            self.set_Identifiers(obj_)
        elif nodeName_ == 'Memberships':
            obj_ = Memberships.factory()
            obj_.build(child_)
            self.set_Memberships(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = Relationships.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
        elif nodeName_ == 'Revenues':
            obj_ = Revenues.factory()
            obj_.build(child_)
            self.set_Revenues(obj_)
        elif nodeName_ == 'Stocks':
            obj_ = Stocks.factory()
            obj_.build(child_)
            self.set_Stocks(obj_)
        elif nodeName_ == 'Vehicles':
            obj_ = Vehicles.factory()
            obj_.build(child_)
            self.set_Vehicles(obj_)
        elif nodeName_ == 'PersonInfo':
            obj_ = PersonInfo.factory()
            obj_.build(child_)
            self.set_PersonInfo(obj_)
        elif nodeName_ == 'BirthInfo':
            obj_ = BirthInfo.factory()
            obj_.build(child_)
            self.set_BirthInfo(obj_)
        elif nodeName_ == 'CountriesOfResidence':
            obj_ = CountriesOfResidence.factory()
            obj_.build(child_)
            self.set_CountriesOfResidence(obj_)
        elif nodeName_ == 'Favourites':
            obj_ = Favourites.factory()
            obj_.build(child_)
            self.set_Favourites(obj_)
        elif nodeName_ == 'Habits':
            obj_ = Habits.factory()
            obj_.build(child_)
            self.set_Habits(obj_)
        elif nodeName_ == 'Hobbies':
            obj_ = Hobbies.factory()
            obj_.build(child_)
            self.set_Hobbies(obj_)
        elif nodeName_ == 'Languages':
            obj_ = Languages.factory()
            obj_.build(child_)
            self.set_Languages(obj_)
        elif nodeName_ == 'Nationalities':
            obj_ = Nationalities.factory()
            obj_.build(child_)
            self.set_Nationalities(obj_)
        elif nodeName_ == 'Occupations':
            obj_ = Occupations.factory()
            obj_.build(child_)
            self.set_Occupations(obj_)
        elif nodeName_ == 'PhysicalInfo':
            obj_ = PhysicalInfo.factory()
            obj_.build(child_)
            self.set_PhysicalInfo(obj_)
        elif nodeName_ == 'Preferences':
            obj_ = Preferences.factory()
            obj_.build(child_)
            self.set_Preferences(obj_)
        elif nodeName_ == 'Qualifications':
            obj_ = Qualifications.factory()
            obj_.build(child_)
            self.set_Qualifications(obj_)
        elif nodeName_ == 'Visas':
            obj_ = Visas.factory()
            obj_.build(child_)
            self.set_Visas(obj_)
# end class PersonDetailsType


class OrganisationDetailsType(GeneratedsSuper):
    """A container for defining the unique characteristics of an
    organisation onlyType of use of this data. e.g. data exchange,
    contact, update, createStatus of the organisation detailsA
    primary key to reference Organisation Details.A foreign key to
    reference attribute Key of Organisation Details."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, href=None, OrganisationDetailsKeyRef=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, OrganisationDetailsKey=None, DataQualityType=None, Usage=None, ValidFrom=None, type_=None, FreeTextLines=None, OrganisationName=None, Addresses=None, Accounts=None, ContactNumbers=None, Documents=None, ElectronicAddressIdentifiers=None, Events=None, Identifiers=None, Memberships=None, Relationships=None, Revenues=None, Stocks=None, Vehicles=None, OrganisationInfo=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.href = _cast(None, href)
        self.OrganisationDetailsKeyRef = _cast(None, OrganisationDetailsKeyRef)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.label = _cast(None, label)
        self.DateValidTo = _cast(None, DateValidTo)
        self.OrganisationDetailsKey = _cast(None, OrganisationDetailsKey)
        self.DataQualityType = _cast(None, DataQualityType)
        self.Usage = _cast(None, Usage)
        self.ValidFrom = _cast(None, ValidFrom)
        self.type_ = _cast(None, type_)
        self.FreeTextLines = FreeTextLines
        if OrganisationName is None:
            self.OrganisationName = []
        else:
            self.OrganisationName = OrganisationName
        self.Addresses = Addresses
        self.Accounts = Accounts
        self.ContactNumbers = ContactNumbers
        self.Documents = Documents
        self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
        self.Events = Events
        self.Identifiers = Identifiers
        self.Memberships = Memberships
        self.Relationships = Relationships
        self.Revenues = Revenues
        self.Stocks = Stocks
        self.Vehicles = Vehicles
        self.OrganisationInfo = OrganisationInfo
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if OrganisationDetailsType.subclass:
            return OrganisationDetailsType.subclass(*args_, **kwargs_)
        else:
            return OrganisationDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeTextLines(self): return self.FreeTextLines
    def set_FreeTextLines(self, FreeTextLines): self.FreeTextLines = FreeTextLines
    def get_OrganisationName(self): return self.OrganisationName
    def set_OrganisationName(self, OrganisationName): self.OrganisationName = OrganisationName
    def add_OrganisationName(self, value): self.OrganisationName.append(value)
    def insert_OrganisationName(self, index, value): self.OrganisationName[index] = value
    def get_Addresses(self): return self.Addresses
    def set_Addresses(self, Addresses): self.Addresses = Addresses
    def get_Accounts(self): return self.Accounts
    def set_Accounts(self, Accounts): self.Accounts = Accounts
    def get_ContactNumbers(self): return self.ContactNumbers
    def set_ContactNumbers(self, ContactNumbers): self.ContactNumbers = ContactNumbers
    def get_Documents(self): return self.Documents
    def set_Documents(self, Documents): self.Documents = Documents
    def get_ElectronicAddressIdentifiers(self): return self.ElectronicAddressIdentifiers
    def set_ElectronicAddressIdentifiers(self, ElectronicAddressIdentifiers): self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
    def get_Events(self): return self.Events
    def set_Events(self, Events): self.Events = Events
    def get_Identifiers(self): return self.Identifiers
    def set_Identifiers(self, Identifiers): self.Identifiers = Identifiers
    def get_Memberships(self): return self.Memberships
    def set_Memberships(self, Memberships): self.Memberships = Memberships
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_Revenues(self): return self.Revenues
    def set_Revenues(self, Revenues): self.Revenues = Revenues
    def get_Stocks(self): return self.Stocks
    def set_Stocks(self, Stocks): self.Stocks = Stocks
    def get_Vehicles(self): return self.Vehicles
    def set_Vehicles(self, Vehicles): self.Vehicles = Vehicles
    def get_OrganisationInfo(self): return self.OrganisationInfo
    def set_OrganisationInfo(self, OrganisationInfo): self.OrganisationInfo = OrganisationInfo
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_OrganisationDetailsKeyRef(self): return self.OrganisationDetailsKeyRef
    def set_OrganisationDetailsKeyRef(self, OrganisationDetailsKeyRef): self.OrganisationDetailsKeyRef = OrganisationDetailsKeyRef
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_OrganisationDetailsKey(self): return self.OrganisationDetailsKey
    def set_OrganisationDetailsKey(self, OrganisationDetailsKey): self.OrganisationDetailsKey = OrganisationDetailsKey
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_OrganisationDetailsUsageList(self, value):
        # Validate type OrganisationDetailsUsageList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='OrganisationDetailsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationDetailsType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.OrganisationDetailsKeyRef is not None and 'OrganisationDetailsKeyRef' not in already_processed:
            already_processed.append('OrganisationDetailsKeyRef')
            outfile.write(' OrganisationDetailsKeyRef=%s' % (quote_attrib(self.OrganisationDetailsKeyRef), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.OrganisationDetailsKey is not None and 'OrganisationDetailsKey' not in already_processed:
            already_processed.append('OrganisationDetailsKey')
            outfile.write(' OrganisationDetailsKey=%s' % (quote_attrib(self.OrganisationDetailsKey), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreeTextLines is not None:
            self.FreeTextLines.export(outfile, level, namespace_, name_='FreeTextLines', pretty_print=pretty_print)
        for OrganisationName_ in self.OrganisationName:
            OrganisationName_.export(outfile, level, namespace_, name_='OrganisationName', pretty_print=pretty_print)
        if self.Addresses is not None:
            self.Addresses.export(outfile, level, namespace_, name_='Addresses', pretty_print=pretty_print)
        if self.Accounts is not None:
            self.Accounts.export(outfile, level, namespace_, name_='Accounts', pretty_print=pretty_print)
        if self.ContactNumbers is not None:
            self.ContactNumbers.export(outfile, level, namespace_, name_='ContactNumbers', pretty_print=pretty_print)
        if self.Documents is not None:
            self.Documents.export(outfile, level, namespace_, name_='Documents', pretty_print=pretty_print)
        if self.ElectronicAddressIdentifiers is not None:
            self.ElectronicAddressIdentifiers.export(outfile, level, namespace_, name_='ElectronicAddressIdentifiers', pretty_print=pretty_print)
        if self.Events is not None:
            self.Events.export(outfile, level, namespace_, name_='Events', pretty_print=pretty_print)
        if self.Identifiers is not None:
            self.Identifiers.export(outfile, level, namespace_, name_='Identifiers', pretty_print=pretty_print)
        if self.Memberships is not None:
            self.Memberships.export(outfile, level, namespace_, name_='Memberships', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
        if self.Revenues is not None:
            self.Revenues.export(outfile, level, namespace_, name_='Revenues', pretty_print=pretty_print)
        if self.Stocks is not None:
            self.Stocks.export(outfile, level, namespace_, name_='Stocks', pretty_print=pretty_print)
        if self.Vehicles is not None:
            self.Vehicles.export(outfile, level, namespace_, name_='Vehicles', pretty_print=pretty_print)
        if self.OrganisationInfo is not None:
            self.OrganisationInfo.export(outfile, level, namespace_, name_='OrganisationInfo', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FreeTextLines is not None or
            self.OrganisationName or
            self.Addresses is not None or
            self.Accounts is not None or
            self.ContactNumbers is not None or
            self.Documents is not None or
            self.ElectronicAddressIdentifiers is not None or
            self.Events is not None or
            self.Identifiers is not None or
            self.Memberships is not None or
            self.Relationships is not None or
            self.Revenues is not None or
            self.Stocks is not None or
            self.Vehicles is not None or
            self.OrganisationInfo is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrganisationDetailsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.OrganisationDetailsKeyRef is not None and 'OrganisationDetailsKeyRef' not in already_processed:
            already_processed.append('OrganisationDetailsKeyRef')
            showIndent(outfile, level)
            outfile.write('OrganisationDetailsKeyRef = %s,\n' % (self.OrganisationDetailsKeyRef,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.OrganisationDetailsKey is not None and 'OrganisationDetailsKey' not in already_processed:
            already_processed.append('OrganisationDetailsKey')
            showIndent(outfile, level)
            outfile.write('OrganisationDetailsKey = %s,\n' % (self.OrganisationDetailsKey,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FreeTextLines is not None:
            showIndent(outfile, level)
            outfile.write('FreeTextLines=model_.FreeTextLines(\n')
            self.FreeTextLines.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OrganisationName=[\n')
        level += 1
        for OrganisationName_ in self.OrganisationName:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationName(\n')
            OrganisationName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Addresses is not None:
            showIndent(outfile, level)
            outfile.write('Addresses=model_.Addresses(\n')
            self.Addresses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accounts is not None:
            showIndent(outfile, level)
            outfile.write('Accounts=model_.Accounts(\n')
            self.Accounts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactNumbers is not None:
            showIndent(outfile, level)
            outfile.write('ContactNumbers=model_.ContactNumbers(\n')
            self.ContactNumbers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Documents is not None:
            showIndent(outfile, level)
            outfile.write('Documents=model_.Documents(\n')
            self.Documents.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElectronicAddressIdentifiers is not None:
            showIndent(outfile, level)
            outfile.write('ElectronicAddressIdentifiers=model_.ElectronicAddressIdentifiers(\n')
            self.ElectronicAddressIdentifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Events is not None:
            showIndent(outfile, level)
            outfile.write('Events=model_.Events(\n')
            self.Events.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Identifiers is not None:
            showIndent(outfile, level)
            outfile.write('Identifiers=model_.Identifiers(\n')
            self.Identifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Memberships is not None:
            showIndent(outfile, level)
            outfile.write('Memberships=model_.Memberships(\n')
            self.Memberships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.Relationships(\n')
            self.Relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Revenues is not None:
            showIndent(outfile, level)
            outfile.write('Revenues=model_.Revenues(\n')
            self.Revenues.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Stocks is not None:
            showIndent(outfile, level)
            outfile.write('Stocks=model_.Stocks(\n')
            self.Stocks.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vehicles is not None:
            showIndent(outfile, level)
            outfile.write('Vehicles=model_.Vehicles(\n')
            self.Vehicles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrganisationInfo is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationInfo=model_.OrganisationInfo(\n')
            self.OrganisationInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('OrganisationDetailsKeyRef', node)
        if value is not None and 'OrganisationDetailsKeyRef' not in already_processed:
            already_processed.append('OrganisationDetailsKeyRef')
            self.OrganisationDetailsKeyRef = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('OrganisationDetailsKey', node)
        if value is not None and 'OrganisationDetailsKey' not in already_processed:
            already_processed.append('OrganisationDetailsKey')
            self.OrganisationDetailsKey = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_OrganisationDetailsUsageList(self.Usage)    # validate type OrganisationDetailsUsageList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeTextLines':
            obj_ = FreeTextLines.factory()
            obj_.build(child_)
            self.set_FreeTextLines(obj_)
        elif nodeName_ == 'OrganisationName':
            class_obj_ = self.get_class_obj_(child_, OrganisationNameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.OrganisationName.append(obj_)
        elif nodeName_ == 'Addresses':
            obj_ = Addresses.factory()
            obj_.build(child_)
            self.set_Addresses(obj_)
        elif nodeName_ == 'Accounts':
            obj_ = Accounts.factory()
            obj_.build(child_)
            self.set_Accounts(obj_)
        elif nodeName_ == 'ContactNumbers':
            obj_ = ContactNumbers.factory()
            obj_.build(child_)
            self.set_ContactNumbers(obj_)
        elif nodeName_ == 'Documents':
            obj_ = Documents.factory()
            obj_.build(child_)
            self.set_Documents(obj_)
        elif nodeName_ == 'ElectronicAddressIdentifiers':
            obj_ = ElectronicAddressIdentifiers.factory()
            obj_.build(child_)
            self.set_ElectronicAddressIdentifiers(obj_)
        elif nodeName_ == 'Events':
            obj_ = Events.factory()
            obj_.build(child_)
            self.set_Events(obj_)
        elif nodeName_ == 'Identifiers':
            obj_ = Identifiers.factory()
            obj_.build(child_)
            self.set_Identifiers(obj_)
        elif nodeName_ == 'Memberships':
            obj_ = Memberships.factory()
            obj_.build(child_)
            self.set_Memberships(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = Relationships.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
        elif nodeName_ == 'Revenues':
            obj_ = Revenues.factory()
            obj_.build(child_)
            self.set_Revenues(obj_)
        elif nodeName_ == 'Stocks':
            obj_ = Stocks.factory()
            obj_.build(child_)
            self.set_Stocks(obj_)
        elif nodeName_ == 'Vehicles':
            obj_ = Vehicles.factory()
            obj_.build(child_)
            self.set_Vehicles(obj_)
        elif nodeName_ == 'OrganisationInfo':
            obj_ = OrganisationInfo.factory()
            obj_.build(child_)
            self.set_OrganisationInfo(obj_)
# end class OrganisationDetailsType


class FreeTextLines(GeneratedsSuper):
    """Free text description of the party as line 1, line 2, line n."""
    subclass = None
    superclass = None
    def __init__(self, FreeTextLine=None):
        if FreeTextLine is None:
            self.FreeTextLine = []
        else:
            self.FreeTextLine = FreeTextLine
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FreeTextLines.subclass:
            return FreeTextLines.subclass(*args_, **kwargs_)
        else:
            return FreeTextLines(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeTextLine(self): return self.FreeTextLine
    def set_FreeTextLine(self, FreeTextLine): self.FreeTextLine = FreeTextLine
    def add_FreeTextLine(self, value): self.FreeTextLine.append(value)
    def insert_FreeTextLine(self, index, value): self.FreeTextLine[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FreeTextLines', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeTextLines')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreeTextLines'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FreeTextLines', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FreeTextLine_ in self.FreeTextLine:
            FreeTextLine_.export(outfile, level, namespace_, name_='FreeTextLine', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FreeTextLine
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreeTextLines'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FreeTextLine=[\n')
        level += 1
        for FreeTextLine_ in self.FreeTextLine:
            showIndent(outfile, level)
            outfile.write('model_.FreeTextLineType(\n')
            FreeTextLine_.exportLiteral(outfile, level, name_='FreeTextLineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeTextLine':
            obj_ = FreeTextLineType.factory()
            obj_.build(child_)
            self.FreeTextLine.append(obj_)
# end class FreeTextLines


class Accounts(GeneratedsSuper):
    """A container to define the accounts details of the party"""
    subclass = None
    superclass = None
    def __init__(self, Account=None):
        if Account is None:
            self.Account = []
        else:
            self.Account = Account
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Accounts.subclass:
            return Accounts.subclass(*args_, **kwargs_)
        else:
            return Accounts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Account(self): return self.Account
    def set_Account(self, Account): self.Account = Account
    def add_Account(self, value): self.Account.append(value)
    def insert_Account(self, index, value): self.Account[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Accounts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Accounts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Accounts'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Accounts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Account_ in self.Account:
            Account_.export(outfile, level, namespace_, name_='Account', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Account
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Accounts'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Account=[\n')
        level += 1
        for Account_ in self.Account:
            showIndent(outfile, level)
            outfile.write('model_.AccountType(\n')
            Account_.exportLiteral(outfile, level, name_='AccountType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Account':
            obj_ = AccountType.factory()
            obj_.build(child_)
            self.Account.append(obj_)
# end class Accounts


class Addresses(GeneratedsSuper):
    """A container for all party addresses"""
    subclass = None
    superclass = None
    def __init__(self, Address=None):
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Addresses.subclass:
            return Addresses.subclass(*args_, **kwargs_)
        else:
            return Addresses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def add_Address(self, value): self.Address.append(value)
    def insert_Address(self, index, value): self.Address[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Addresses', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Addresses')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Addresses'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Addresses', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Address_ in self.Address:
            Address_.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Address
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Addresses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Address=[\n')
        level += 1
        for Address_ in self.Address:
            showIndent(outfile, level)
            outfile.write('model_.AddressType1(\n')
            Address_.exportLiteral(outfile, level, name_='AddressType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = AddressType1.factory()
            obj_.build(child_)
            self.Address.append(obj_)
# end class Addresses


class ContactNumbers(GeneratedsSuper):
    """A container for all kinds of telecommunication lines of party used
    for contact purposes. e.g. phone, fax, mobile, pager, etc."""
    subclass = None
    superclass = None
    def __init__(self, ContactNumber=None):
        if ContactNumber is None:
            self.ContactNumber = []
        else:
            self.ContactNumber = ContactNumber
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ContactNumbers.subclass:
            return ContactNumbers.subclass(*args_, **kwargs_)
        else:
            return ContactNumbers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactNumber(self): return self.ContactNumber
    def set_ContactNumber(self, ContactNumber): self.ContactNumber = ContactNumber
    def add_ContactNumber(self, value): self.ContactNumber.append(value)
    def insert_ContactNumber(self, index, value): self.ContactNumber[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ContactNumbers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactNumbers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactNumbers'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactNumbers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContactNumber_ in self.ContactNumber:
            ContactNumber_.export(outfile, level, namespace_, name_='ContactNumber', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ContactNumber
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactNumbers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ContactNumber=[\n')
        level += 1
        for ContactNumber_ in self.ContactNumber:
            showIndent(outfile, level)
            outfile.write('model_.ContactNumberType(\n')
            ContactNumber_.exportLiteral(outfile, level, name_='ContactNumberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactNumber':
            obj_ = ContactNumberType.factory()
            obj_.build(child_)
            self.ContactNumber.append(obj_)
# end class ContactNumbers


class Documents(GeneratedsSuper):
    """A container for identification document and cards of the party that
    are unique to the party."""
    subclass = None
    superclass = None
    def __init__(self, Document=None):
        if Document is None:
            self.Document = []
        else:
            self.Document = Document
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Documents.subclass:
            return Documents.subclass(*args_, **kwargs_)
        else:
            return Documents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Document(self): return self.Document
    def set_Document(self, Document): self.Document = Document
    def add_Document(self, value): self.Document.append(value)
    def insert_Document(self, index, value): self.Document[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Documents', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Documents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Documents'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Documents', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Document_ in self.Document:
            Document_.export(outfile, level, namespace_, name_='Document', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Document
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Documents'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Document=[\n')
        level += 1
        for Document_ in self.Document:
            showIndent(outfile, level)
            outfile.write('model_.DocumentType(\n')
            Document_.exportLiteral(outfile, level, name_='DocumentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Document':
            obj_ = DocumentType.factory()
            obj_.build(child_)
            self.Document.append(obj_)
# end class Documents


class ElectronicAddressIdentifiers(GeneratedsSuper):
    """A container of different types of electronic addresses of party
    (e.g. email, chat, skype, etc)"""
    subclass = None
    superclass = None
    def __init__(self, ElectronicAddressIdentifier=None):
        if ElectronicAddressIdentifier is None:
            self.ElectronicAddressIdentifier = []
        else:
            self.ElectronicAddressIdentifier = ElectronicAddressIdentifier
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ElectronicAddressIdentifiers.subclass:
            return ElectronicAddressIdentifiers.subclass(*args_, **kwargs_)
        else:
            return ElectronicAddressIdentifiers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ElectronicAddressIdentifier(self): return self.ElectronicAddressIdentifier
    def set_ElectronicAddressIdentifier(self, ElectronicAddressIdentifier): self.ElectronicAddressIdentifier = ElectronicAddressIdentifier
    def add_ElectronicAddressIdentifier(self, value): self.ElectronicAddressIdentifier.append(value)
    def insert_ElectronicAddressIdentifier(self, index, value): self.ElectronicAddressIdentifier[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ElectronicAddressIdentifiers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectronicAddressIdentifiers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectronicAddressIdentifiers'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ElectronicAddressIdentifiers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ElectronicAddressIdentifier_ in self.ElectronicAddressIdentifier:
            ElectronicAddressIdentifier_.export(outfile, level, namespace_, name_='ElectronicAddressIdentifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ElectronicAddressIdentifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ElectronicAddressIdentifiers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ElectronicAddressIdentifier=[\n')
        level += 1
        for ElectronicAddressIdentifier_ in self.ElectronicAddressIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.ElectronicAddressIdentifierType(\n')
            ElectronicAddressIdentifier_.exportLiteral(outfile, level, name_='ElectronicAddressIdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ElectronicAddressIdentifier':
            obj_ = ElectronicAddressIdentifierType.factory()
            obj_.build(child_)
            self.ElectronicAddressIdentifier.append(obj_)
# end class ElectronicAddressIdentifiers


class Events(GeneratedsSuper):
    """A container for a list of key events and dates of the events of the
    organisation and person"""
    subclass = None
    superclass = None
    def __init__(self, Event=None):
        if Event is None:
            self.Event = []
        else:
            self.Event = Event
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Events.subclass:
            return Events.subclass(*args_, **kwargs_)
        else:
            return Events(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def add_Event(self, value): self.Event.append(value)
    def insert_Event(self, index, value): self.Event[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Events', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Events')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Events'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Events', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Event_ in self.Event:
            Event_.export(outfile, level, namespace_, name_='Event', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Event
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Events'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Event=[\n')
        level += 1
        for Event_ in self.Event:
            showIndent(outfile, level)
            outfile.write('model_.EventType(\n')
            Event_.exportLiteral(outfile, level, name_='EventType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Event':
            obj_ = EventType.factory()
            obj_.build(child_)
            self.Event.append(obj_)
# end class Events


class Identifiers(GeneratedsSuper):
    """A container for a list of Identifiers to recognise the party such as
    customer identifer, social security number, tax number, etc"""
    subclass = None
    superclass = None
    def __init__(self, Identifier=None):
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Identifiers.subclass:
            return Identifiers.subclass(*args_, **kwargs_)
        else:
            return Identifiers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Identifiers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Identifiers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Identifiers'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Identifiers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Identifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Identifiers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType1(\n')
            Identifier_.exportLiteral(outfile, level, name_='IdentifierType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identifier':
            obj_ = IdentifierType1.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
# end class Identifiers


class Memberships(GeneratedsSuper):
    """A container for memberships of party with other organisations (e.g.
    industry groups)."""
    subclass = None
    superclass = None
    def __init__(self, Membership=None):
        if Membership is None:
            self.Membership = []
        else:
            self.Membership = Membership
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Memberships.subclass:
            return Memberships.subclass(*args_, **kwargs_)
        else:
            return Memberships(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Membership(self): return self.Membership
    def set_Membership(self, Membership): self.Membership = Membership
    def add_Membership(self, value): self.Membership.append(value)
    def insert_Membership(self, index, value): self.Membership[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Memberships', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Memberships')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Memberships'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Memberships', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Membership_ in self.Membership:
            Membership_.export(outfile, level, namespace_, name_='Membership', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Membership
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Memberships'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Membership=[\n')
        level += 1
        for Membership_ in self.Membership:
            showIndent(outfile, level)
            outfile.write('model_.MembershipType(\n')
            Membership_.exportLiteral(outfile, level, name_='MembershipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Membership':
            obj_ = MembershipType.factory()
            obj_.build(child_)
            self.Membership.append(obj_)
# end class Memberships


class Relationships(GeneratedsSuper):
    """A container for relationships with other parties (persons or
    organisations, and the nature of relationship). Can also use
    this to define an organisation hierarchy (parent and subsidiary
    organisations or branches/groups of organisations)"""
    subclass = None
    superclass = None
    def __init__(self, Relationship=None):
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Relationships.subclass:
            return Relationships.subclass(*args_, **kwargs_)
        else:
            return Relationships(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship(self, index, value): self.Relationship[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Relationships', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationships')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Relationships'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Relationships', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, namespace_, name_='Relationship', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relationship
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationships'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.RelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='RelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            obj_ = RelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
# end class Relationships


class Revenues(GeneratedsSuper):
    """Container for income / revenue information of the party"""
    subclass = None
    superclass = None
    def __init__(self, Revenue=None):
        if Revenue is None:
            self.Revenue = []
        else:
            self.Revenue = Revenue
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Revenues.subclass:
            return Revenues.subclass(*args_, **kwargs_)
        else:
            return Revenues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Revenue(self): return self.Revenue
    def set_Revenue(self, Revenue): self.Revenue = Revenue
    def add_Revenue(self, value): self.Revenue.append(value)
    def insert_Revenue(self, index, value): self.Revenue[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Revenues', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Revenues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Revenues'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Revenues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Revenue_ in self.Revenue:
            Revenue_.export(outfile, level, namespace_, name_='Revenue', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Revenue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Revenues'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Revenue=[\n')
        level += 1
        for Revenue_ in self.Revenue:
            showIndent(outfile, level)
            outfile.write('model_.RevenueType(\n')
            Revenue_.exportLiteral(outfile, level, name_='RevenueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Revenue':
            obj_ = RevenueType.factory()
            obj_.build(child_)
            self.Revenue.append(obj_)
# end class Revenues


class Stocks(GeneratedsSuper):
    """A container for stocks invested information"""
    subclass = None
    superclass = None
    def __init__(self, Stock=None):
        if Stock is None:
            self.Stock = []
        else:
            self.Stock = Stock
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Stocks.subclass:
            return Stocks.subclass(*args_, **kwargs_)
        else:
            return Stocks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Stock(self): return self.Stock
    def set_Stock(self, Stock): self.Stock = Stock
    def add_Stock(self, value): self.Stock.append(value)
    def insert_Stock(self, index, value): self.Stock[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Stocks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stocks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Stocks'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Stocks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Stock_ in self.Stock:
            Stock_.export(outfile, level, namespace_, name_='Stock', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Stock
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Stocks'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Stock=[\n')
        level += 1
        for Stock_ in self.Stock:
            showIndent(outfile, level)
            outfile.write('model_.StockType(\n')
            Stock_.exportLiteral(outfile, level, name_='StockType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Stock':
            obj_ = StockType.factory()
            obj_.build(child_)
            self.Stock.append(obj_)
# end class Stocks


class Vehicles(GeneratedsSuper):
    """A container to define all the vehicles of the party"""
    subclass = None
    superclass = None
    def __init__(self, Vehicle=None):
        if Vehicle is None:
            self.Vehicle = []
        else:
            self.Vehicle = Vehicle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Vehicles.subclass:
            return Vehicles.subclass(*args_, **kwargs_)
        else:
            return Vehicles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vehicle(self): return self.Vehicle
    def set_Vehicle(self, Vehicle): self.Vehicle = Vehicle
    def add_Vehicle(self, value): self.Vehicle.append(value)
    def insert_Vehicle(self, index, value): self.Vehicle[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Vehicles', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Vehicles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Vehicles'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Vehicles', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Vehicle_ in self.Vehicle:
            Vehicle_.export(outfile, level, namespace_, name_='Vehicle', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Vehicle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Vehicles'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Vehicle=[\n')
        level += 1
        for Vehicle_ in self.Vehicle:
            showIndent(outfile, level)
            outfile.write('model_.VehicleType(\n')
            Vehicle_.exportLiteral(outfile, level, name_='VehicleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vehicle':
            obj_ = VehicleType.factory()
            obj_.build(child_)
            self.Vehicle.append(obj_)
# end class Vehicles


class OrganisationInfo(GeneratedsSuper):
    """Container for organisation specific details that are not covered in
    this schema that is common to a partyType of organisation. Free
    text description, e.g. Company, Trust, Bank, Society, Club,
    etc.Type of category the organisation belongs to such as club,
    association, company, vendor, etcStatus of the entity. e.g. Old,
    Current, Inactive, Active, etcNature of the organisation. e.g.
    Public limited, Commercial, charity, non-commercial,
    etc.Organisation Industry type such as IT, Manufacturing.
    Industry code or classificationType of code used for industry
    codeFree text description of organisation size in terms of
    number of employeesOperating hour start time of the
    organisation, e.g. 9:00amOperating hour end time for the
    organisation. e.g. 5:00pm"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, IndustryCode=None, NumberOfEmployees=None, Nature=None, Type=None, ValidTo=None, OperatingHourEndTime=None, IndustryCodeType=None, DataQualityType=None, OperatingHourStartTime=None, ValidFrom=None, CategoryType=None, IndustryType=None):
        self.Status = _cast(None, Status)
        self.IndustryCode = _cast(None, IndustryCode)
        self.NumberOfEmployees = _cast(None, NumberOfEmployees)
        self.Nature = _cast(None, Nature)
        self.Type = _cast(None, Type)
        self.ValidTo = _cast(None, ValidTo)
        self.OperatingHourEndTime = _cast(None, OperatingHourEndTime)
        self.IndustryCodeType = _cast(None, IndustryCodeType)
        self.DataQualityType = _cast(None, DataQualityType)
        self.OperatingHourStartTime = _cast(None, OperatingHourStartTime)
        self.ValidFrom = _cast(None, ValidFrom)
        self.CategoryType = _cast(None, CategoryType)
        self.IndustryType = _cast(None, IndustryType)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if OrganisationInfo.subclass:
            return OrganisationInfo.subclass(*args_, **kwargs_)
        else:
            return OrganisationInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_IndustryCode(self): return self.IndustryCode
    def set_IndustryCode(self, IndustryCode): self.IndustryCode = IndustryCode
    def validate_IndustryCodeList(self, value):
        # Validate type IndustryCodeList, a restriction on xs:normalizedString.
        pass
    def get_NumberOfEmployees(self): return self.NumberOfEmployees
    def set_NumberOfEmployees(self, NumberOfEmployees): self.NumberOfEmployees = NumberOfEmployees
    def get_Nature(self): return self.Nature
    def set_Nature(self, Nature): self.Nature = Nature
    def validate_OrganisationInfoNatureList(self, value):
        # Validate type OrganisationInfoNatureList, a restriction on xs:normalizedString.
        pass
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_OrganisationInfoTypeList(self, value):
        # Validate type OrganisationInfoTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_OperatingHourEndTime(self): return self.OperatingHourEndTime
    def set_OperatingHourEndTime(self, OperatingHourEndTime): self.OperatingHourEndTime = OperatingHourEndTime
    def get_IndustryCodeType(self): return self.IndustryCodeType
    def set_IndustryCodeType(self, IndustryCodeType): self.IndustryCodeType = IndustryCodeType
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_OperatingHourStartTime(self): return self.OperatingHourStartTime
    def set_OperatingHourStartTime(self, OperatingHourStartTime): self.OperatingHourStartTime = OperatingHourStartTime
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_CategoryType(self): return self.CategoryType
    def set_CategoryType(self, CategoryType): self.CategoryType = CategoryType
    def validate_OrganisationCategoryTypeList(self, value):
        # Validate type OrganisationCategoryTypeList, a restriction on xs:normalizedString.
        pass
    def get_IndustryType(self): return self.IndustryType
    def set_IndustryType(self, IndustryType): self.IndustryType = IndustryType
    def validate_IndustryTypeList(self, value):
        # Validate type IndustryTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='OrganisationInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationInfo'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.IndustryCode is not None and 'IndustryCode' not in already_processed:
            already_processed.append('IndustryCode')
            outfile.write(' IndustryCode=%s' % (quote_attrib(self.IndustryCode), ))
        if self.NumberOfEmployees is not None and 'NumberOfEmployees' not in already_processed:
            already_processed.append('NumberOfEmployees')
            outfile.write(' NumberOfEmployees=%s' % (quote_attrib(self.NumberOfEmployees), ))
        if self.Nature is not None and 'Nature' not in already_processed:
            already_processed.append('Nature')
            outfile.write(' Nature=%s' % (quote_attrib(self.Nature), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.OperatingHourEndTime is not None and 'OperatingHourEndTime' not in already_processed:
            already_processed.append('OperatingHourEndTime')
            outfile.write(' OperatingHourEndTime=%s' % (self.gds_format_string(quote_attrib(self.OperatingHourEndTime).encode(ExternalEncoding), input_name='OperatingHourEndTime'), ))
        if self.IndustryCodeType is not None and 'IndustryCodeType' not in already_processed:
            already_processed.append('IndustryCodeType')
            outfile.write(' IndustryCodeType=%s' % (quote_attrib(self.IndustryCodeType), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.OperatingHourStartTime is not None and 'OperatingHourStartTime' not in already_processed:
            already_processed.append('OperatingHourStartTime')
            outfile.write(' OperatingHourStartTime=%s' % (self.gds_format_string(quote_attrib(self.OperatingHourStartTime).encode(ExternalEncoding), input_name='OperatingHourStartTime'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.CategoryType is not None and 'CategoryType' not in already_processed:
            already_processed.append('CategoryType')
            outfile.write(' CategoryType=%s' % (quote_attrib(self.CategoryType), ))
        if self.IndustryType is not None and 'IndustryType' not in already_processed:
            already_processed.append('IndustryType')
            outfile.write(' IndustryType=%s' % (quote_attrib(self.IndustryType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationInfo', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrganisationInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.IndustryCode is not None and 'IndustryCode' not in already_processed:
            already_processed.append('IndustryCode')
            showIndent(outfile, level)
            outfile.write('IndustryCode = "%s",\n' % (self.IndustryCode,))
        if self.NumberOfEmployees is not None and 'NumberOfEmployees' not in already_processed:
            already_processed.append('NumberOfEmployees')
            showIndent(outfile, level)
            outfile.write('NumberOfEmployees = %s,\n' % (self.NumberOfEmployees,))
        if self.Nature is not None and 'Nature' not in already_processed:
            already_processed.append('Nature')
            showIndent(outfile, level)
            outfile.write('Nature = "%s",\n' % (self.Nature,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.OperatingHourEndTime is not None and 'OperatingHourEndTime' not in already_processed:
            already_processed.append('OperatingHourEndTime')
            showIndent(outfile, level)
            outfile.write('OperatingHourEndTime = "%s",\n' % (self.OperatingHourEndTime,))
        if self.IndustryCodeType is not None and 'IndustryCodeType' not in already_processed:
            already_processed.append('IndustryCodeType')
            showIndent(outfile, level)
            outfile.write('IndustryCodeType = %s,\n' % (self.IndustryCodeType,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.OperatingHourStartTime is not None and 'OperatingHourStartTime' not in already_processed:
            already_processed.append('OperatingHourStartTime')
            showIndent(outfile, level)
            outfile.write('OperatingHourStartTime = "%s",\n' % (self.OperatingHourStartTime,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.CategoryType is not None and 'CategoryType' not in already_processed:
            already_processed.append('CategoryType')
            showIndent(outfile, level)
            outfile.write('CategoryType = "%s",\n' % (self.CategoryType,))
        if self.IndustryType is not None and 'IndustryType' not in already_processed:
            already_processed.append('IndustryType')
            showIndent(outfile, level)
            outfile.write('IndustryType = "%s",\n' % (self.IndustryType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('IndustryCode', node)
        if value is not None and 'IndustryCode' not in already_processed:
            already_processed.append('IndustryCode')
            self.IndustryCode = value
            self.validate_IndustryCodeList(self.IndustryCode)    # validate type IndustryCodeList
        value = find_attr_value_('NumberOfEmployees', node)
        if value is not None and 'NumberOfEmployees' not in already_processed:
            already_processed.append('NumberOfEmployees')
            self.NumberOfEmployees = value
        value = find_attr_value_('Nature', node)
        if value is not None and 'Nature' not in already_processed:
            already_processed.append('Nature')
            self.Nature = value
            self.validate_OrganisationInfoNatureList(self.Nature)    # validate type OrganisationInfoNatureList
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_OrganisationInfoTypeList(self.Type)    # validate type OrganisationInfoTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('OperatingHourEndTime', node)
        if value is not None and 'OperatingHourEndTime' not in already_processed:
            already_processed.append('OperatingHourEndTime')
            self.OperatingHourEndTime = value
        value = find_attr_value_('IndustryCodeType', node)
        if value is not None and 'IndustryCodeType' not in already_processed:
            already_processed.append('IndustryCodeType')
            self.IndustryCodeType = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('OperatingHourStartTime', node)
        if value is not None and 'OperatingHourStartTime' not in already_processed:
            already_processed.append('OperatingHourStartTime')
            self.OperatingHourStartTime = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('CategoryType', node)
        if value is not None and 'CategoryType' not in already_processed:
            already_processed.append('CategoryType')
            self.CategoryType = value
            self.validate_OrganisationCategoryTypeList(self.CategoryType)    # validate type OrganisationCategoryTypeList
        value = find_attr_value_('IndustryType', node)
        if value is not None and 'IndustryType' not in already_processed:
            already_processed.append('IndustryType')
            self.IndustryType = value
            self.validate_IndustryTypeList(self.IndustryType)    # validate type IndustryTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganisationInfo


class PersonInfo(GeneratedsSuper):
    """Container for person specific details that are not covered in this
    schema that is common to a partyAge of the person as integerType
    of category the person belongs such as customer, employee,
    friend, prospect, etcStatus of the person. e.g. living,
    deceased, retired. To log the date of the status such as death
    or retired, use "Events" elementFree text description of the
    current marital status, e.g. married, separated, divorced,
    separated, etc.Ethnicity of the person, e.g. Asian, Chinese,
    African, etc.Free text gender description.Free text name of the
    religion"""
    subclass = None
    superclass = None
    def __init__(self, MaritalStatus=None, Gender=None, Age=None, Religion=None, ValidFrom=None, DataQualityType=None, PhysicalStatus=None, CategoryType=None, ValidTo=None, Ethnicity=None):
        self.MaritalStatus = _cast(None, MaritalStatus)
        self.Gender = _cast(None, Gender)
        self.Age = _cast(None, Age)
        self.Religion = _cast(None, Religion)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        self.PhysicalStatus = _cast(None, PhysicalStatus)
        self.CategoryType = _cast(None, CategoryType)
        self.ValidTo = _cast(None, ValidTo)
        self.Ethnicity = _cast(None, Ethnicity)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PersonInfo.subclass:
            return PersonInfo.subclass(*args_, **kwargs_)
        else:
            return PersonInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaritalStatus(self): return self.MaritalStatus
    def set_MaritalStatus(self, MaritalStatus): self.MaritalStatus = MaritalStatus
    def validate_MaritalStatusList(self, value):
        # Validate type MaritalStatusList, a restriction on xs:normalizedString.
        pass
    def get_Gender(self): return self.Gender
    def set_Gender(self, Gender): self.Gender = Gender
    def validate_GenderList(self, value):
        # Validate type GenderList, a restriction on xs:normalizedString.
        pass
    def get_Age(self): return self.Age
    def set_Age(self, Age): self.Age = Age
    def get_Religion(self): return self.Religion
    def set_Religion(self, Religion): self.Religion = Religion
    def validate_ReligionList(self, value):
        # Validate type ReligionList, a restriction on xs:normalizedString.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_PhysicalStatus(self): return self.PhysicalStatus
    def set_PhysicalStatus(self, PhysicalStatus): self.PhysicalStatus = PhysicalStatus
    def validate_PhysicalStatusList(self, value):
        # Validate type PhysicalStatusList, a restriction on xs:normalizedString.
        pass
    def get_CategoryType(self): return self.CategoryType
    def set_CategoryType(self, CategoryType): self.CategoryType = CategoryType
    def validate_PersonCategoryTypeList(self, value):
        # Validate type PersonCategoryTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_Ethnicity(self): return self.Ethnicity
    def set_Ethnicity(self, Ethnicity): self.Ethnicity = Ethnicity
    def validate_PersonEthnicityList(self, value):
        # Validate type PersonEthnicityList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PersonInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonInfo'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.MaritalStatus is not None and 'MaritalStatus' not in already_processed:
            already_processed.append('MaritalStatus')
            outfile.write(' MaritalStatus=%s' % (quote_attrib(self.MaritalStatus), ))
        if self.Gender is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            outfile.write(' Gender=%s' % (quote_attrib(self.Gender), ))
        if self.Age is not None and 'Age' not in already_processed:
            already_processed.append('Age')
            outfile.write(' Age=%s' % (quote_attrib(self.Age), ))
        if self.Religion is not None and 'Religion' not in already_processed:
            already_processed.append('Religion')
            outfile.write(' Religion=%s' % (quote_attrib(self.Religion), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.PhysicalStatus is not None and 'PhysicalStatus' not in already_processed:
            already_processed.append('PhysicalStatus')
            outfile.write(' PhysicalStatus=%s' % (quote_attrib(self.PhysicalStatus), ))
        if self.CategoryType is not None and 'CategoryType' not in already_processed:
            already_processed.append('CategoryType')
            outfile.write(' CategoryType=%s' % (quote_attrib(self.CategoryType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.Ethnicity is not None and 'Ethnicity' not in already_processed:
            already_processed.append('Ethnicity')
            outfile.write(' Ethnicity=%s' % (quote_attrib(self.Ethnicity), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonInfo', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MaritalStatus is not None and 'MaritalStatus' not in already_processed:
            already_processed.append('MaritalStatus')
            showIndent(outfile, level)
            outfile.write('MaritalStatus = "%s",\n' % (self.MaritalStatus,))
        if self.Gender is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            showIndent(outfile, level)
            outfile.write('Gender = "%s",\n' % (self.Gender,))
        if self.Age is not None and 'Age' not in already_processed:
            already_processed.append('Age')
            showIndent(outfile, level)
            outfile.write('Age = %s,\n' % (self.Age,))
        if self.Religion is not None and 'Religion' not in already_processed:
            already_processed.append('Religion')
            showIndent(outfile, level)
            outfile.write('Religion = "%s",\n' % (self.Religion,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.PhysicalStatus is not None and 'PhysicalStatus' not in already_processed:
            already_processed.append('PhysicalStatus')
            showIndent(outfile, level)
            outfile.write('PhysicalStatus = "%s",\n' % (self.PhysicalStatus,))
        if self.CategoryType is not None and 'CategoryType' not in already_processed:
            already_processed.append('CategoryType')
            showIndent(outfile, level)
            outfile.write('CategoryType = "%s",\n' % (self.CategoryType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.Ethnicity is not None and 'Ethnicity' not in already_processed:
            already_processed.append('Ethnicity')
            showIndent(outfile, level)
            outfile.write('Ethnicity = "%s",\n' % (self.Ethnicity,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MaritalStatus', node)
        if value is not None and 'MaritalStatus' not in already_processed:
            already_processed.append('MaritalStatus')
            self.MaritalStatus = value
            self.validate_MaritalStatusList(self.MaritalStatus)    # validate type MaritalStatusList
        value = find_attr_value_('Gender', node)
        if value is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            self.Gender = value
            self.validate_GenderList(self.Gender)    # validate type GenderList
        value = find_attr_value_('Age', node)
        if value is not None and 'Age' not in already_processed:
            already_processed.append('Age')
            self.Age = value
        value = find_attr_value_('Religion', node)
        if value is not None and 'Religion' not in already_processed:
            already_processed.append('Religion')
            self.Religion = value
            self.validate_ReligionList(self.Religion)    # validate type ReligionList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('PhysicalStatus', node)
        if value is not None and 'PhysicalStatus' not in already_processed:
            already_processed.append('PhysicalStatus')
            self.PhysicalStatus = value
            self.validate_PhysicalStatusList(self.PhysicalStatus)    # validate type PhysicalStatusList
        value = find_attr_value_('CategoryType', node)
        if value is not None and 'CategoryType' not in already_processed:
            already_processed.append('CategoryType')
            self.CategoryType = value
            self.validate_PersonCategoryTypeList(self.CategoryType)    # validate type PersonCategoryTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('Ethnicity', node)
        if value is not None and 'Ethnicity' not in already_processed:
            already_processed.append('Ethnicity')
            self.Ethnicity = value
            self.validate_PersonEthnicityList(self.Ethnicity)    # validate type PersonEthnicityList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PersonInfo


class BirthInfo(GeneratedsSuper):
    """A container to define the Date of Birth details of a personBirth
    data and time to the known precision. Usually, it is only the
    date that is known. Leave time as 00:00:00 if not known.Specify
    the duration of the uncertainity period as a range where
    BirthDateTime is in the middle of the range. Uses xsd:duration
    as the data type. The time interval is in the format:
    PnYnMnDTnHnMnS P: period (required), nY: number of years, nM:
    number of months, nD: number of days, T: start of a time section
    (required if hours, minutes or secords to be specified), nH:
    number of hours, nM: number of minutes, nS: number of seconds
    P5Y -> period of 5 years P5Y2M10D -> 5 years, 2 months, 10 days,
    and 15 hours"""
    subclass = None
    superclass = None
    def __init__(self, BirthDateTime=None, ValidTo=None, ValidFrom=None, DataQualityType=None, BirthDateTimePrecision=None, BirthInfoElement=None, BirthPlaceDetails=None):
        self.BirthDateTime = _cast(None, BirthDateTime)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        self.BirthDateTimePrecision = _cast(None, BirthDateTimePrecision)
        if BirthInfoElement is None:
            self.BirthInfoElement = []
        else:
            self.BirthInfoElement = BirthInfoElement
        self.BirthPlaceDetails = BirthPlaceDetails
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BirthInfo.subclass:
            return BirthInfo.subclass(*args_, **kwargs_)
        else:
            return BirthInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BirthInfoElement(self): return self.BirthInfoElement
    def set_BirthInfoElement(self, BirthInfoElement): self.BirthInfoElement = BirthInfoElement
    def add_BirthInfoElement(self, value): self.BirthInfoElement.append(value)
    def insert_BirthInfoElement(self, index, value): self.BirthInfoElement[index] = value
    def get_BirthPlaceDetails(self): return self.BirthPlaceDetails
    def set_BirthPlaceDetails(self, BirthPlaceDetails): self.BirthPlaceDetails = BirthPlaceDetails
    def get_BirthDateTime(self): return self.BirthDateTime
    def set_BirthDateTime(self, BirthDateTime): self.BirthDateTime = BirthDateTime
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_BirthDateTimePrecision(self): return self.BirthDateTimePrecision
    def set_BirthDateTimePrecision(self, BirthDateTimePrecision): self.BirthDateTimePrecision = BirthDateTimePrecision
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BirthInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BirthInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BirthInfo'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.BirthDateTime is not None and 'BirthDateTime' not in already_processed:
            already_processed.append('BirthDateTime')
            outfile.write(' BirthDateTime=%s' % (self.gds_format_string(quote_attrib(self.BirthDateTime).encode(ExternalEncoding), input_name='BirthDateTime'), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.BirthDateTimePrecision is not None and 'BirthDateTimePrecision' not in already_processed:
            already_processed.append('BirthDateTimePrecision')
            outfile.write(' BirthDateTimePrecision=%s' % (self.gds_format_string(quote_attrib(self.BirthDateTimePrecision).encode(ExternalEncoding), input_name='BirthDateTimePrecision'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BirthInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BirthInfoElement_ in self.BirthInfoElement:
            BirthInfoElement_.export(outfile, level, namespace_, name_='BirthInfoElement', pretty_print=pretty_print)
        if self.BirthPlaceDetails is not None:
            self.BirthPlaceDetails.export(outfile, level, namespace_, name_='BirthPlaceDetails', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BirthInfoElement or
            self.BirthPlaceDetails is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BirthInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BirthDateTime is not None and 'BirthDateTime' not in already_processed:
            already_processed.append('BirthDateTime')
            showIndent(outfile, level)
            outfile.write('BirthDateTime = "%s",\n' % (self.BirthDateTime,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.BirthDateTimePrecision is not None and 'BirthDateTimePrecision' not in already_processed:
            already_processed.append('BirthDateTimePrecision')
            showIndent(outfile, level)
            outfile.write('BirthDateTimePrecision = "%s",\n' % (self.BirthDateTimePrecision,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BirthInfoElement=[\n')
        level += 1
        for BirthInfoElement_ in self.BirthInfoElement:
            showIndent(outfile, level)
            outfile.write('model_.BirthInfoElementType(\n')
            BirthInfoElement_.exportLiteral(outfile, level, name_='BirthInfoElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.BirthPlaceDetails is not None:
            showIndent(outfile, level)
            outfile.write('BirthPlaceDetails=model_.AddressType(\n')
            self.BirthPlaceDetails.exportLiteral(outfile, level, name_='BirthPlaceDetails')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BirthDateTime', node)
        if value is not None and 'BirthDateTime' not in already_processed:
            already_processed.append('BirthDateTime')
            self.BirthDateTime = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('BirthDateTimePrecision', node)
        if value is not None and 'BirthDateTimePrecision' not in already_processed:
            already_processed.append('BirthDateTimePrecision')
            self.BirthDateTimePrecision = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BirthInfoElement':
            obj_ = BirthInfoElementType.factory()
            obj_.build(child_)
            self.BirthInfoElement.append(obj_)
        elif nodeName_ == 'BirthPlaceDetails':
            class_obj_ = self.get_class_obj_(child_, AddressType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_BirthPlaceDetails(obj_)
# end class BirthInfo


class CountriesOfResidence(GeneratedsSuper):
    """A container for all citizenships and residencies
    (Permanent/temporary) of a person."""
    subclass = None
    superclass = None
    def __init__(self, Country=None):
        if Country is None:
            self.Country = []
        else:
            self.Country = Country
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CountriesOfResidence.subclass:
            return CountriesOfResidence.subclass(*args_, **kwargs_)
        else:
            return CountriesOfResidence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    def add_Country(self, value): self.Country.append(value)
    def insert_Country(self, index, value): self.Country[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CountriesOfResidence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountriesOfResidence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountriesOfResidence'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CountriesOfResidence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Country_ in self.Country:
            Country_.export(outfile, level, namespace_, name_='Country', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Country
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountriesOfResidence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Country=[\n')
        level += 1
        for Country_ in self.Country:
            showIndent(outfile, level)
            outfile.write('model_.CountryType1(\n')
            Country_.exportLiteral(outfile, level, name_='CountryType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Country':
            obj_ = CountryType1.factory()
            obj_.build(child_)
            self.Country.append(obj_)
# end class CountriesOfResidence


class Favourites(GeneratedsSuper):
    """A container for a list of favourites of a person"""
    subclass = None
    superclass = None
    def __init__(self, Favourite=None):
        if Favourite is None:
            self.Favourite = []
        else:
            self.Favourite = Favourite
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Favourites.subclass:
            return Favourites.subclass(*args_, **kwargs_)
        else:
            return Favourites(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Favourite(self): return self.Favourite
    def set_Favourite(self, Favourite): self.Favourite = Favourite
    def add_Favourite(self, value): self.Favourite.append(value)
    def insert_Favourite(self, index, value): self.Favourite[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Favourites', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Favourites')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Favourites'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Favourites', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Favourite_ in self.Favourite:
            Favourite_.export(outfile, level, namespace_, name_='Favourite', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Favourite
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Favourites'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Favourite=[\n')
        level += 1
        for Favourite_ in self.Favourite:
            showIndent(outfile, level)
            outfile.write('model_.FavouriteType(\n')
            Favourite_.exportLiteral(outfile, level, name_='FavouriteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Favourite':
            obj_ = FavouriteType.factory()
            obj_.build(child_)
            self.Favourite.append(obj_)
# end class Favourites


class Habits(GeneratedsSuper):
    """A container for a list of habits of a person"""
    subclass = None
    superclass = None
    def __init__(self, Habit=None):
        if Habit is None:
            self.Habit = []
        else:
            self.Habit = Habit
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Habits.subclass:
            return Habits.subclass(*args_, **kwargs_)
        else:
            return Habits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Habit(self): return self.Habit
    def set_Habit(self, Habit): self.Habit = Habit
    def add_Habit(self, value): self.Habit.append(value)
    def insert_Habit(self, index, value): self.Habit[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Habits', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Habits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Habits'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Habits', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Habit_ in self.Habit:
            Habit_.export(outfile, level, namespace_, name_='Habit', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Habit
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Habits'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Habit=[\n')
        level += 1
        for Habit_ in self.Habit:
            showIndent(outfile, level)
            outfile.write('model_.HabitType(\n')
            Habit_.exportLiteral(outfile, level, name_='HabitType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Habit':
            obj_ = HabitType.factory()
            obj_.build(child_)
            self.Habit.append(obj_)
# end class Habits


class Hobbies(GeneratedsSuper):
    """A container for a list of hobbies of a person"""
    subclass = None
    superclass = None
    def __init__(self, Hobby=None):
        if Hobby is None:
            self.Hobby = []
        else:
            self.Hobby = Hobby
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Hobbies.subclass:
            return Hobbies.subclass(*args_, **kwargs_)
        else:
            return Hobbies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hobby(self): return self.Hobby
    def set_Hobby(self, Hobby): self.Hobby = Hobby
    def add_Hobby(self, value): self.Hobby.append(value)
    def insert_Hobby(self, index, value): self.Hobby[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Hobbies', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Hobbies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Hobbies'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Hobbies', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Hobby_ in self.Hobby:
            Hobby_.export(outfile, level, namespace_, name_='Hobby', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Hobby
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Hobbies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hobby=[\n')
        level += 1
        for Hobby_ in self.Hobby:
            showIndent(outfile, level)
            outfile.write('model_.HobbyType(\n')
            Hobby_.exportLiteral(outfile, level, name_='HobbyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hobby':
            obj_ = HobbyType.factory()
            obj_.build(child_)
            self.Hobby.append(obj_)
# end class Hobbies


class Languages(GeneratedsSuper):
    """A container for a list of languages spoken by a person."""
    subclass = None
    superclass = None
    def __init__(self, Language=None):
        if Language is None:
            self.Language = []
        else:
            self.Language = Language
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Languages.subclass:
            return Languages.subclass(*args_, **kwargs_)
        else:
            return Languages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def add_Language(self, value): self.Language.append(value)
    def insert_Language(self, index, value): self.Language[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Languages', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Languages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Languages'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Languages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Language_ in self.Language:
            Language_.export(outfile, level, namespace_, name_='Language', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Language
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Languages'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Language=[\n')
        level += 1
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('model_.LanguageType(\n')
            Language_.exportLiteral(outfile, level, name_='LanguageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Language':
            obj_ = LanguageType.factory()
            obj_.build(child_)
            self.Language.append(obj_)
# end class Languages


class Nationalities(GeneratedsSuper):
    """A container for a list of nationalities of a person"""
    subclass = None
    superclass = None
    def __init__(self, Country=None):
        if Country is None:
            self.Country = []
        else:
            self.Country = Country
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Nationalities.subclass:
            return Nationalities.subclass(*args_, **kwargs_)
        else:
            return Nationalities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    def add_Country(self, value): self.Country.append(value)
    def insert_Country(self, index, value): self.Country[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Nationalities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Nationalities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Nationalities'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Nationalities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Country_ in self.Country:
            Country_.export(outfile, level, namespace_, name_='Country', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Country
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Nationalities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Country=[\n')
        level += 1
        for Country_ in self.Country:
            showIndent(outfile, level)
            outfile.write('model_.CountryType2(\n')
            Country_.exportLiteral(outfile, level, name_='CountryType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Country':
            obj_ = CountryType2.factory()
            obj_.build(child_)
            self.Country.append(obj_)
# end class Nationalities


class Occupations(GeneratedsSuper):
    """A container for a list of occupations of a person"""
    subclass = None
    superclass = None
    def __init__(self, Occupation=None):
        if Occupation is None:
            self.Occupation = []
        else:
            self.Occupation = Occupation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Occupations.subclass:
            return Occupations.subclass(*args_, **kwargs_)
        else:
            return Occupations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Occupation(self): return self.Occupation
    def set_Occupation(self, Occupation): self.Occupation = Occupation
    def add_Occupation(self, value): self.Occupation.append(value)
    def insert_Occupation(self, index, value): self.Occupation[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Occupations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Occupations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Occupations'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Occupations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Occupation_ in self.Occupation:
            Occupation_.export(outfile, level, namespace_, name_='Occupation', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Occupation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Occupations'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Occupation=[\n')
        level += 1
        for Occupation_ in self.Occupation:
            showIndent(outfile, level)
            outfile.write('model_.OccupationType(\n')
            Occupation_.exportLiteral(outfile, level, name_='OccupationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Occupation':
            obj_ = OccupationType.factory()
            obj_.build(child_)
            self.Occupation.append(obj_)
# end class Occupations


class PhysicalInfo(GeneratedsSuper):
    """A container for physical characteristics of a person"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, BloodGroup=None, ValidFrom=None, FreeTextLine=None, Feature=None, BodyMark=None, Disability=None, Allergy=None, HealthCondition=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.BloodGroup = _cast(None, BloodGroup)
        self.ValidFrom = _cast(None, ValidFrom)
        if FreeTextLine is None:
            self.FreeTextLine = []
        else:
            self.FreeTextLine = FreeTextLine
        if Feature is None:
            self.Feature = []
        else:
            self.Feature = Feature
        if BodyMark is None:
            self.BodyMark = []
        else:
            self.BodyMark = BodyMark
        if Disability is None:
            self.Disability = []
        else:
            self.Disability = Disability
        if Allergy is None:
            self.Allergy = []
        else:
            self.Allergy = Allergy
        if HealthCondition is None:
            self.HealthCondition = []
        else:
            self.HealthCondition = HealthCondition
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PhysicalInfo.subclass:
            return PhysicalInfo.subclass(*args_, **kwargs_)
        else:
            return PhysicalInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeTextLine(self): return self.FreeTextLine
    def set_FreeTextLine(self, FreeTextLine): self.FreeTextLine = FreeTextLine
    def add_FreeTextLine(self, value): self.FreeTextLine.append(value)
    def insert_FreeTextLine(self, index, value): self.FreeTextLine[index] = value
    def get_Feature(self): return self.Feature
    def set_Feature(self, Feature): self.Feature = Feature
    def add_Feature(self, value): self.Feature.append(value)
    def insert_Feature(self, index, value): self.Feature[index] = value
    def get_BodyMark(self): return self.BodyMark
    def set_BodyMark(self, BodyMark): self.BodyMark = BodyMark
    def add_BodyMark(self, value): self.BodyMark.append(value)
    def insert_BodyMark(self, index, value): self.BodyMark[index] = value
    def get_Disability(self): return self.Disability
    def set_Disability(self, Disability): self.Disability = Disability
    def add_Disability(self, value): self.Disability.append(value)
    def insert_Disability(self, index, value): self.Disability[index] = value
    def get_Allergy(self): return self.Allergy
    def set_Allergy(self, Allergy): self.Allergy = Allergy
    def add_Allergy(self, value): self.Allergy.append(value)
    def insert_Allergy(self, index, value): self.Allergy[index] = value
    def get_HealthCondition(self): return self.HealthCondition
    def set_HealthCondition(self, HealthCondition): self.HealthCondition = HealthCondition
    def add_HealthCondition(self, value): self.HealthCondition.append(value)
    def insert_HealthCondition(self, index, value): self.HealthCondition[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_BloodGroup(self): return self.BloodGroup
    def set_BloodGroup(self, BloodGroup): self.BloodGroup = BloodGroup
    def validate_BloodGroupList(self, value):
        # Validate type BloodGroupList, a restriction on xs:normalizedString.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PhysicalInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhysicalInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhysicalInfo'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.BloodGroup is not None and 'BloodGroup' not in already_processed:
            already_processed.append('BloodGroup')
            outfile.write(' BloodGroup=%s' % (quote_attrib(self.BloodGroup), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PhysicalInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FreeTextLine_ in self.FreeTextLine:
            FreeTextLine_.export(outfile, level, namespace_, name_='FreeTextLine', pretty_print=pretty_print)
        for Feature_ in self.Feature:
            Feature_.export(outfile, level, namespace_, name_='Feature', pretty_print=pretty_print)
        for BodyMark_ in self.BodyMark:
            BodyMark_.export(outfile, level, namespace_, name_='BodyMark', pretty_print=pretty_print)
        for Disability_ in self.Disability:
            Disability_.export(outfile, level, namespace_, name_='Disability', pretty_print=pretty_print)
        for Allergy_ in self.Allergy:
            Allergy_.export(outfile, level, namespace_, name_='Allergy', pretty_print=pretty_print)
        for HealthCondition_ in self.HealthCondition:
            HealthCondition_.export(outfile, level, namespace_, name_='HealthCondition', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FreeTextLine or
            self.Feature or
            self.BodyMark or
            self.Disability or
            self.Allergy or
            self.HealthCondition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhysicalInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.BloodGroup is not None and 'BloodGroup' not in already_processed:
            already_processed.append('BloodGroup')
            showIndent(outfile, level)
            outfile.write('BloodGroup = "%s",\n' % (self.BloodGroup,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FreeTextLine=[\n')
        level += 1
        for FreeTextLine_ in self.FreeTextLine:
            showIndent(outfile, level)
            outfile.write('model_.FreeTextLineType1(\n')
            FreeTextLine_.exportLiteral(outfile, level, name_='FreeTextLineType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Feature=[\n')
        level += 1
        for Feature_ in self.Feature:
            showIndent(outfile, level)
            outfile.write('model_.FeatureType(\n')
            Feature_.exportLiteral(outfile, level, name_='FeatureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BodyMark=[\n')
        level += 1
        for BodyMark_ in self.BodyMark:
            showIndent(outfile, level)
            outfile.write('model_.BodyMarkType(\n')
            BodyMark_.exportLiteral(outfile, level, name_='BodyMarkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Disability=[\n')
        level += 1
        for Disability_ in self.Disability:
            showIndent(outfile, level)
            outfile.write('model_.DisabilityType(\n')
            Disability_.exportLiteral(outfile, level, name_='DisabilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Allergy=[\n')
        level += 1
        for Allergy_ in self.Allergy:
            showIndent(outfile, level)
            outfile.write('model_.AllergyType(\n')
            Allergy_.exportLiteral(outfile, level, name_='AllergyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HealthCondition=[\n')
        level += 1
        for HealthCondition_ in self.HealthCondition:
            showIndent(outfile, level)
            outfile.write('model_.HealthConditionType(\n')
            HealthCondition_.exportLiteral(outfile, level, name_='HealthConditionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('BloodGroup', node)
        if value is not None and 'BloodGroup' not in already_processed:
            already_processed.append('BloodGroup')
            self.BloodGroup = value
            self.validate_BloodGroupList(self.BloodGroup)    # validate type BloodGroupList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeTextLine':
            obj_ = FreeTextLineType1.factory()
            obj_.build(child_)
            self.FreeTextLine.append(obj_)
        elif nodeName_ == 'Feature':
            obj_ = FeatureType.factory()
            obj_.build(child_)
            self.Feature.append(obj_)
        elif nodeName_ == 'BodyMark':
            obj_ = BodyMarkType.factory()
            obj_.build(child_)
            self.BodyMark.append(obj_)
        elif nodeName_ == 'Disability':
            obj_ = DisabilityType.factory()
            obj_.build(child_)
            self.Disability.append(obj_)
        elif nodeName_ == 'Allergy':
            obj_ = AllergyType.factory()
            obj_.build(child_)
            self.Allergy.append(obj_)
        elif nodeName_ == 'HealthCondition':
            obj_ = HealthConditionType.factory()
            obj_.build(child_)
            self.HealthCondition.append(obj_)
# end class PhysicalInfo


class Preferences(GeneratedsSuper):
    """A container for a list of preferences of a person (e.g. seat
    position in flight, restuarants)"""
    subclass = None
    superclass = None
    def __init__(self, Preference=None):
        if Preference is None:
            self.Preference = []
        else:
            self.Preference = Preference
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Preferences.subclass:
            return Preferences.subclass(*args_, **kwargs_)
        else:
            return Preferences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Preference(self): return self.Preference
    def set_Preference(self, Preference): self.Preference = Preference
    def add_Preference(self, value): self.Preference.append(value)
    def insert_Preference(self, index, value): self.Preference[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Preferences', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Preferences')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Preferences'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Preferences', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Preference_ in self.Preference:
            Preference_.export(outfile, level, namespace_, name_='Preference', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Preference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Preferences'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Preference=[\n')
        level += 1
        for Preference_ in self.Preference:
            showIndent(outfile, level)
            outfile.write('model_.PreferenceType(\n')
            Preference_.exportLiteral(outfile, level, name_='PreferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Preference':
            obj_ = PreferenceType.factory()
            obj_.build(child_)
            self.Preference.append(obj_)
# end class Preferences


class Qualifications(GeneratedsSuper):
    """A container for a list of qualifications of a person"""
    subclass = None
    superclass = None
    def __init__(self, Qualification=None):
        if Qualification is None:
            self.Qualification = []
        else:
            self.Qualification = Qualification
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Qualifications.subclass:
            return Qualifications.subclass(*args_, **kwargs_)
        else:
            return Qualifications(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Qualification(self): return self.Qualification
    def set_Qualification(self, Qualification): self.Qualification = Qualification
    def add_Qualification(self, value): self.Qualification.append(value)
    def insert_Qualification(self, index, value): self.Qualification[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Qualifications', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Qualifications')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Qualifications'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Qualifications', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Qualification_ in self.Qualification:
            Qualification_.export(outfile, level, namespace_, name_='Qualification', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Qualification
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Qualifications'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Qualification=[\n')
        level += 1
        for Qualification_ in self.Qualification:
            showIndent(outfile, level)
            outfile.write('model_.QualificationType(\n')
            Qualification_.exportLiteral(outfile, level, name_='QualificationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Qualification':
            obj_ = QualificationType.factory()
            obj_.build(child_)
            self.Qualification.append(obj_)
# end class Qualifications


class Visas(GeneratedsSuper):
    """A container to define the VISAs held by a person (e.g. visitor,
    temporary, permanent resident, work, etc)"""
    subclass = None
    superclass = None
    def __init__(self, Visa=None):
        if Visa is None:
            self.Visa = []
        else:
            self.Visa = Visa
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Visas.subclass:
            return Visas.subclass(*args_, **kwargs_)
        else:
            return Visas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Visa(self): return self.Visa
    def set_Visa(self, Visa): self.Visa = Visa
    def add_Visa(self, value): self.Visa.append(value)
    def insert_Visa(self, index, value): self.Visa[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Visas', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Visas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Visas'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Visas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Visa_ in self.Visa:
            Visa_.export(outfile, level, namespace_, name_='Visa', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Visa
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Visas'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Visa=[\n')
        level += 1
        for Visa_ in self.Visa:
            showIndent(outfile, level)
            outfile.write('model_.VisaType(\n')
            Visa_.exportLiteral(outfile, level, name_='VisaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Visa':
            obj_ = VisaType.factory()
            obj_.build(child_)
            self.Visa.append(obj_)
# end class Visas


class PartyNameType(GeneratedsSuper):
    """Reusable complex type for a party. A party is a person or an
    organisationA unique identifier of a partyType of Party Name
    IDGlobally unique identifierTye of use of this data. e.g. data
    exchange, contact, update, createStatus of the entity. e.g. Old,
    Current, Inactive, Active, etcThe connector used to join more
    than one person name. Example: Mr Hunt AND Mrs Clark, where AND
    is the JointNameConnector. The flow is from the preceding to the
    following. If there is more than 2 names then all names are
    connected using this connector in the natural order."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, PartyNameIDType=None, ValidTo=None, DateValidFrom=None, JointNameConnector=None, ID=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, label=None, type_=None, PartyNameID=None, NameLine=None, PersonName=None, OrganisationName=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.NameKeyRef = _cast(None, NameKeyRef)
        self.PartyNameIDType = _cast(None, PartyNameIDType)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.JointNameConnector = _cast(None, JointNameConnector)
        self.ID = _cast(None, ID)
        self.DateValidTo = _cast(None, DateValidTo)
        self.href = _cast(None, href)
        self.ValidFrom = _cast(None, ValidFrom)
        self.NameKey = _cast(None, NameKey)
        self.Usage = _cast(None, Usage)
        self.DataQualityType = _cast(None, DataQualityType)
        self.label = _cast(None, label)
        self.type_ = _cast(None, type_)
        self.PartyNameID = _cast(None, PartyNameID)
        if NameLine is None:
            self.NameLine = []
        else:
            self.NameLine = NameLine
        if PersonName is None:
            self.PersonName = []
        else:
            self.PersonName = PersonName
        if OrganisationName is None:
            self.OrganisationName = []
        else:
            self.OrganisationName = OrganisationName
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PartyNameType.subclass:
            return PartyNameType.subclass(*args_, **kwargs_)
        else:
            return PartyNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameLine(self): return self.NameLine
    def set_NameLine(self, NameLine): self.NameLine = NameLine
    def add_NameLine(self, value): self.NameLine.append(value)
    def insert_NameLine(self, index, value): self.NameLine[index] = value
    def get_PersonName(self): return self.PersonName
    def set_PersonName(self, PersonName): self.PersonName = PersonName
    def add_PersonName(self, value): self.PersonName.append(value)
    def insert_PersonName(self, index, value): self.PersonName[index] = value
    def get_OrganisationName(self): return self.OrganisationName
    def set_OrganisationName(self, OrganisationName): self.OrganisationName = OrganisationName
    def add_OrganisationName(self, value): self.OrganisationName.append(value)
    def insert_OrganisationName(self, index, value): self.OrganisationName[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_NameKeyRef(self): return self.NameKeyRef
    def set_NameKeyRef(self, NameKeyRef): self.NameKeyRef = NameKeyRef
    def get_PartyNameIDType(self): return self.PartyNameIDType
    def set_PartyNameIDType(self, PartyNameIDType): self.PartyNameIDType = PartyNameIDType
    def validate_PartyNameIDTypeList(self, value):
        # Validate type PartyNameIDTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_JointNameConnector(self): return self.JointNameConnector
    def set_JointNameConnector(self, JointNameConnector): self.JointNameConnector = JointNameConnector
    def validate_JointNameConnectorList(self, value):
        # Validate type JointNameConnectorList, a restriction on xs:normalizedString.
        pass
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_NameKey(self): return self.NameKey
    def set_NameKey(self, NameKey): self.NameKey = NameKey
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_PartyNameUsageList(self, value):
        # Validate type PartyNameUsageList, a restriction on xs:string.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_PartyNameID(self): return self.PartyNameID
    def set_PartyNameID(self, PartyNameID): self.PartyNameID = PartyNameID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PartyNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartyNameType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
           xsinamespaceprefix = 'xsi'
           xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
           xsinamespace2 = '{%s}' % (xsinamespace1, )
           if name.startswith(xsinamespace2):
               name1 = name[len(xsinamespace2):]
               name2 = '%s:%s' % (xsinamespaceprefix, name1, )
               if name2 not in already_processed:
                   already_processed.append(name2)
                   outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
           else:
               mo = re_.match(Namespace_extract_pat_, name)
               if mo is not None:
                   namespace, name = mo.group(1, 2)
                   if name not in already_processed:
                       already_processed.append(name)
                       if namespace == 'http://www.w3.org/XML/1998/namespace':
                           outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                       else:
                           unique_counter += 1
                           outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                           outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
               else:
                   if name not in already_processed:
                       already_processed.append(name)
                       outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' n:Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' ct:LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.NameKeyRef is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            outfile.write(' n:NameKeyRef=%s' % (quote_attrib(self.NameKeyRef), ))
        if self.PartyNameIDType is not None and 'PartyNameIDType' not in already_processed:
            already_processed.append('PartyNameIDType')
            outfile.write(' n:PartyNameIDType=%s' % (quote_attrib(self.PartyNameIDType), ))
        if self.ValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ct:ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' n:DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.JointNameConnector is not None and 'JointNameConnector' not in already_processed:
            already_processed.append('JointNameConnector')
            outfile.write(' n:JointNameConnector=%s' % (quote_attrib(self.JointNameConnector), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' n:ID=%s' % (quote_attrib(self.ID), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' n:DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' xlink:href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ct:ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.NameKey is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            outfile.write(' n:NameKey=%s' % (quote_attrib(self.NameKey), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' n:Usage=%s' % (quote_attrib(self.Usage), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' ct:DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' xlink:label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' xlink:type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.PartyNameID is not None and 'PartyNameID' not in already_processed:
            already_processed.append('PartyNameID')
            outfile.write(' n:PartyNameID=%s' % (quote_attrib(self.PartyNameID), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PartyNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameLine_ in self.NameLine:
            NameLine_.export(outfile, level, "n:", name_='NameLine', pretty_print=pretty_print)
        for PersonName_ in self.PersonName:
            PersonName_.export(outfile, level, "n:", name_='PersonName', pretty_print=pretty_print)
        for OrganisationName_ in self.OrganisationName:
            OrganisationName_.export(outfile, level, "n:", name_='OrganisationName', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameLine or
            self.PersonName or
            self.OrganisationName
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PartyNameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.NameKeyRef is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            showIndent(outfile, level)
            outfile.write('NameKeyRef = %s,\n' % (self.NameKeyRef,))
        if self.PartyNameIDType is not None and 'PartyNameIDType' not in already_processed:
            already_processed.append('PartyNameIDType')
            showIndent(outfile, level)
            outfile.write('PartyNameIDType = "%s",\n' % (self.PartyNameIDType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.JointNameConnector is not None and 'JointNameConnector' not in already_processed:
            already_processed.append('JointNameConnector')
            showIndent(outfile, level)
            outfile.write('JointNameConnector = "%s",\n' % (self.JointNameConnector,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %s,\n' % (self.ID,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.NameKey is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            showIndent(outfile, level)
            outfile.write('NameKey = %s,\n' % (self.NameKey,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.PartyNameID is not None and 'PartyNameID' not in already_processed:
            already_processed.append('PartyNameID')
            showIndent(outfile, level)
            outfile.write('PartyNameID = %s,\n' % (self.PartyNameID,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameLine=[\n')
        level += 1
        for NameLine_ in self.NameLine:
            showIndent(outfile, level)
            outfile.write('model_.NameLine(\n')
            NameLine_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PersonName=[\n')
        level += 1
        for PersonName_ in self.PersonName:
            showIndent(outfile, level)
            outfile.write('model_.PersonNameType1(\n')
            PersonName_.exportLiteral(outfile, level, name_='PersonNameType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OrganisationName=[\n')
        level += 1
        for OrganisationName_ in self.OrganisationName:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationNameType1(\n')
            OrganisationName_.exportLiteral(outfile, level, name_='OrganisationNameType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('NameKeyRef', node)
        if value is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            self.NameKeyRef = value
        value = find_attr_value_('PartyNameIDType', node)
        if value is not None and 'PartyNameIDType' not in already_processed:
            already_processed.append('PartyNameIDType')
            self.PartyNameIDType = value
            self.validate_PartyNameIDTypeList(self.PartyNameIDType)    # validate type PartyNameIDTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('JointNameConnector', node)
        if value is not None and 'JointNameConnector' not in already_processed:
            already_processed.append('JointNameConnector')
            self.JointNameConnector = value
            self.validate_JointNameConnectorList(self.JointNameConnector)    # validate type JointNameConnectorList
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('NameKey', node)
        if value is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            self.NameKey = value
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_PartyNameUsageList(self.Usage)    # validate type PartyNameUsageList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('PartyNameID', node)
        if value is not None and 'PartyNameID' not in already_processed:
            already_processed.append('PartyNameID')
            self.PartyNameID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameLine':
            obj_ = NameLine.factory()
            obj_.build(child_)
            self.NameLine.append(obj_)
        elif nodeName_ == 'PersonName':
            obj_ = PersonNameType1.factory()
            obj_.build(child_)
            self.PersonName.append(obj_)
        elif nodeName_ == 'OrganisationName':
            obj_ = OrganisationNameType1.factory()
            obj_.build(child_)
            self.OrganisationName.append(obj_)
# end class PartyNameType


class PersonNameType(GeneratedsSuper):
    """Reusable complex typeEnumerated list of type of name. example:
    Alias, Nick Name, former name, known as, etcA unique identifier
    of a personType of identifierGlobally unique identifierUsage of
    a person name. How is it used and for what purpose. Allows user
    which name in a set of names to select for a given purpose. e.g.
    used for legal purposesStatus of the entity. e.g. Old, Current,
    Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, PersonID=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, PersonIDType=None, NameKey=None, Usage=None, DataQualityType=None, ValidFrom=None, Type=None, ID=None, NameElement=None, extensiontype_=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.NameKeyRef = _cast(None, NameKeyRef)
        self.PersonID = _cast(None, PersonID)
        self.type_ = _cast(None, type_)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.label = _cast(None, label)
        self.DateValidTo = _cast(None, DateValidTo)
        self.href = _cast(None, href)
        self.PersonIDType = _cast(None, PersonIDType)
        self.NameKey = _cast(None, NameKey)
        self.Usage = _cast(None, Usage)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PersonNameType.subclass:
            return PersonNameType.subclass(*args_, **kwargs_)
        else:
            return PersonNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_NameKeyRef(self): return self.NameKeyRef
    def set_NameKeyRef(self, NameKeyRef): self.NameKeyRef = NameKeyRef
    def get_PersonID(self): return self.PersonID
    def set_PersonID(self, PersonID): self.PersonID = PersonID
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_PersonIDType(self): return self.PersonIDType
    def set_PersonIDType(self, PersonIDType): self.PersonIDType = PersonIDType
    def validate_PersonIDTypeList(self, value):
        # Validate type PersonIDTypeList, a restriction on xs:normalizedString.
        pass
    def get_NameKey(self): return self.NameKey
    def set_NameKey(self, NameKey): self.NameKey = NameKey
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_PersonNameUsageList(self, value):
        # Validate type PersonNameUsageList, a restriction on xs:normalizedString.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PersonNameTypeList(self, value):
        # Validate type PersonNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='PersonNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonNameType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.NameKeyRef is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            outfile.write(' NameKeyRef=%s' % (quote_attrib(self.NameKeyRef), ))
        if self.PersonID is not None and 'PersonID' not in already_processed:
            already_processed.append('PersonID')
            outfile.write(' PersonID=%s' % (quote_attrib(self.PersonID), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.PersonIDType is not None and 'PersonIDType' not in already_processed:
            already_processed.append('PersonIDType')
            outfile.write(' PersonIDType=%s' % (quote_attrib(self.PersonIDType), ))
        if self.NameKey is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            outfile.write(' NameKey=%s' % (quote_attrib(self.NameKey), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='PersonNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonNameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.NameKeyRef is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            showIndent(outfile, level)
            outfile.write('NameKeyRef = %s,\n' % (self.NameKeyRef,))
        if self.PersonID is not None and 'PersonID' not in already_processed:
            already_processed.append('PersonID')
            showIndent(outfile, level)
            outfile.write('PersonID = %s,\n' % (self.PersonID,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.PersonIDType is not None and 'PersonIDType' not in already_processed:
            already_processed.append('PersonIDType')
            showIndent(outfile, level)
            outfile.write('PersonIDType = "%s",\n' % (self.PersonIDType,))
        if self.NameKey is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            showIndent(outfile, level)
            outfile.write('NameKey = %s,\n' % (self.NameKey,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %s,\n' % (self.ID,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('NameKeyRef', node)
        if value is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            self.NameKeyRef = value
        value = find_attr_value_('PersonID', node)
        if value is not None and 'PersonID' not in already_processed:
            already_processed.append('PersonID')
            self.PersonID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('PersonIDType', node)
        if value is not None and 'PersonIDType' not in already_processed:
            already_processed.append('PersonIDType')
            self.PersonIDType = value
            self.validate_PersonIDTypeList(self.PersonIDType)    # validate type PersonIDTypeList
        value = find_attr_value_('NameKey', node)
        if value is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            self.NameKey = value
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_PersonNameUsageList(self.Usage)    # validate type PersonNameUsageList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PersonNameTypeList(self.Type)    # validate type PersonNameTypeList
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
# end class PersonNameType


class OrganisationNameType(GeneratedsSuper):
    """Reusable complex typeEnumerated list of common types of aliases or
    name types.A unique identifier of an organisationType of
    identifierGlobally unique identiferUsage of organisation name.
    How is it used and for what purpose. Allows user which name in a
    set of names to select for a given purpose. e.g. used for legal
    purposesStatus of the entity. e.g. Old, Current, Inactive,
    Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None, extensiontype_=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.NameKeyRef = _cast(None, NameKeyRef)
        self.type_ = _cast(None, type_)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.label = _cast(None, label)
        self.DateValidTo = _cast(None, DateValidTo)
        self.href = _cast(None, href)
        self.ValidFrom = _cast(None, ValidFrom)
        self.NameKey = _cast(None, NameKey)
        self.Usage = _cast(None, Usage)
        self.DataQualityType = _cast(None, DataQualityType)
        self.OrganisationID = _cast(None, OrganisationID)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.OrganisationIDType = _cast(None, OrganisationIDType)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        if SubDivisionName is None:
            self.SubDivisionName = []
        else:
            self.SubDivisionName = SubDivisionName
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if OrganisationNameType.subclass:
            return OrganisationNameType.subclass(*args_, **kwargs_)
        else:
            return OrganisationNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_SubDivisionName(self): return self.SubDivisionName
    def set_SubDivisionName(self, SubDivisionName): self.SubDivisionName = SubDivisionName
    def add_SubDivisionName(self, value): self.SubDivisionName.append(value)
    def insert_SubDivisionName(self, index, value): self.SubDivisionName[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_NameKeyRef(self): return self.NameKeyRef
    def set_NameKeyRef(self, NameKeyRef): self.NameKeyRef = NameKeyRef
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_NameKey(self): return self.NameKey
    def set_NameKey(self, NameKey): self.NameKey = NameKey
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_OrganisationNameUsageList(self, value):
        # Validate type OrganisationNameUsageList, a restriction on xs:normalizedString.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_OrganisationID(self): return self.OrganisationID
    def set_OrganisationID(self, OrganisationID): self.OrganisationID = OrganisationID
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_OrganisationNameTypeList(self, value):
        # Validate type OrganisationNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_OrganisationIDType(self): return self.OrganisationIDType
    def set_OrganisationIDType(self, OrganisationIDType): self.OrganisationIDType = OrganisationIDType
    def validate_OrganisationIDTypeList(self, value):
        # Validate type OrganisationIDTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='OrganisationNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationNameType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.NameKeyRef is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            outfile.write(' NameKeyRef=%s' % (quote_attrib(self.NameKeyRef), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.NameKey is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            outfile.write(' NameKey=%s' % (quote_attrib(self.NameKey), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.OrganisationID is not None and 'OrganisationID' not in already_processed:
            already_processed.append('OrganisationID')
            outfile.write(' OrganisationID=%s' % (quote_attrib(self.OrganisationID), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.OrganisationIDType is not None and 'OrganisationIDType' not in already_processed:
            already_processed.append('OrganisationIDType')
            outfile.write(' OrganisationIDType=%s' % (quote_attrib(self.OrganisationIDType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
        for SubDivisionName_ in self.SubDivisionName:
            SubDivisionName_.export(outfile, level, namespace_, name_='SubDivisionName', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement or
            self.SubDivisionName
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrganisationNameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.NameKeyRef is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            showIndent(outfile, level)
            outfile.write('NameKeyRef = %s,\n' % (self.NameKeyRef,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.NameKey is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            showIndent(outfile, level)
            outfile.write('NameKey = %s,\n' % (self.NameKey,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.OrganisationID is not None and 'OrganisationID' not in already_processed:
            already_processed.append('OrganisationID')
            showIndent(outfile, level)
            outfile.write('OrganisationID = %s,\n' % (self.OrganisationID,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %s,\n' % (self.ID,))
        if self.OrganisationIDType is not None and 'OrganisationIDType' not in already_processed:
            already_processed.append('OrganisationIDType')
            showIndent(outfile, level)
            outfile.write('OrganisationIDType = "%s",\n' % (self.OrganisationIDType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType1(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SubDivisionName=[\n')
        level += 1
        for SubDivisionName_ in self.SubDivisionName:
            showIndent(outfile, level)
            outfile.write('model_.SubDivisionNameType(\n')
            SubDivisionName_.exportLiteral(outfile, level, name_='SubDivisionNameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('NameKeyRef', node)
        if value is not None and 'NameKeyRef' not in already_processed:
            already_processed.append('NameKeyRef')
            self.NameKeyRef = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('NameKey', node)
        if value is not None and 'NameKey' not in already_processed:
            already_processed.append('NameKey')
            self.NameKey = value
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_OrganisationNameUsageList(self.Usage)    # validate type OrganisationNameUsageList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('OrganisationID', node)
        if value is not None and 'OrganisationID' not in already_processed:
            already_processed.append('OrganisationID')
            self.OrganisationID = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_OrganisationNameTypeList(self.Type)    # validate type OrganisationNameTypeList
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('OrganisationIDType', node)
        if value is not None and 'OrganisationIDType' not in already_processed:
            already_processed.append('OrganisationIDType')
            self.OrganisationIDType = value
            self.validate_OrganisationIDTypeList(self.OrganisationIDType)    # validate type OrganisationIDTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType1.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
        elif nodeName_ == 'SubDivisionName':
            obj_ = SubDivisionNameType.factory()
            obj_.build(child_)
            self.SubDivisionName.append(obj_)
# end class OrganisationNameType


class NameLine(GeneratedsSuper):
    """ Define name as a free format text. Use this when the type of the
    entity (person or organisation) is unknown, or is not broken
    down into individual elements (e.g. unstructured, unparsed) or
    is beyond the provided types. The name represented may be
    formatted in the right order or may not be as it is not
    parsed/broken into atomic fieldsType define what this free
    format name line could mean. For example, the Type could be
    "Unknown" """
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameLine.subclass:
            return NameLine.subclass(*args_, **kwargs_)
        else:
            return NameLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_NameLineTypeList(self, value):
        # Validate type NameLineTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameLine', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameLine')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameLine'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameLine', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameLine'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_NameLineTypeList(self.Type)    # validate type NameLineTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameLine


class AddressType(GeneratedsSuper):
    """Complex type that defines the structure of an address with geocode
    details for reuseDefines the type of address. An address type
    can be" Primary Address, Secondary Address, Rural Address,
    Military Address, etc.A unique address identifier such as postal
    delivery idetifier assigned to the address by local postal
    authority, e.g. DPID in Australia.Type of address ID used. e.g.
    DPID, etcA globally unique identifier assigned to the addressThe
    purpose the address is used for. E.g. Postal, residential,
    business, exchange, update, create, delete, etcMode of delivery
    of address. For example: rural route, normal delivery, post
    office box, etc. Status of the entity. e.g. Old, Current,
    Inactive, Active, etcA primary key to reference Address.A
    foreign key to reference attribute Key of Address."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, LanguageCode=None, ValidFrom=None, DeliveryMode=None, AddressID=None, type_=None, ValidTo=None, DateValidFrom=None, AddressKey=None, DateValidTo=None, href=None, DataQualityType=None, Usage=None, AddressIDType=None, label=None, Type=None, ID=None, AddressKeyRef=None, FreeTextAddress=None, Country=None, AdministrativeArea=None, Locality=None, Thoroughfare=None, Premises=None, PostCode=None, RuralDelivery=None, PostalDeliveryPoint=None, PostOffice=None, GeoRSS=None, LocationByCoordinates=None, extensiontype_=None):
        self.Status = _cast(None, Status)
        self.LanguageCode = _cast(None, LanguageCode)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DeliveryMode = _cast(None, DeliveryMode)
        self.AddressID = _cast(None, AddressID)
        self.type_ = _cast(None, type_)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.AddressKey = _cast(None, AddressKey)
        self.DateValidTo = _cast(None, DateValidTo)
        self.href = _cast(None, href)
        self.DataQualityType = _cast(None, DataQualityType)
        self.Usage = _cast(None, Usage)
        self.AddressIDType = _cast(None, AddressIDType)
        self.label = _cast(None, label)
        self.Type = _cast(None, Type)
        self.ID = _cast(None, ID)
        self.AddressKeyRef = _cast(None, AddressKeyRef)
        self.FreeTextAddress = FreeTextAddress
        self.Country = Country
        self.AdministrativeArea = AdministrativeArea
        self.Locality = Locality
        self.Thoroughfare = Thoroughfare
        self.Premises = Premises
        self.PostCode = PostCode
        self.RuralDelivery = RuralDelivery
        self.PostalDeliveryPoint = PostalDeliveryPoint
        self.PostOffice = PostOffice
        self.GeoRSS = GeoRSS
        self.LocationByCoordinates = LocationByCoordinates
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AddressType.subclass:
            return AddressType.subclass(*args_, **kwargs_)
        else:
            return AddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FreeTextAddress(self): return self.FreeTextAddress
    def set_FreeTextAddress(self, FreeTextAddress): self.FreeTextAddress = FreeTextAddress
    def get_Country(self): return self.Country
    def set_Country(self, Country): self.Country = Country
    def get_AdministrativeArea(self): return self.AdministrativeArea
    def set_AdministrativeArea(self, AdministrativeArea): self.AdministrativeArea = AdministrativeArea
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def get_Thoroughfare(self): return self.Thoroughfare
    def set_Thoroughfare(self, Thoroughfare): self.Thoroughfare = Thoroughfare
    def get_Premises(self): return self.Premises
    def set_Premises(self, Premises): self.Premises = Premises
    def get_PostCode(self): return self.PostCode
    def set_PostCode(self, PostCode): self.PostCode = PostCode
    def get_RuralDelivery(self): return self.RuralDelivery
    def set_RuralDelivery(self, RuralDelivery): self.RuralDelivery = RuralDelivery
    def get_PostalDeliveryPoint(self): return self.PostalDeliveryPoint
    def set_PostalDeliveryPoint(self, PostalDeliveryPoint): self.PostalDeliveryPoint = PostalDeliveryPoint
    def get_PostOffice(self): return self.PostOffice
    def set_PostOffice(self, PostOffice): self.PostOffice = PostOffice
    def get_GeoRSS(self): return self.GeoRSS
    def set_GeoRSS(self, GeoRSS): self.GeoRSS = GeoRSS
    def get_LocationByCoordinates(self): return self.LocationByCoordinates
    def set_LocationByCoordinates(self, LocationByCoordinates): self.LocationByCoordinates = LocationByCoordinates
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_LanguageCode(self): return self.LanguageCode
    def set_LanguageCode(self, LanguageCode): self.LanguageCode = LanguageCode
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DeliveryMode(self): return self.DeliveryMode
    def set_DeliveryMode(self, DeliveryMode): self.DeliveryMode = DeliveryMode
    def validate_DeliveryModeList(self, value):
        # Validate type DeliveryModeList, a restriction on xs:normalizedString.
        pass
    def get_AddressID(self): return self.AddressID
    def set_AddressID(self, AddressID): self.AddressID = AddressID
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_AddressKey(self): return self.AddressKey
    def set_AddressKey(self, AddressKey): self.AddressKey = AddressKey
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_AddressUsageList(self, value):
        # Validate type AddressUsageList, a restriction on xs:normalizedString.
        pass
    def get_AddressIDType(self): return self.AddressIDType
    def set_AddressIDType(self, AddressIDType): self.AddressIDType = AddressIDType
    def validate_AddressIDTypeList(self, value):
        # Validate type AddressIDTypeList, a restriction on xs:normalizedString.
        pass
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AddressTypeList(self, value):
        # Validate type AddressTypeList, a restriction on xs:normalizedString.
        pass
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_AddressKeyRef(self): return self.AddressKeyRef
    def set_AddressKeyRef(self, AddressKeyRef): self.AddressKeyRef = AddressKeyRef
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='AddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            outfile.write(' LanguageCode=%s' % (self.gds_format_string(quote_attrib(self.LanguageCode).encode(ExternalEncoding), input_name='LanguageCode'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DeliveryMode is not None and 'DeliveryMode' not in already_processed:
            already_processed.append('DeliveryMode')
            outfile.write(' DeliveryMode=%s' % (quote_attrib(self.DeliveryMode), ))
        if self.AddressID is not None and 'AddressID' not in already_processed:
            already_processed.append('AddressID')
            outfile.write(' AddressID=%s' % (quote_attrib(self.AddressID), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.AddressKey is not None and 'AddressKey' not in already_processed:
            already_processed.append('AddressKey')
            outfile.write(' AddressKey=%s' % (quote_attrib(self.AddressKey), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.AddressIDType is not None and 'AddressIDType' not in already_processed:
            already_processed.append('AddressIDType')
            outfile.write(' AddressIDType=%s' % (quote_attrib(self.AddressIDType), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
        if self.AddressKeyRef is not None and 'AddressKeyRef' not in already_processed:
            already_processed.append('AddressKeyRef')
            outfile.write(' AddressKeyRef=%s' % (quote_attrib(self.AddressKeyRef), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FreeTextAddress is not None:
            self.FreeTextAddress.export(outfile, level, namespace_, name_='FreeTextAddress', pretty_print=pretty_print)
        if self.Country is not None:
            self.Country.export(outfile, level, namespace_, name_='Country', pretty_print=pretty_print)
        if self.AdministrativeArea is not None:
            self.AdministrativeArea.export(outfile, level, namespace_, name_='AdministrativeArea', pretty_print=pretty_print)
        if self.Locality is not None:
            self.Locality.export(outfile, level, namespace_, name_='Locality', pretty_print=pretty_print)
        if self.Thoroughfare is not None:
            self.Thoroughfare.export(outfile, level, namespace_, name_='Thoroughfare', pretty_print=pretty_print)
        if self.Premises is not None:
            self.Premises.export(outfile, level, namespace_, name_='Premises', pretty_print=pretty_print)
        if self.PostCode is not None:
            self.PostCode.export(outfile, level, namespace_, name_='PostCode', pretty_print=pretty_print)
        if self.RuralDelivery is not None:
            self.RuralDelivery.export(outfile, level, namespace_, name_='RuralDelivery', pretty_print=pretty_print)
        if self.PostalDeliveryPoint is not None:
            self.PostalDeliveryPoint.export(outfile, level, namespace_, name_='PostalDeliveryPoint', pretty_print=pretty_print)
        if self.PostOffice is not None:
            self.PostOffice.export(outfile, level, namespace_, name_='PostOffice', pretty_print=pretty_print)
        if self.GeoRSS is not None:
            self.GeoRSS.export(outfile, level, namespace_, name_='GeoRSS', pretty_print=pretty_print)
        if self.LocationByCoordinates is not None:
            self.LocationByCoordinates.export(outfile, level, namespace_, name_='LocationByCoordinates', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.FreeTextAddress is not None or
            self.Country is not None or
            self.AdministrativeArea is not None or
            self.Locality is not None or
            self.Thoroughfare is not None or
            self.Premises is not None or
            self.PostCode is not None or
            self.RuralDelivery is not None or
            self.PostalDeliveryPoint is not None or
            self.PostOffice is not None or
            self.GeoRSS is not None or
            self.LocationByCoordinates is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AddressType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.LanguageCode is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            showIndent(outfile, level)
            outfile.write('LanguageCode = "%s",\n' % (self.LanguageCode,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DeliveryMode is not None and 'DeliveryMode' not in already_processed:
            already_processed.append('DeliveryMode')
            showIndent(outfile, level)
            outfile.write('DeliveryMode = "%s",\n' % (self.DeliveryMode,))
        if self.AddressID is not None and 'AddressID' not in already_processed:
            already_processed.append('AddressID')
            showIndent(outfile, level)
            outfile.write('AddressID = %s,\n' % (self.AddressID,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.AddressKey is not None and 'AddressKey' not in already_processed:
            already_processed.append('AddressKey')
            showIndent(outfile, level)
            outfile.write('AddressKey = %s,\n' % (self.AddressKey,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.AddressIDType is not None and 'AddressIDType' not in already_processed:
            already_processed.append('AddressIDType')
            showIndent(outfile, level)
            outfile.write('AddressIDType = "%s",\n' % (self.AddressIDType,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %s,\n' % (self.ID,))
        if self.AddressKeyRef is not None and 'AddressKeyRef' not in already_processed:
            already_processed.append('AddressKeyRef')
            showIndent(outfile, level)
            outfile.write('AddressKeyRef = %s,\n' % (self.AddressKeyRef,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FreeTextAddress is not None:
            showIndent(outfile, level)
            outfile.write('FreeTextAddress=model_.FreeTextAddressType(\n')
            self.FreeTextAddress.exportLiteral(outfile, level, name_='FreeTextAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Country is not None:
            showIndent(outfile, level)
            outfile.write('Country=model_.CountryType3(\n')
            self.Country.exportLiteral(outfile, level, name_='Country')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AdministrativeArea is not None:
            showIndent(outfile, level)
            outfile.write('AdministrativeArea=model_.AdministrativeAreaType(\n')
            self.AdministrativeArea.exportLiteral(outfile, level, name_='AdministrativeArea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Locality is not None:
            showIndent(outfile, level)
            outfile.write('Locality=model_.LocalityType(\n')
            self.Locality.exportLiteral(outfile, level, name_='Locality')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Thoroughfare is not None:
            showIndent(outfile, level)
            outfile.write('Thoroughfare=model_.ThoroughfareType1(\n')
            self.Thoroughfare.exportLiteral(outfile, level, name_='Thoroughfare')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Premises is not None:
            showIndent(outfile, level)
            outfile.write('Premises=model_.PremisesType1(\n')
            self.Premises.exportLiteral(outfile, level, name_='Premises')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PostCode is not None:
            showIndent(outfile, level)
            outfile.write('PostCode=model_.PostCodeType(\n')
            self.PostCode.exportLiteral(outfile, level, name_='PostCode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RuralDelivery is not None:
            showIndent(outfile, level)
            outfile.write('RuralDelivery=model_.RuralDeliveryType(\n')
            self.RuralDelivery.exportLiteral(outfile, level, name_='RuralDelivery')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PostalDeliveryPoint is not None:
            showIndent(outfile, level)
            outfile.write('PostalDeliveryPoint=model_.PostalDeliveryPointType(\n')
            self.PostalDeliveryPoint.exportLiteral(outfile, level, name_='PostalDeliveryPoint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PostOffice is not None:
            showIndent(outfile, level)
            outfile.write('PostOffice=model_.PostOfficeType(\n')
            self.PostOffice.exportLiteral(outfile, level, name_='PostOffice')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GeoRSS is not None:
            showIndent(outfile, level)
            outfile.write('GeoRSS=model_.GeoRSSType(\n')
            self.GeoRSS.exportLiteral(outfile, level, name_='GeoRSS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocationByCoordinates is not None:
            showIndent(outfile, level)
            outfile.write('LocationByCoordinates=model_.LocationByCoordinatesType(\n')
            self.LocationByCoordinates.exportLiteral(outfile, level, name_='LocationByCoordinates')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('LanguageCode', node)
        if value is not None and 'LanguageCode' not in already_processed:
            already_processed.append('LanguageCode')
            self.LanguageCode = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DeliveryMode', node)
        if value is not None and 'DeliveryMode' not in already_processed:
            already_processed.append('DeliveryMode')
            self.DeliveryMode = value
            self.validate_DeliveryModeList(self.DeliveryMode)    # validate type DeliveryModeList
        value = find_attr_value_('AddressID', node)
        if value is not None and 'AddressID' not in already_processed:
            already_processed.append('AddressID')
            self.AddressID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('AddressKey', node)
        if value is not None and 'AddressKey' not in already_processed:
            already_processed.append('AddressKey')
            self.AddressKey = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_AddressUsageList(self.Usage)    # validate type AddressUsageList
        value = find_attr_value_('AddressIDType', node)
        if value is not None and 'AddressIDType' not in already_processed:
            already_processed.append('AddressIDType')
            self.AddressIDType = value
            self.validate_AddressIDTypeList(self.AddressIDType)    # validate type AddressIDTypeList
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_AddressTypeList(self.Type)    # validate type AddressTypeList
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('AddressKeyRef', node)
        if value is not None and 'AddressKeyRef' not in already_processed:
            already_processed.append('AddressKeyRef')
            self.AddressKeyRef = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FreeTextAddress':
            obj_ = FreeTextAddressType.factory()
            obj_.build(child_)
            self.set_FreeTextAddress(obj_)
        elif nodeName_ == 'Country':
            obj_ = CountryType3.factory()
            obj_.build(child_)
            self.set_Country(obj_)
        elif nodeName_ == 'AdministrativeArea':
            obj_ = AdministrativeAreaType.factory()
            obj_.build(child_)
            self.set_AdministrativeArea(obj_)
        elif nodeName_ == 'Locality':
            obj_ = LocalityType.factory()
            obj_.build(child_)
            self.set_Locality(obj_)
        elif nodeName_ == 'Thoroughfare':
            obj_ = ThoroughfareType1.factory()
            obj_.build(child_)
            self.set_Thoroughfare(obj_)
        elif nodeName_ == 'Premises':
            obj_ = PremisesType1.factory()
            obj_.build(child_)
            self.set_Premises(obj_)
        elif nodeName_ == 'PostCode':
            obj_ = PostCodeType.factory()
            obj_.build(child_)
            self.set_PostCode(obj_)
        elif nodeName_ == 'RuralDelivery':
            obj_ = RuralDeliveryType.factory()
            obj_.build(child_)
            self.set_RuralDelivery(obj_)
        elif nodeName_ == 'PostalDeliveryPoint':
            obj_ = PostalDeliveryPointType.factory()
            obj_.build(child_)
            self.set_PostalDeliveryPoint(obj_)
        elif nodeName_ == 'PostOffice':
            obj_ = PostOfficeType.factory()
            obj_.build(child_)
            self.set_PostOffice(obj_)
        elif nodeName_ == 'GeoRSS':
            obj_ = GeoRSSType.factory()
            obj_.build(child_)
            self.set_GeoRSS(obj_)
        elif nodeName_ == 'LocationByCoordinates':
            obj_ = LocationByCoordinatesType.factory()
            obj_.build(child_)
            self.set_LocationByCoordinates(obj_)
# end class AddressType


class CountryType(GeneratedsSuper):
    """Complex type that defines the name of the country and is reused in
    other CIQ specs"""
    subclass = None
    superclass = None
    def __init__(self, NameElement=None, extensiontype_=None):
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CountryType.subclass:
            return CountryType.subclass(*args_, **kwargs_)
        else:
            return CountryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='CountryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CountryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, "aciq:", name_='NameElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType6(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType6')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType6.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
# end class CountryType


class IdentifierType(GeneratedsSuper):
    """Complex type for internal reuseIndicates which part of number or
    identifier this element contains. Some "numbers" are as simple
    as 42 and some "numbers" are more like complex aplhanumberic
    identifiers as Postcodes in UK or Canada, e.g. M2H 2S5. It may
    be necessary to separate the "number" into sub-elements and
    indicate what type of information each of them contains."""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, Type=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_IdentifierElementTypeList(self, value):
        # Validate type IdentifierElementTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='IdentifierType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdentifierType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_IdentifierElementTypeList(self.Type)    # validate type IdentifierElementTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifierType


class PremisesType(GeneratedsSuper):
    """Complex type for internal reuse"""
    subclass = None
    superclass = None
    def __init__(self, NameElement=None, Number=None, extensiontype_=None):
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        if Number is None:
            self.Number = []
        else:
            self.Number = Number
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PremisesType.subclass:
            return PremisesType.subclass(*args_, **kwargs_)
        else:
            return PremisesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def add_Number(self, value): self.Number.append(value)
    def insert_Number(self, index, value): self.Number[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='PremisesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PremisesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PremisesType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PremisesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
        for Number_ in self.Number:
            Number_.export(outfile, level, namespace_, name_='Number', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement or
            self.Number
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PremisesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType7(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType7')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Number=[\n')
        level += 1
        for Number_ in self.Number:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            Number_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType7.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
        elif nodeName_ == 'Number':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.Number.append(obj_)
# end class PremisesType


class ThoroughfareType(GeneratedsSuper):
    """Complex type for internal reuseType of thoroughfare. eg. primary
    road, secondary road, road branch (e.g. Lane 14), road sub
    branch (e.g. Alley 21), adjourning street, cross street, closest
    street, etcType of code use for thoroughfare"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, TypeCode=None, NameElement=None, Number=None, extensiontype_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.TypeCode = _cast(None, TypeCode)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        if Number is None:
            self.Number = []
        else:
            self.Number = Number
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ThoroughfareType.subclass:
            return ThoroughfareType.subclass(*args_, **kwargs_)
        else:
            return ThoroughfareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def add_Number(self, value): self.Number.append(value)
    def insert_Number(self, index, value): self.Number[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ThoroughfareTypeList(self, value):
        # Validate type ThoroughfareTypeList, a restriction on xs:normalizedString.
        pass
    def get_TypeCode(self): return self.TypeCode
    def set_TypeCode(self, TypeCode): self.TypeCode = TypeCode
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ThoroughfareType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThoroughfareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThoroughfareType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.TypeCode is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            outfile.write(' TypeCode=%s' % (quote_attrib(self.TypeCode), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ThoroughfareType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
        for Number_ in self.Number:
            Number_.export(outfile, level, namespace_, name_='Number', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement or
            self.Number
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ThoroughfareType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.TypeCode is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            showIndent(outfile, level)
            outfile.write('TypeCode = %s,\n' % (self.TypeCode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType8(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType8')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Number=[\n')
        level += 1
        for Number_ in self.Number:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            Number_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_ThoroughfareTypeList(self.Type)    # validate type ThoroughfareTypeList
        value = find_attr_value_('TypeCode', node)
        if value is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            self.TypeCode = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType8.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
        elif nodeName_ == 'Number':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.Number.append(obj_)
# end class ThoroughfareType


class FreeTextLineType(GeneratedsSuper):
    """Type (semantics or category) of free text data"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FreeTextLineType.subclass:
            return FreeTextLineType.subclass(*args_, **kwargs_)
        else:
            return FreeTextLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_FreeTextLineTypeList(self, value):
        # Validate type FreeTextLineTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FreeTextLineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeTextLineType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreeTextLineType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FreeTextLineType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreeTextLineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_FreeTextLineTypeList(self.Type)    # validate type FreeTextLineTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FreeTextLineType


class AccountType(GeneratedsSuper):
    """Type of account. e.g. bank, customer, employee, etcJoint,
    Individual, corporate, etc.Status of the entity. e.g. Old,
    Current, Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, OwnershipType=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, Type=None, ValidTo=None, AccountElement=None, Organisation=None):
        self.Status = _cast(None, Status)
        self.OwnershipType = _cast(None, OwnershipType)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.ValidTo = _cast(None, ValidTo)
        if AccountElement is None:
            self.AccountElement = []
        else:
            self.AccountElement = AccountElement
        self.Organisation = Organisation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AccountType.subclass:
            return AccountType.subclass(*args_, **kwargs_)
        else:
            return AccountType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountElement(self): return self.AccountElement
    def set_AccountElement(self, AccountElement): self.AccountElement = AccountElement
    def add_AccountElement(self, value): self.AccountElement.append(value)
    def insert_AccountElement(self, index, value): self.AccountElement[index] = value
    def get_Organisation(self): return self.Organisation
    def set_Organisation(self, Organisation): self.Organisation = Organisation
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_OwnershipType(self): return self.OwnershipType
    def set_OwnershipType(self, OwnershipType): self.OwnershipType = OwnershipType
    def validate_AccountOwnershipTypeList(self, value):
        # Validate type AccountOwnershipTypeList, a restriction on xs:time.
        pass
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AccountTypeList(self, value):
        # Validate type AccountTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='AccountType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.OwnershipType is not None and 'OwnershipType' not in already_processed:
            already_processed.append('OwnershipType')
            outfile.write(' OwnershipType=%s' % (quote_attrib(self.OwnershipType), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AccountElement_ in self.AccountElement:
            AccountElement_.export(outfile, level, namespace_, name_='AccountElement', pretty_print=pretty_print)
        if self.Organisation is not None:
            self.Organisation.export(outfile, level, namespace_, name_='Organisation', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.AccountElement or
            self.Organisation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccountType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.OwnershipType is not None and 'OwnershipType' not in already_processed:
            already_processed.append('OwnershipType')
            showIndent(outfile, level)
            outfile.write('OwnershipType = "%s",\n' % (self.OwnershipType,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AccountElement=[\n')
        level += 1
        for AccountElement_ in self.AccountElement:
            showIndent(outfile, level)
            outfile.write('model_.AccountElementType(\n')
            AccountElement_.exportLiteral(outfile, level, name_='AccountElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Organisation is not None:
            showIndent(outfile, level)
            outfile.write('Organisation=model_.OrganisationType(\n')
            self.Organisation.exportLiteral(outfile, level, name_='Organisation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('OwnershipType', node)
        if value is not None and 'OwnershipType' not in already_processed:
            already_processed.append('OwnershipType')
            self.OwnershipType = value
            self.validate_AccountOwnershipTypeList(self.OwnershipType)    # validate type AccountOwnershipTypeList
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_AccountTypeList(self.Type)    # validate type AccountTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountElement':
            obj_ = AccountElementType.factory()
            obj_.build(child_)
            self.AccountElement.append(obj_)
        elif nodeName_ == 'Organisation':
            obj_ = OrganisationType.factory()
            obj_.build(child_)
            self.set_Organisation(obj_)
# end class AccountType


class AccountElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AccountElementType.subclass:
            return AccountElementType.subclass(*args_, **kwargs_)
        else:
            return AccountElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AccountElementList(self, value):
        # Validate type AccountElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='AccountElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AccountElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccountElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_AccountElementList(self.Type)    # validate type AccountElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccountElementType


class OrganisationType(OrganisationNameType):
    subclass = None
    superclass = OrganisationNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None):
        super(OrganisationType, self).__init__(Status, LanguageCode, NameKeyRef, type_, ValidTo, DateValidFrom, label, DateValidTo, href, ValidFrom, NameKey, Usage, DataQualityType, OrganisationID, Type, ID, OrganisationIDType, NameElement, SubDivisionName, )
        pass
    def factory(*args_, **kwargs_):
        if OrganisationType.subclass:
            return OrganisationType.subclass(*args_, **kwargs_)
        else:
            return OrganisationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='OrganisationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationType'):
        super(OrganisationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationType')
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationType', fromsubclass_=False, pretty_print=True):
        super(OrganisationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(OrganisationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrganisationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrganisationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrganisationType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OrganisationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OrganisationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OrganisationType


class AddressType1(AddressType):
    subclass = None
    superclass = AddressType
    def __init__(self, Status=None, LanguageCode=None, ValidFrom=None, DeliveryMode=None, AddressID=None, type_=None, ValidTo=None, DateValidFrom=None, AddressKey=None, DateValidTo=None, href=None, DataQualityType=None, Usage=None, AddressIDType=None, label=None, Type=None, ID=None, AddressKeyRef=None, FreeTextAddress=None, Country=None, AdministrativeArea=None, Locality=None, Thoroughfare=None, Premises=None, PostCode=None, RuralDelivery=None, PostalDeliveryPoint=None, PostOffice=None, GeoRSS=None, LocationByCoordinates=None):
        super(AddressType1, self).__init__(Status, LanguageCode, ValidFrom, DeliveryMode, AddressID, type_, ValidTo, DateValidFrom, AddressKey, DateValidTo, href, DataQualityType, Usage, AddressIDType, label, Type, ID, AddressKeyRef, FreeTextAddress, Country, AdministrativeArea, Locality, Thoroughfare, Premises, PostCode, RuralDelivery, PostalDeliveryPoint, PostOffice, GeoRSS, LocationByCoordinates, )
        pass
    def factory(*args_, **kwargs_):
        if AddressType1.subclass:
            return AddressType1.subclass(*args_, **kwargs_)
        else:
            return AddressType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AddressType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressType1'):
        super(AddressType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AddressType1')
    def exportChildren(self, outfile, level, namespace_='', name_='AddressType1', fromsubclass_=False, pretty_print=True):
        super(AddressType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(AddressType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AddressType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AddressType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AddressType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AddressType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AddressType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AddressType1


class ContactNumberType(GeneratedsSuper):
    """Free text explanation of the communication line type. e.g.
    telephone, land line, mobile, fax, pager, etcStatus of the
    entity. e.g. Old, Current, Inactive, Active, etcCurrent Status
    of Contact NumberNature of contact. Example: business, personal,
    free call, toll free, after hours, etcFree text expression of
    contact hours. e.g. 9:00AM-5:00PM"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ValidTo=None, DateValidFrom=None, CommunicationMediaType=None, DateValidTo=None, DataQualityType=None, Usage=None, ValidFrom=None, ContactHours=None, ContactNumberElement=None):
        self.Status = _cast(None, Status)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.CommunicationMediaType = _cast(None, CommunicationMediaType)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.Usage = _cast(None, Usage)
        self.ValidFrom = _cast(None, ValidFrom)
        self.ContactHours = _cast(None, ContactHours)
        if ContactNumberElement is None:
            self.ContactNumberElement = []
        else:
            self.ContactNumberElement = ContactNumberElement
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ContactNumberType.subclass:
            return ContactNumberType.subclass(*args_, **kwargs_)
        else:
            return ContactNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactNumberElement(self): return self.ContactNumberElement
    def set_ContactNumberElement(self, ContactNumberElement): self.ContactNumberElement = ContactNumberElement
    def add_ContactNumberElement(self, value): self.ContactNumberElement.append(value)
    def insert_ContactNumberElement(self, index, value): self.ContactNumberElement[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_CommunicationMediaType(self): return self.CommunicationMediaType
    def set_CommunicationMediaType(self, CommunicationMediaType): self.CommunicationMediaType = CommunicationMediaType
    def validate_CommunicationMediaTypeList(self, value):
        # Validate type CommunicationMediaTypeList, a restriction on xs:normalizedString.
        pass
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_ContactNumberUsageList(self, value):
        # Validate type ContactNumberUsageList, a restriction on xs:normalizedString.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_ContactHours(self): return self.ContactHours
    def set_ContactHours(self, ContactHours): self.ContactHours = ContactHours
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ContactNumberType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactNumberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactNumberType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.CommunicationMediaType is not None and 'CommunicationMediaType' not in already_processed:
            already_processed.append('CommunicationMediaType')
            outfile.write(' CommunicationMediaType=%s' % (quote_attrib(self.CommunicationMediaType), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.ContactHours is not None and 'ContactHours' not in already_processed:
            already_processed.append('ContactHours')
            outfile.write(' ContactHours=%s' % (quote_attrib(self.ContactHours), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContactNumberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ContactNumberElement_ in self.ContactNumberElement:
            ContactNumberElement_.export(outfile, level, namespace_, name_='ContactNumberElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ContactNumberElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactNumberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.CommunicationMediaType is not None and 'CommunicationMediaType' not in already_processed:
            already_processed.append('CommunicationMediaType')
            showIndent(outfile, level)
            outfile.write('CommunicationMediaType = "%s",\n' % (self.CommunicationMediaType,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.ContactHours is not None and 'ContactHours' not in already_processed:
            already_processed.append('ContactHours')
            showIndent(outfile, level)
            outfile.write('ContactHours = %s,\n' % (self.ContactHours,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ContactNumberElement=[\n')
        level += 1
        for ContactNumberElement_ in self.ContactNumberElement:
            showIndent(outfile, level)
            outfile.write('model_.ContactNumberElementType(\n')
            ContactNumberElement_.exportLiteral(outfile, level, name_='ContactNumberElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('CommunicationMediaType', node)
        if value is not None and 'CommunicationMediaType' not in already_processed:
            already_processed.append('CommunicationMediaType')
            self.CommunicationMediaType = value
            self.validate_CommunicationMediaTypeList(self.CommunicationMediaType)    # validate type CommunicationMediaTypeList
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_ContactNumberUsageList(self.Usage)    # validate type ContactNumberUsageList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('ContactHours', node)
        if value is not None and 'ContactHours' not in already_processed:
            already_processed.append('ContactHours')
            self.ContactHours = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactNumberElement':
            obj_ = ContactNumberElementType.factory()
            obj_.build(child_)
            self.ContactNumberElement.append(obj_)
# end class ContactNumberType


class ContactNumberElementType(GeneratedsSuper):
    """If present, specifies type of the information provdied as text value
    of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ContactNumberElementType.subclass:
            return ContactNumberElementType.subclass(*args_, **kwargs_)
        else:
            return ContactNumberElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ContactNumberElementList(self, value):
        # Validate type ContactNumberElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ContactNumberElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactNumberElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactNumberElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContactNumberElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactNumberElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_ContactNumberElementList(self.Type)    # validate type ContactNumberElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactNumberElementType


class DocumentType(GeneratedsSuper):
    """Status of the entity. e.g. Old, Current, Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, Type=None, DocumentElement=None, NameOnDocument=None, AddressOnDocument=None, IssuerName=None):
        self.Status = _cast(None, Status)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if DocumentElement is None:
            self.DocumentElement = []
        else:
            self.DocumentElement = DocumentElement
        self.NameOnDocument = NameOnDocument
        self.AddressOnDocument = AddressOnDocument
        self.IssuerName = IssuerName
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DocumentType.subclass:
            return DocumentType.subclass(*args_, **kwargs_)
        else:
            return DocumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentElement(self): return self.DocumentElement
    def set_DocumentElement(self, DocumentElement): self.DocumentElement = DocumentElement
    def add_DocumentElement(self, value): self.DocumentElement.append(value)
    def insert_DocumentElement(self, index, value): self.DocumentElement[index] = value
    def get_NameOnDocument(self): return self.NameOnDocument
    def set_NameOnDocument(self, NameOnDocument): self.NameOnDocument = NameOnDocument
    def get_AddressOnDocument(self): return self.AddressOnDocument
    def set_AddressOnDocument(self, AddressOnDocument): self.AddressOnDocument = AddressOnDocument
    def get_IssuerName(self): return self.IssuerName
    def set_IssuerName(self, IssuerName): self.IssuerName = IssuerName
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_DocumentTypeList(self, value):
        # Validate type DocumentTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DocumentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DocumentElement_ in self.DocumentElement:
            DocumentElement_.export(outfile, level, namespace_, name_='DocumentElement', pretty_print=pretty_print)
        if self.NameOnDocument is not None:
            self.NameOnDocument.export(outfile, level, namespace_, name_='NameOnDocument', pretty_print=pretty_print)
        if self.AddressOnDocument is not None:
            self.AddressOnDocument.export(outfile, level, namespace_, name_='AddressOnDocument', pretty_print=pretty_print)
        if self.IssuerName is not None:
            self.IssuerName.export(outfile, level, namespace_, name_='IssuerName', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.DocumentElement or
            self.NameOnDocument is not None or
            self.AddressOnDocument is not None or
            self.IssuerName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocumentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DocumentElement=[\n')
        level += 1
        for DocumentElement_ in self.DocumentElement:
            showIndent(outfile, level)
            outfile.write('model_.DocumentElementType(\n')
            DocumentElement_.exportLiteral(outfile, level, name_='DocumentElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.NameOnDocument is not None:
            showIndent(outfile, level)
            outfile.write('NameOnDocument=model_.PartyNameType(\n')
            self.NameOnDocument.exportLiteral(outfile, level, name_='NameOnDocument')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AddressOnDocument is not None:
            showIndent(outfile, level)
            outfile.write('AddressOnDocument=model_.AddressType(\n')
            self.AddressOnDocument.exportLiteral(outfile, level, name_='AddressOnDocument')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IssuerName is not None:
            showIndent(outfile, level)
            outfile.write('IssuerName=model_.IssuerNameType(\n')
            self.IssuerName.exportLiteral(outfile, level, name_='IssuerName')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_DocumentTypeList(self.Type)    # validate type DocumentTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentElement':
            obj_ = DocumentElementType.factory()
            obj_.build(child_)
            self.DocumentElement.append(obj_)
        elif nodeName_ == 'NameOnDocument':
            obj_ = PartyNameType.factory()
            obj_.build(child_)
            self.set_NameOnDocument(obj_)
        elif nodeName_ == 'AddressOnDocument':
            class_obj_ = self.get_class_obj_(child_, AddressType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_AddressOnDocument(obj_)
        elif nodeName_ == 'IssuerName':
            obj_ = IssuerNameType.factory()
            obj_.build(child_)
            self.set_IssuerName(obj_)
# end class DocumentType


class DocumentElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DocumentElementType.subclass:
            return DocumentElementType.subclass(*args_, **kwargs_)
        else:
            return DocumentElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_DocumentElementList(self, value):
        # Validate type DocumentElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DocumentElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocumentElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DocumentElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocumentElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_DocumentElementList(self.Type)    # validate type DocumentElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocumentElementType


class IssuerNameType(OrganisationNameType):
    subclass = None
    superclass = OrganisationNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None):
        super(IssuerNameType, self).__init__(Status, LanguageCode, NameKeyRef, type_, ValidTo, DateValidFrom, label, DateValidTo, href, ValidFrom, NameKey, Usage, DataQualityType, OrganisationID, Type, ID, OrganisationIDType, NameElement, SubDivisionName, )
        pass
    def factory(*args_, **kwargs_):
        if IssuerNameType.subclass:
            return IssuerNameType.subclass(*args_, **kwargs_)
        else:
            return IssuerNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='IssuerNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IssuerNameType'):
        super(IssuerNameType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IssuerNameType')
    def exportChildren(self, outfile, level, namespace_='', name_='IssuerNameType', fromsubclass_=False, pretty_print=True):
        super(IssuerNameType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(IssuerNameType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IssuerNameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IssuerNameType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IssuerNameType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(IssuerNameType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IssuerNameType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IssuerNameType


class ElectronicAddressIdentifierType(GeneratedsSuper):
    """Type of electronic address identifierStatus of the entity. e.g. Old,
    Current, Inactive, Active, etcUsage of electronic address
    identifier. e.g. business, personalAn electronic address
    identifier is usually stored (and probably exchanged) in
    conjunction with a label which is typically displayed and the
    URL/electronic identifier just links that label."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ValidTo=None, Label=None, DataQualityType=None, Usage=None, ValidFrom=None, Type=None, valueOf_=None):
        self.Status = _cast(None, Status)
        self.ValidTo = _cast(None, ValidTo)
        self.Label = _cast(None, Label)
        self.DataQualityType = _cast(None, DataQualityType)
        self.Usage = _cast(None, Usage)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ElectronicAddressIdentifierType.subclass:
            return ElectronicAddressIdentifierType.subclass(*args_, **kwargs_)
        else:
            return ElectronicAddressIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_Usage(self): return self.Usage
    def set_Usage(self, Usage): self.Usage = Usage
    def validate_ElectronicAddressIdentifierUsageList(self, value):
        # Validate type ElectronicAddressIdentifierUsageList, a restriction on xs:normalizedString.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ElectronicAddressIdentifierTypeList(self, value):
        # Validate type ElectronicAddressIdentifierTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ElectronicAddressIdentifierType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ElectronicAddressIdentifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ElectronicAddressIdentifierType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.append('Label')
            outfile.write(' Label=%s' % (quote_attrib(self.Label), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            outfile.write(' Usage=%s' % (quote_attrib(self.Usage), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ElectronicAddressIdentifierType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ElectronicAddressIdentifierType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.Label is not None and 'Label' not in already_processed:
            already_processed.append('Label')
            showIndent(outfile, level)
            outfile.write('Label = %s,\n' % (self.Label,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.Usage is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            showIndent(outfile, level)
            outfile.write('Usage = "%s",\n' % (self.Usage,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('Label', node)
        if value is not None and 'Label' not in already_processed:
            already_processed.append('Label')
            self.Label = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('Usage', node)
        if value is not None and 'Usage' not in already_processed:
            already_processed.append('Usage')
            self.Usage = value
            self.validate_ElectronicAddressIdentifierUsageList(self.Usage)    # validate type ElectronicAddressIdentifierUsageList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_ElectronicAddressIdentifierTypeList(self.Type)    # validate type ElectronicAddressIdentifierTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ElectronicAddressIdentifierType


class EventType(GeneratedsSuper):
    """Type of event. e.g. Anniversary. If "Anniversary" is type, then the
    text for Event could be "20th wedding anniversary"Record the
    exact date of the event here. For example, deceased date,
    company closed date, birthday date of spouse, etc"""
    subclass = None
    superclass = None
    def __init__(self, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, Date=None, ValidFrom=None, Type=None, valueOf_=None):
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.Date = _cast(None, Date)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EventType.subclass:
            return EventType.subclass(*args_, **kwargs_)
        else:
            return EventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_EventTypeList(self, value):
        # Validate type EventTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='EventType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.append('Date')
            outfile.write(' Date=%s' % (self.gds_format_string(quote_attrib(self.Date).encode(ExternalEncoding), input_name='Date'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EventType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EventType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.append('Date')
            showIndent(outfile, level)
            outfile.write('Date = "%s",\n' % (self.Date,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('Date', node)
        if value is not None and 'Date' not in already_processed:
            already_processed.append('Date')
            self.Date = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_EventTypeList(self.Type)    # validate type EventTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EventType


class IdentifierType1(GeneratedsSuper):
    """Type of identifier. e.g. Tax NumberStatus of the entity. e.g. Old,
    Current, Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, Type=None, IdentifierElement=None, IssuerName=None):
        self.Status = _cast(None, Status)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if IdentifierElement is None:
            self.IdentifierElement = []
        else:
            self.IdentifierElement = IdentifierElement
        self.IssuerName = IssuerName
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IdentifierType1.subclass:
            return IdentifierType1.subclass(*args_, **kwargs_)
        else:
            return IdentifierType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdentifierElement(self): return self.IdentifierElement
    def set_IdentifierElement(self, IdentifierElement): self.IdentifierElement = IdentifierElement
    def add_IdentifierElement(self, value): self.IdentifierElement.append(value)
    def insert_IdentifierElement(self, index, value): self.IdentifierElement[index] = value
    def get_IssuerName(self): return self.IssuerName
    def set_IssuerName(self, IssuerName): self.IssuerName = IssuerName
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PartyIdentifierTypeList(self, value):
        # Validate type PartyIdentifierTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='IdentifierType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType1'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IdentifierElement_ in self.IdentifierElement:
            IdentifierElement_.export(outfile, level, namespace_, name_='IdentifierElement', pretty_print=pretty_print)
        if self.IssuerName is not None:
            self.IssuerName.export(outfile, level, namespace_, name_='IssuerName', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IdentifierElement or
            self.IssuerName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdentifierType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IdentifierElement=[\n')
        level += 1
        for IdentifierElement_ in self.IdentifierElement:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierElementType(\n')
            IdentifierElement_.exportLiteral(outfile, level, name_='IdentifierElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.IssuerName is not None:
            showIndent(outfile, level)
            outfile.write('IssuerName=model_.OrganisationNameType(\n')
            self.IssuerName.exportLiteral(outfile, level, name_='IssuerName')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PartyIdentifierTypeList(self.Type)    # validate type PartyIdentifierTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IdentifierElement':
            obj_ = IdentifierElementType.factory()
            obj_.build(child_)
            self.IdentifierElement.append(obj_)
        elif nodeName_ == 'IssuerName':
            class_obj_ = self.get_class_obj_(child_, OrganisationNameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_IssuerName(obj_)
# end class IdentifierType1


class IdentifierElementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IdentifierElementType.subclass:
            return IdentifierElementType.subclass(*args_, **kwargs_)
        else:
            return IdentifierElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PartyIdentifierElementList(self, value):
        # Validate type PartyIdentifierElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='IdentifierElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdentifierElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PartyIdentifierElementList(self.Type)    # validate type PartyIdentifierElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IdentifierElementType


class MembershipType(GeneratedsSuper):
    """Type of membership. e.g Type of membership. e.g IEEE, Rifles
    ClubStatus of the entity. e.g. Old, Current, Inactive, Active,
    etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, Type=None, MembershipElement=None, Organisation=None):
        self.Status = _cast(None, Status)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if MembershipElement is None:
            self.MembershipElement = []
        else:
            self.MembershipElement = MembershipElement
        self.Organisation = Organisation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if MembershipType.subclass:
            return MembershipType.subclass(*args_, **kwargs_)
        else:
            return MembershipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MembershipElement(self): return self.MembershipElement
    def set_MembershipElement(self, MembershipElement): self.MembershipElement = MembershipElement
    def add_MembershipElement(self, value): self.MembershipElement.append(value)
    def insert_MembershipElement(self, index, value): self.MembershipElement[index] = value
    def get_Organisation(self): return self.Organisation
    def set_Organisation(self, Organisation): self.Organisation = Organisation
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_MembershipTypeList(self, value):
        # Validate type MembershipTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='MembershipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MembershipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MembershipType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MembershipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MembershipElement_ in self.MembershipElement:
            MembershipElement_.export(outfile, level, namespace_, name_='MembershipElement', pretty_print=pretty_print)
        if self.Organisation is not None:
            self.Organisation.export(outfile, level, namespace_, name_='Organisation', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.MembershipElement or
            self.Organisation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MembershipType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MembershipElement=[\n')
        level += 1
        for MembershipElement_ in self.MembershipElement:
            showIndent(outfile, level)
            outfile.write('model_.MembershipElementType(\n')
            MembershipElement_.exportLiteral(outfile, level, name_='MembershipElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Organisation is not None:
            showIndent(outfile, level)
            outfile.write('Organisation=model_.OrganisationType1(\n')
            self.Organisation.exportLiteral(outfile, level, name_='Organisation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_MembershipTypeList(self.Type)    # validate type MembershipTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MembershipElement':
            obj_ = MembershipElementType.factory()
            obj_.build(child_)
            self.MembershipElement.append(obj_)
        elif nodeName_ == 'Organisation':
            obj_ = OrganisationType1.factory()
            obj_.build(child_)
            self.set_Organisation(obj_)
# end class MembershipType


class MembershipElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if MembershipElementType.subclass:
            return MembershipElementType.subclass(*args_, **kwargs_)
        else:
            return MembershipElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_MembershipElementList(self, value):
        # Validate type MembershipElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='MembershipElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MembershipElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MembershipElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MembershipElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MembershipElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_MembershipElementList(self.Type)    # validate type MembershipElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MembershipElementType


class OrganisationType1(OrganisationNameType):
    subclass = None
    superclass = OrganisationNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None):
        super(OrganisationType1, self).__init__(Status, LanguageCode, NameKeyRef, type_, ValidTo, DateValidFrom, label, DateValidTo, href, ValidFrom, NameKey, Usage, DataQualityType, OrganisationID, Type, ID, OrganisationIDType, NameElement, SubDivisionName, )
        pass
    def factory(*args_, **kwargs_):
        if OrganisationType1.subclass:
            return OrganisationType1.subclass(*args_, **kwargs_)
        else:
            return OrganisationType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='OrganisationType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationType1'):
        super(OrganisationType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationType1')
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationType1', fromsubclass_=False, pretty_print=True):
        super(OrganisationType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(OrganisationType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrganisationType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrganisationType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrganisationType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OrganisationType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OrganisationType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OrganisationType1


class RelationshipType(GeneratedsSuper):
    """Status of the entity. e.g. Old, Current, Inactive, Active, etcType
    of party involved in the relationship, i.e. person or
    organisationIf tha party is person, then the type of
    relationship with the person such as Friend, Mother, wife,
    contact, refereeIf tha party is organisation, then the type of
    relationship with the organisation such as employer, branch,
    head office, subsidiary, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, RelationshipValidFrom=None, ValidTo=None, RelationshipWithPerson=None, RelationshipValidTo=None, DataQualityType=None, ValidFrom=None, RelationshipWithOrganisation=None, PartyType=None, NameLine=None, PersonName=None, OrganisationName=None, Addresses=None, ContactNumbers=None, ElectronicAddressIdentifiers=None):
        self.Status = _cast(None, Status)
        self.RelationshipValidFrom = _cast(None, RelationshipValidFrom)
        self.ValidTo = _cast(None, ValidTo)
        self.RelationshipWithPerson = _cast(None, RelationshipWithPerson)
        self.RelationshipValidTo = _cast(None, RelationshipValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.RelationshipWithOrganisation = _cast(None, RelationshipWithOrganisation)
        self.PartyType = _cast(None, PartyType)
        self.NameLine = NameLine
        self.PersonName = PersonName
        self.OrganisationName = OrganisationName
        self.Addresses = Addresses
        self.ContactNumbers = ContactNumbers
        self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RelationshipType.subclass:
            return RelationshipType.subclass(*args_, **kwargs_)
        else:
            return RelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameLine(self): return self.NameLine
    def set_NameLine(self, NameLine): self.NameLine = NameLine
    def get_PersonName(self): return self.PersonName
    def set_PersonName(self, PersonName): self.PersonName = PersonName
    def get_OrganisationName(self): return self.OrganisationName
    def set_OrganisationName(self, OrganisationName): self.OrganisationName = OrganisationName
    def get_Addresses(self): return self.Addresses
    def set_Addresses(self, Addresses): self.Addresses = Addresses
    def get_ContactNumbers(self): return self.ContactNumbers
    def set_ContactNumbers(self, ContactNumbers): self.ContactNumbers = ContactNumbers
    def get_ElectronicAddressIdentifiers(self): return self.ElectronicAddressIdentifiers
    def set_ElectronicAddressIdentifiers(self, ElectronicAddressIdentifiers): self.ElectronicAddressIdentifiers = ElectronicAddressIdentifiers
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_RelationshipValidFrom(self): return self.RelationshipValidFrom
    def set_RelationshipValidFrom(self, RelationshipValidFrom): self.RelationshipValidFrom = RelationshipValidFrom
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_RelationshipWithPerson(self): return self.RelationshipWithPerson
    def set_RelationshipWithPerson(self, RelationshipWithPerson): self.RelationshipWithPerson = RelationshipWithPerson
    def validate_PersonRelationshipTypeList(self, value):
        # Validate type PersonRelationshipTypeList, a restriction on xs:normalizedString.
        pass
    def get_RelationshipValidTo(self): return self.RelationshipValidTo
    def set_RelationshipValidTo(self, RelationshipValidTo): self.RelationshipValidTo = RelationshipValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_RelationshipWithOrganisation(self): return self.RelationshipWithOrganisation
    def set_RelationshipWithOrganisation(self, RelationshipWithOrganisation): self.RelationshipWithOrganisation = RelationshipWithOrganisation
    def validate_OrganisationRelationshipTypeList(self, value):
        # Validate type OrganisationRelationshipTypeList, a restriction on xs:normalizedString.
        pass
    def get_PartyType(self): return self.PartyType
    def set_PartyType(self, PartyType): self.PartyType = PartyType
    def validate_PartyTypeList(self, value):
        # Validate type PartyTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RelationshipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelationshipType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.RelationshipValidFrom is not None and 'RelationshipValidFrom' not in already_processed:
            already_processed.append('RelationshipValidFrom')
            outfile.write(' RelationshipValidFrom=%s' % (self.gds_format_string(quote_attrib(self.RelationshipValidFrom).encode(ExternalEncoding), input_name='RelationshipValidFrom'), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.RelationshipWithPerson is not None and 'RelationshipWithPerson' not in already_processed:
            already_processed.append('RelationshipWithPerson')
            outfile.write(' RelationshipWithPerson=%s' % (quote_attrib(self.RelationshipWithPerson), ))
        if self.RelationshipValidTo is not None and 'RelationshipValidTo' not in already_processed:
            already_processed.append('RelationshipValidTo')
            outfile.write(' RelationshipValidTo=%s' % (self.gds_format_string(quote_attrib(self.RelationshipValidTo).encode(ExternalEncoding), input_name='RelationshipValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.RelationshipWithOrganisation is not None and 'RelationshipWithOrganisation' not in already_processed:
            already_processed.append('RelationshipWithOrganisation')
            outfile.write(' RelationshipWithOrganisation=%s' % (quote_attrib(self.RelationshipWithOrganisation), ))
        if self.PartyType is not None and 'PartyType' not in already_processed:
            already_processed.append('PartyType')
            outfile.write(' PartyType=%s' % (quote_attrib(self.PartyType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NameLine is not None:
            self.NameLine.export(outfile, level, namespace_, name_='NameLine', pretty_print=pretty_print)
        if self.PersonName is not None:
            self.PersonName.export(outfile, level, namespace_, name_='PersonName', pretty_print=pretty_print)
        if self.OrganisationName is not None:
            self.OrganisationName.export(outfile, level, namespace_, name_='OrganisationName', pretty_print=pretty_print)
        if self.Addresses is not None:
            self.Addresses.export(outfile, level, namespace_, name_='Addresses', pretty_print=pretty_print)
        if self.ContactNumbers is not None:
            self.ContactNumbers.export(outfile, level, namespace_, name_='ContactNumbers', pretty_print=pretty_print)
        if self.ElectronicAddressIdentifiers is not None:
            self.ElectronicAddressIdentifiers.export(outfile, level, namespace_, name_='ElectronicAddressIdentifiers', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameLine is not None or
            self.PersonName is not None or
            self.OrganisationName is not None or
            self.Addresses is not None or
            self.ContactNumbers is not None or
            self.ElectronicAddressIdentifiers is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RelationshipType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.RelationshipValidFrom is not None and 'RelationshipValidFrom' not in already_processed:
            already_processed.append('RelationshipValidFrom')
            showIndent(outfile, level)
            outfile.write('RelationshipValidFrom = "%s",\n' % (self.RelationshipValidFrom,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.RelationshipWithPerson is not None and 'RelationshipWithPerson' not in already_processed:
            already_processed.append('RelationshipWithPerson')
            showIndent(outfile, level)
            outfile.write('RelationshipWithPerson = "%s",\n' % (self.RelationshipWithPerson,))
        if self.RelationshipValidTo is not None and 'RelationshipValidTo' not in already_processed:
            already_processed.append('RelationshipValidTo')
            showIndent(outfile, level)
            outfile.write('RelationshipValidTo = "%s",\n' % (self.RelationshipValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.RelationshipWithOrganisation is not None and 'RelationshipWithOrganisation' not in already_processed:
            already_processed.append('RelationshipWithOrganisation')
            showIndent(outfile, level)
            outfile.write('RelationshipWithOrganisation = "%s",\n' % (self.RelationshipWithOrganisation,))
        if self.PartyType is not None and 'PartyType' not in already_processed:
            already_processed.append('PartyType')
            showIndent(outfile, level)
            outfile.write('PartyType = "%s",\n' % (self.PartyType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NameLine is not None:
            showIndent(outfile, level)
            outfile.write('NameLine=model_.NameLine(\n')
            self.NameLine.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PersonName is not None:
            showIndent(outfile, level)
            outfile.write('PersonName=model_.PersonName(\n')
            self.PersonName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrganisationName is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationName=model_.OrganisationName(\n')
            self.OrganisationName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Addresses is not None:
            showIndent(outfile, level)
            outfile.write('Addresses=model_.Addresses(\n')
            self.Addresses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactNumbers is not None:
            showIndent(outfile, level)
            outfile.write('ContactNumbers=model_.ContactNumbers(\n')
            self.ContactNumbers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElectronicAddressIdentifiers is not None:
            showIndent(outfile, level)
            outfile.write('ElectronicAddressIdentifiers=model_.ElectronicAddressIdentifiers(\n')
            self.ElectronicAddressIdentifiers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('RelationshipValidFrom', node)
        if value is not None and 'RelationshipValidFrom' not in already_processed:
            already_processed.append('RelationshipValidFrom')
            self.RelationshipValidFrom = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('RelationshipWithPerson', node)
        if value is not None and 'RelationshipWithPerson' not in already_processed:
            already_processed.append('RelationshipWithPerson')
            self.RelationshipWithPerson = value
            self.validate_PersonRelationshipTypeList(self.RelationshipWithPerson)    # validate type PersonRelationshipTypeList
        value = find_attr_value_('RelationshipValidTo', node)
        if value is not None and 'RelationshipValidTo' not in already_processed:
            already_processed.append('RelationshipValidTo')
            self.RelationshipValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('RelationshipWithOrganisation', node)
        if value is not None and 'RelationshipWithOrganisation' not in already_processed:
            already_processed.append('RelationshipWithOrganisation')
            self.RelationshipWithOrganisation = value
            self.validate_OrganisationRelationshipTypeList(self.RelationshipWithOrganisation)    # validate type OrganisationRelationshipTypeList
        value = find_attr_value_('PartyType', node)
        if value is not None and 'PartyType' not in already_processed:
            already_processed.append('PartyType')
            self.PartyType = value
            self.validate_PartyTypeList(self.PartyType)    # validate type PartyTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameLine':
            obj_ = NameLine.factory()
            obj_.build(child_)
            self.set_NameLine(obj_)
        elif nodeName_ == 'PersonName':
            class_obj_ = self.get_class_obj_(child_, PersonNameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_PersonName(obj_)
        elif nodeName_ == 'OrganisationName':
            class_obj_ = self.get_class_obj_(child_, OrganisationNameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_OrganisationName(obj_)
        elif nodeName_ == 'Addresses':
            obj_ = Addresses.factory()
            obj_.build(child_)
            self.set_Addresses(obj_)
        elif nodeName_ == 'ContactNumbers':
            obj_ = ContactNumbers.factory()
            obj_.build(child_)
            self.set_ContactNumbers(obj_)
        elif nodeName_ == 'ElectronicAddressIdentifiers':
            obj_ = ElectronicAddressIdentifiers.factory()
            obj_.build(child_)
            self.set_ElectronicAddressIdentifiers(obj_)
# end class RelationshipType


class RevenueType(GeneratedsSuper):
    """A three-letter currency code as per ISO 4217Status of the entity.
    e.g. Old, Current, Inactive, Active, etcBegining of the period.
    Inclusive.End of the period. Inclusive.Defines the type of
    amount. Example: Total earning, profit, loss, turnover,
    etc.Precision range where the value of the element is in the
    middle of the range. E.g. Where this revenue / income comes
    from, e.g. business stream, activity, etc.Country from where the
    revenue is generatedIf present and set to true indicates that
    the income / revenue is after tax."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, AfterTax=None, PeriodFrom=None, CurrencyCode=None, Precision=None, CountryName=None, Source=None, DataQualityType=None, PeriodTo=None, ValidFrom=None, Type=None, ValidTo=None, valueOf_=None):
        self.Status = _cast(None, Status)
        self.AfterTax = _cast(bool, AfterTax)
        self.PeriodFrom = _cast(None, PeriodFrom)
        self.CurrencyCode = _cast(None, CurrencyCode)
        self.Precision = _cast(float, Precision)
        self.CountryName = _cast(None, CountryName)
        self.Source = _cast(None, Source)
        self.DataQualityType = _cast(None, DataQualityType)
        self.PeriodTo = _cast(None, PeriodTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.ValidTo = _cast(None, ValidTo)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RevenueType.subclass:
            return RevenueType.subclass(*args_, **kwargs_)
        else:
            return RevenueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_AfterTax(self): return self.AfterTax
    def set_AfterTax(self, AfterTax): self.AfterTax = AfterTax
    def get_PeriodFrom(self): return self.PeriodFrom
    def set_PeriodFrom(self, PeriodFrom): self.PeriodFrom = PeriodFrom
    def get_CurrencyCode(self): return self.CurrencyCode
    def set_CurrencyCode(self, CurrencyCode): self.CurrencyCode = CurrencyCode
    def validate_RevenueCurrencyCodeList(self, value):
        # Validate type RevenueCurrencyCodeList, a restriction on xs:normalizedString.
        pass
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def validate_RevenueSourceList(self, value):
        # Validate type RevenueSourceList, a restriction on xs:normalizedString.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_PeriodTo(self): return self.PeriodTo
    def set_PeriodTo(self, PeriodTo): self.PeriodTo = PeriodTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_RevenueTypeList(self, value):
        # Validate type RevenueTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RevenueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RevenueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RevenueType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.AfterTax is not None and 'AfterTax' not in already_processed:
            already_processed.append('AfterTax')
            outfile.write(' AfterTax="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.AfterTax)), input_name='AfterTax'))
        if self.PeriodFrom is not None and 'PeriodFrom' not in already_processed:
            already_processed.append('PeriodFrom')
            outfile.write(' PeriodFrom=%s' % (self.gds_format_string(quote_attrib(self.PeriodFrom).encode(ExternalEncoding), input_name='PeriodFrom'), ))
        if self.CurrencyCode is not None and 'CurrencyCode' not in already_processed:
            already_processed.append('CurrencyCode')
            outfile.write(' CurrencyCode=%s' % (quote_attrib(self.CurrencyCode), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision="%s"' % self.gds_format_float(self.Precision, input_name='Precision'))
        if self.CountryName is not None and 'CountryName' not in already_processed:
            already_processed.append('CountryName')
            outfile.write(' CountryName=%s' % (quote_attrib(self.CountryName), ))
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.append('Source')
            outfile.write(' Source=%s' % (quote_attrib(self.Source), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.PeriodTo is not None and 'PeriodTo' not in already_processed:
            already_processed.append('PeriodTo')
            outfile.write(' PeriodTo=%s' % (self.gds_format_string(quote_attrib(self.PeriodTo).encode(ExternalEncoding), input_name='PeriodTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RevenueType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RevenueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.AfterTax is not None and 'AfterTax' not in already_processed:
            already_processed.append('AfterTax')
            showIndent(outfile, level)
            outfile.write('AfterTax = %s,\n' % (self.AfterTax,))
        if self.PeriodFrom is not None and 'PeriodFrom' not in already_processed:
            already_processed.append('PeriodFrom')
            showIndent(outfile, level)
            outfile.write('PeriodFrom = "%s",\n' % (self.PeriodFrom,))
        if self.CurrencyCode is not None and 'CurrencyCode' not in already_processed:
            already_processed.append('CurrencyCode')
            showIndent(outfile, level)
            outfile.write('CurrencyCode = "%s",\n' % (self.CurrencyCode,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %f,\n' % (self.Precision,))
        if self.CountryName is not None and 'CountryName' not in already_processed:
            already_processed.append('CountryName')
            showIndent(outfile, level)
            outfile.write('CountryName = %s,\n' % (self.CountryName,))
        if self.Source is not None and 'Source' not in already_processed:
            already_processed.append('Source')
            showIndent(outfile, level)
            outfile.write('Source = "%s",\n' % (self.Source,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.PeriodTo is not None and 'PeriodTo' not in already_processed:
            already_processed.append('PeriodTo')
            showIndent(outfile, level)
            outfile.write('PeriodTo = "%s",\n' % (self.PeriodTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('AfterTax', node)
        if value is not None and 'AfterTax' not in already_processed:
            already_processed.append('AfterTax')
            if value in ('true', '1'):
                self.AfterTax = True
            elif value in ('false', '0'):
                self.AfterTax = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('PeriodFrom', node)
        if value is not None and 'PeriodFrom' not in already_processed:
            already_processed.append('PeriodFrom')
            self.PeriodFrom = value
        value = find_attr_value_('CurrencyCode', node)
        if value is not None and 'CurrencyCode' not in already_processed:
            already_processed.append('CurrencyCode')
            self.CurrencyCode = value
            self.validate_RevenueCurrencyCodeList(self.CurrencyCode)    # validate type RevenueCurrencyCodeList
        value = find_attr_value_('Precision', node)
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            try:
                self.Precision = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (Precision): %s' % exp)
        value = find_attr_value_('CountryName', node)
        if value is not None and 'CountryName' not in already_processed:
            already_processed.append('CountryName')
            self.CountryName = value
        value = find_attr_value_('Source', node)
        if value is not None and 'Source' not in already_processed:
            already_processed.append('Source')
            self.Source = value
            self.validate_RevenueSourceList(self.Source)    # validate type RevenueSourceList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('PeriodTo', node)
        if value is not None and 'PeriodTo' not in already_processed:
            already_processed.append('PeriodTo')
            self.PeriodTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_RevenueTypeList(self.Type)    # validate type RevenueTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RevenueType


class StockType(GeneratedsSuper):
    """The code name for the organisation as listed in the exchange. E.g.
    MOT for Motorola IncFree text name of the stock exchange or
    other market. E.g. NYSE or NZXName of the country where
    listeddate of investmentQuantity of shares.....1 million
    sharesdate of listing"""
    subclass = None
    superclass = None
    def __init__(self, MarketName=None, ValidTo=None, ListedDate=None, CountryName=None, ShareQuantity=None, DataQualityType=None, ListedCode=None, ValidFrom=None, InvestedDate=None):
        self.MarketName = _cast(None, MarketName)
        self.ValidTo = _cast(None, ValidTo)
        self.ListedDate = _cast(None, ListedDate)
        self.CountryName = _cast(None, CountryName)
        self.ShareQuantity = _cast(None, ShareQuantity)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ListedCode = _cast(None, ListedCode)
        self.ValidFrom = _cast(None, ValidFrom)
        self.InvestedDate = _cast(None, InvestedDate)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if StockType.subclass:
            return StockType.subclass(*args_, **kwargs_)
        else:
            return StockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MarketName(self): return self.MarketName
    def set_MarketName(self, MarketName): self.MarketName = MarketName
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ListedDate(self): return self.ListedDate
    def set_ListedDate(self, ListedDate): self.ListedDate = ListedDate
    def get_CountryName(self): return self.CountryName
    def set_CountryName(self, CountryName): self.CountryName = CountryName
    def get_ShareQuantity(self): return self.ShareQuantity
    def set_ShareQuantity(self, ShareQuantity): self.ShareQuantity = ShareQuantity
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ListedCode(self): return self.ListedCode
    def set_ListedCode(self, ListedCode): self.ListedCode = ListedCode
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_InvestedDate(self): return self.InvestedDate
    def set_InvestedDate(self, InvestedDate): self.InvestedDate = InvestedDate
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='StockType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StockType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.MarketName is not None and 'MarketName' not in already_processed:
            already_processed.append('MarketName')
            outfile.write(' MarketName=%s' % (quote_attrib(self.MarketName), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ListedDate is not None and 'ListedDate' not in already_processed:
            already_processed.append('ListedDate')
            outfile.write(' ListedDate=%s' % (self.gds_format_string(quote_attrib(self.ListedDate).encode(ExternalEncoding), input_name='ListedDate'), ))
        if self.CountryName is not None and 'CountryName' not in already_processed:
            already_processed.append('CountryName')
            outfile.write(' CountryName=%s' % (quote_attrib(self.CountryName), ))
        if self.ShareQuantity is not None and 'ShareQuantity' not in already_processed:
            already_processed.append('ShareQuantity')
            outfile.write(' ShareQuantity=%s' % (quote_attrib(self.ShareQuantity), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ListedCode is not None and 'ListedCode' not in already_processed:
            already_processed.append('ListedCode')
            outfile.write(' ListedCode=%s' % (quote_attrib(self.ListedCode), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.InvestedDate is not None and 'InvestedDate' not in already_processed:
            already_processed.append('InvestedDate')
            outfile.write(' InvestedDate=%s' % (self.gds_format_string(quote_attrib(self.InvestedDate).encode(ExternalEncoding), input_name='InvestedDate'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StockType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StockType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MarketName is not None and 'MarketName' not in already_processed:
            already_processed.append('MarketName')
            showIndent(outfile, level)
            outfile.write('MarketName = %s,\n' % (self.MarketName,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ListedDate is not None and 'ListedDate' not in already_processed:
            already_processed.append('ListedDate')
            showIndent(outfile, level)
            outfile.write('ListedDate = "%s",\n' % (self.ListedDate,))
        if self.CountryName is not None and 'CountryName' not in already_processed:
            already_processed.append('CountryName')
            showIndent(outfile, level)
            outfile.write('CountryName = %s,\n' % (self.CountryName,))
        if self.ShareQuantity is not None and 'ShareQuantity' not in already_processed:
            already_processed.append('ShareQuantity')
            showIndent(outfile, level)
            outfile.write('ShareQuantity = %s,\n' % (self.ShareQuantity,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ListedCode is not None and 'ListedCode' not in already_processed:
            already_processed.append('ListedCode')
            showIndent(outfile, level)
            outfile.write('ListedCode = %s,\n' % (self.ListedCode,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.InvestedDate is not None and 'InvestedDate' not in already_processed:
            already_processed.append('InvestedDate')
            showIndent(outfile, level)
            outfile.write('InvestedDate = "%s",\n' % (self.InvestedDate,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('MarketName', node)
        if value is not None and 'MarketName' not in already_processed:
            already_processed.append('MarketName')
            self.MarketName = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ListedDate', node)
        if value is not None and 'ListedDate' not in already_processed:
            already_processed.append('ListedDate')
            self.ListedDate = value
        value = find_attr_value_('CountryName', node)
        if value is not None and 'CountryName' not in already_processed:
            already_processed.append('CountryName')
            self.CountryName = value
        value = find_attr_value_('ShareQuantity', node)
        if value is not None and 'ShareQuantity' not in already_processed:
            already_processed.append('ShareQuantity')
            self.ShareQuantity = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ListedCode', node)
        if value is not None and 'ListedCode' not in already_processed:
            already_processed.append('ListedCode')
            self.ListedCode = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('InvestedDate', node)
        if value is not None and 'InvestedDate' not in already_processed:
            already_processed.append('InvestedDate')
            self.InvestedDate = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StockType


class VehicleType(GeneratedsSuper):
    """Type of vehicle. Example: Motorbike, Truck, Car, Bicycle, 4WD, Jeep,
    etcStatus of the entity. e.g. Old, Current, Inactive, Active,
    etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, VehicleElement=None):
        self.Status = _cast(None, Status)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if VehicleElement is None:
            self.VehicleElement = []
        else:
            self.VehicleElement = VehicleElement
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VehicleType.subclass:
            return VehicleType.subclass(*args_, **kwargs_)
        else:
            return VehicleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VehicleElement(self): return self.VehicleElement
    def set_VehicleElement(self, VehicleElement): self.VehicleElement = VehicleElement
    def add_VehicleElement(self, value): self.VehicleElement.append(value)
    def insert_VehicleElement(self, index, value): self.VehicleElement[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VehicleTypeList(self, value):
        # Validate type VehicleTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VehicleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VehicleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VehicleType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VehicleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VehicleElement_ in self.VehicleElement:
            VehicleElement_.export(outfile, level, namespace_, name_='VehicleElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.VehicleElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VehicleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('VehicleElement=[\n')
        level += 1
        for VehicleElement_ in self.VehicleElement:
            showIndent(outfile, level)
            outfile.write('model_.VehicleElementType(\n')
            VehicleElement_.exportLiteral(outfile, level, name_='VehicleElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_VehicleTypeList(self.Type)    # validate type VehicleTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VehicleElement':
            obj_ = VehicleElementType.factory()
            obj_.build(child_)
            self.VehicleElement.append(obj_)
# end class VehicleType


class VehicleElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VehicleElementType.subclass:
            return VehicleElementType.subclass(*args_, **kwargs_)
        else:
            return VehicleElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VehicleInfoElementList(self, value):
        # Validate type VehicleInfoElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VehicleElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VehicleElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VehicleElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VehicleElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VehicleElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_VehicleInfoElementList(self.Type)    # validate type VehicleInfoElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VehicleElementType


class BirthInfoElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BirthInfoElementType.subclass:
            return BirthInfoElementType.subclass(*args_, **kwargs_)
        else:
            return BirthInfoElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_BirthInfoElementList(self, value):
        # Validate type BirthInfoElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BirthInfoElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BirthInfoElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BirthInfoElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BirthInfoElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BirthInfoElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_BirthInfoElementList(self.Type)    # validate type BirthInfoElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BirthInfoElementType


class CountryType1(CountryType):
    """Type of residency. e.g. permenant resident, citizen, temporary
    residentStatus of the entity. e.g. Old, Current, Inactive,
    Active, etc"""
    subclass = None
    superclass = CountryType
    def __init__(self, NameElement=None, Status=None, DateValidTo=None, DateValidFrom=None, Type=None):
        super(CountryType1, self).__init__(NameElement, )
        self.Status = _cast(None, Status)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.Type = _cast(None, Type)
        pass
    def factory(*args_, **kwargs_):
        if CountryType1.subclass:
            return CountryType1.subclass(*args_, **kwargs_)
        else:
            return CountryType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_ResidencyTypeList(self, value):
        # Validate type ResidencyTypeList, a restriction on xs:normalizedString.
        pass
    def export(self, outfile, level, namespace_='', name_='CountryType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryType1'):
        super(CountryType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType1')
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CountryType1', fromsubclass_=False, pretty_print=True):
        super(CountryType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(CountryType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountryType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        super(CountryType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CountryType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_ResidencyTypeList(self.Type)    # validate type ResidencyTypeList
        super(CountryType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CountryType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CountryType1


class FavouriteType(GeneratedsSuper):
    """Type of favourite. e.g. author, food, book, sport, etc Cricket Back
    to the Future"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FavouriteType.subclass:
            return FavouriteType.subclass(*args_, **kwargs_)
        else:
            return FavouriteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PersonFavouriteTypeList(self, value):
        # Validate type PersonFavouriteTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FavouriteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FavouriteType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FavouriteType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FavouriteType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FavouriteType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PersonFavouriteTypeList(self.Type)    # validate type PersonFavouriteTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FavouriteType


class HabitType(GeneratedsSuper):
    """ Category/type of habit. e.g. sports, food, reading, etc. If "Hot
    Drinks" is type, then text for Habit could be "Strong Black
    Coffee" """
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if HabitType.subclass:
            return HabitType.subclass(*args_, **kwargs_)
        else:
            return HabitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_HabitTypeList(self, value):
        # Validate type HabitTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='HabitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HabitType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HabitType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HabitType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HabitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_HabitTypeList(self.Type)    # validate type HabitTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HabitType


class HobbyType(GeneratedsSuper):
    """ Type/Category of Hobby. e.g. sports, travelling. If "Sport" is a
    type/category of hobby, then text for "Hobby" could be "Playing
    cricket" """
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if HobbyType.subclass:
            return HobbyType.subclass(*args_, **kwargs_)
        else:
            return HobbyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_HobbyTypeList(self, value):
        # Validate type HobbyTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='HobbyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HobbyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HobbyType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HobbyType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HobbyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_HobbyTypeList(self.Type)    # validate type HobbyTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HobbyType


class LanguageType(GeneratedsSuper):
    """Mother tongue, by birth, etcIndicates ability to speak: yes, no,
    poor, good, bad, averageIndicates ability to read: yes, no,
    poor, good, bad, averageIndicates ability to write: yes, no,
    poor, good, bad, averageIndicates ability to understand speech:
    yes, no, poor, good, bad, averageIndicates preferred language of
    communication (read and/or write and/or speak)"""
    subclass = None
    superclass = None
    def __init__(self, Read=None, ValidTo=None, Write=None, Understand=None, Preference=None, DataQualityType=None, ValidFrom=None, Type=None, Speak=None, valueOf_=None):
        self.Read = _cast(None, Read)
        self.ValidTo = _cast(None, ValidTo)
        self.Write = _cast(None, Write)
        self.Understand = _cast(None, Understand)
        self.Preference = _cast(None, Preference)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.Speak = _cast(None, Speak)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LanguageType.subclass:
            return LanguageType.subclass(*args_, **kwargs_)
        else:
            return LanguageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Read(self): return self.Read
    def set_Read(self, Read): self.Read = Read
    def validate_LanguageSkillsList(self, value):
        # Validate type LanguageSkillsList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_Write(self): return self.Write
    def set_Write(self, Write): self.Write = Write
    def get_Understand(self): return self.Understand
    def set_Understand(self, Understand): self.Understand = Understand
    def get_Preference(self): return self.Preference
    def set_Preference(self, Preference): self.Preference = Preference
    def validate_LanguagePreferenceList(self, value):
        # Validate type LanguagePreferenceList, a restriction on xs:normalizedString.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_LanguageTypeList(self, value):
        # Validate type LanguageTypeList, a restriction on xs:normalizedString.
        pass
    def get_Speak(self): return self.Speak
    def set_Speak(self, Speak): self.Speak = Speak
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LanguageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LanguageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LanguageType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Read is not None and 'Read' not in already_processed:
            already_processed.append('Read')
            outfile.write(' Read=%s' % (quote_attrib(self.Read), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.Write is not None and 'Write' not in already_processed:
            already_processed.append('Write')
            outfile.write(' Write=%s' % (quote_attrib(self.Write), ))
        if self.Understand is not None and 'Understand' not in already_processed:
            already_processed.append('Understand')
            outfile.write(' Understand=%s' % (quote_attrib(self.Understand), ))
        if self.Preference is not None and 'Preference' not in already_processed:
            already_processed.append('Preference')
            outfile.write(' Preference=%s' % (quote_attrib(self.Preference), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Speak is not None and 'Speak' not in already_processed:
            already_processed.append('Speak')
            outfile.write(' Speak=%s' % (quote_attrib(self.Speak), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LanguageType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LanguageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Read is not None and 'Read' not in already_processed:
            already_processed.append('Read')
            showIndent(outfile, level)
            outfile.write('Read = "%s",\n' % (self.Read,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.Write is not None and 'Write' not in already_processed:
            already_processed.append('Write')
            showIndent(outfile, level)
            outfile.write('Write = "%s",\n' % (self.Write,))
        if self.Understand is not None and 'Understand' not in already_processed:
            already_processed.append('Understand')
            showIndent(outfile, level)
            outfile.write('Understand = "%s",\n' % (self.Understand,))
        if self.Preference is not None and 'Preference' not in already_processed:
            already_processed.append('Preference')
            showIndent(outfile, level)
            outfile.write('Preference = "%s",\n' % (self.Preference,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.Speak is not None and 'Speak' not in already_processed:
            already_processed.append('Speak')
            showIndent(outfile, level)
            outfile.write('Speak = "%s",\n' % (self.Speak,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Read', node)
        if value is not None and 'Read' not in already_processed:
            already_processed.append('Read')
            self.Read = value
            self.validate_LanguageSkillsList(self.Read)    # validate type LanguageSkillsList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('Write', node)
        if value is not None and 'Write' not in already_processed:
            already_processed.append('Write')
            self.Write = value
            self.validate_LanguageSkillsList(self.Write)    # validate type LanguageSkillsList
        value = find_attr_value_('Understand', node)
        if value is not None and 'Understand' not in already_processed:
            already_processed.append('Understand')
            self.Understand = value
            self.validate_LanguageSkillsList(self.Understand)    # validate type LanguageSkillsList
        value = find_attr_value_('Preference', node)
        if value is not None and 'Preference' not in already_processed:
            already_processed.append('Preference')
            self.Preference = value
            self.validate_LanguagePreferenceList(self.Preference)    # validate type LanguagePreferenceList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_LanguageTypeList(self.Type)    # validate type LanguageTypeList
        value = find_attr_value_('Speak', node)
        if value is not None and 'Speak' not in already_processed:
            already_processed.append('Speak')
            self.Speak = value
            self.validate_LanguageSkillsList(self.Speak)    # validate type LanguageSkillsList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LanguageType


class CountryType2(CountryType):
    """Type of nationality - By birth, naturalization, citizenStatus of the
    entity. e.g. Old, Current, Inactive, Active, etc"""
    subclass = None
    superclass = CountryType
    def __init__(self, NameElement=None, Status=None, DateValidTo=None, DateValidFrom=None, Type=None):
        super(CountryType2, self).__init__(NameElement, )
        self.Status = _cast(None, Status)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.Type = _cast(None, Type)
        pass
    def factory(*args_, **kwargs_):
        if CountryType2.subclass:
            return CountryType2.subclass(*args_, **kwargs_)
        else:
            return CountryType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_NationalityTypeList(self, value):
        # Validate type NationalityTypeList, a restriction on xs:normalizedString.
        pass
    def export(self, outfile, level, namespace_='', name_='CountryType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryType2'):
        super(CountryType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType2')
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CountryType2', fromsubclass_=False, pretty_print=True):
        super(CountryType2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(CountryType2, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountryType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        super(CountryType2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CountryType2, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_NationalityTypeList(self.Type)    # validate type NationalityTypeList
        super(CountryType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CountryType2, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CountryType2


class OccupationType(GeneratedsSuper):
    """Is the party self employed? A boolean value expectedStatus of the
    entity. e.g. Old, Current, Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, isSelfEmployed=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, OccupationElement=None, Employer=None):
        self.Status = _cast(None, Status)
        self.isSelfEmployed = _cast(bool, isSelfEmployed)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        if OccupationElement is None:
            self.OccupationElement = []
        else:
            self.OccupationElement = OccupationElement
        self.Employer = Employer
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if OccupationType.subclass:
            return OccupationType.subclass(*args_, **kwargs_)
        else:
            return OccupationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OccupationElement(self): return self.OccupationElement
    def set_OccupationElement(self, OccupationElement): self.OccupationElement = OccupationElement
    def add_OccupationElement(self, value): self.OccupationElement.append(value)
    def insert_OccupationElement(self, index, value): self.OccupationElement[index] = value
    def get_Employer(self): return self.Employer
    def set_Employer(self, Employer): self.Employer = Employer
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_isSelfEmployed(self): return self.isSelfEmployed
    def set_isSelfEmployed(self, isSelfEmployed): self.isSelfEmployed = isSelfEmployed
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='OccupationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OccupationType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.isSelfEmployed is not None and 'isSelfEmployed' not in already_processed:
            already_processed.append('isSelfEmployed')
            outfile.write(' isSelfEmployed="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.isSelfEmployed)), input_name='isSelfEmployed'))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OccupationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OccupationElement_ in self.OccupationElement:
            OccupationElement_.export(outfile, level, namespace_, name_='OccupationElement', pretty_print=pretty_print)
        if self.Employer is not None:
            self.Employer.export(outfile, level, namespace_, name_='Employer', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.OccupationElement or
            self.Employer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OccupationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.isSelfEmployed is not None and 'isSelfEmployed' not in already_processed:
            already_processed.append('isSelfEmployed')
            showIndent(outfile, level)
            outfile.write('isSelfEmployed = %s,\n' % (self.isSelfEmployed,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OccupationElement=[\n')
        level += 1
        for OccupationElement_ in self.OccupationElement:
            showIndent(outfile, level)
            outfile.write('model_.OccupationElementType(\n')
            OccupationElement_.exportLiteral(outfile, level, name_='OccupationElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Employer is not None:
            showIndent(outfile, level)
            outfile.write('Employer=model_.EmployerType(\n')
            self.Employer.exportLiteral(outfile, level, name_='Employer')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('isSelfEmployed', node)
        if value is not None and 'isSelfEmployed' not in already_processed:
            already_processed.append('isSelfEmployed')
            if value in ('true', '1'):
                self.isSelfEmployed = True
            elif value in ('false', '0'):
                self.isSelfEmployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OccupationElement':
            obj_ = OccupationElementType.factory()
            obj_.build(child_)
            self.OccupationElement.append(obj_)
        elif nodeName_ == 'Employer':
            obj_ = EmployerType.factory()
            obj_.build(child_)
            self.set_Employer(obj_)
# end class OccupationType


class OccupationElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if OccupationElementType.subclass:
            return OccupationElementType.subclass(*args_, **kwargs_)
        else:
            return OccupationElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_OccupationElementList(self, value):
        # Validate type OccupationElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='OccupationElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OccupationElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OccupationElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OccupationElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OccupationElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_OccupationElementList(self.Type)    # validate type OccupationElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OccupationElementType


class EmployerType(OrganisationNameType):
    subclass = None
    superclass = OrganisationNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None):
        super(EmployerType, self).__init__(Status, LanguageCode, NameKeyRef, type_, ValidTo, DateValidFrom, label, DateValidTo, href, ValidFrom, NameKey, Usage, DataQualityType, OrganisationID, Type, ID, OrganisationIDType, NameElement, SubDivisionName, )
        pass
    def factory(*args_, **kwargs_):
        if EmployerType.subclass:
            return EmployerType.subclass(*args_, **kwargs_)
        else:
            return EmployerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='EmployerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmployerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmployerType'):
        super(EmployerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EmployerType')
    def exportChildren(self, outfile, level, namespace_='', name_='EmployerType', fromsubclass_=False, pretty_print=True):
        super(EmployerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(EmployerType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EmployerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EmployerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EmployerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EmployerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EmployerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EmployerType


class FreeTextLineType1(GeneratedsSuper):
    """Category or type of physical info"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FreeTextLineType1.subclass:
            return FreeTextLineType1.subclass(*args_, **kwargs_)
        else:
            return FreeTextLineType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PhysicalInfoFreeTextTypeList(self, value):
        # Validate type PhysicalInfoFreeTextTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FreeTextLineType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeTextLineType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreeTextLineType1'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FreeTextLineType1', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreeTextLineType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PhysicalInfoFreeTextTypeList(self.Type)    # validate type PhysicalInfoFreeTextTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FreeTextLineType1


class FeatureType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element.Defines the unit of measurement. Example:
    Inches, feet, cm, meters, days, months, years, kgs, pounds, etc."""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, UnitType=None, ValidFrom=None, Type=None, ValidTo=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.UnitType = _cast(None, UnitType)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.ValidTo = _cast(None, ValidTo)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FeatureType.subclass:
            return FeatureType.subclass(*args_, **kwargs_)
        else:
            return FeatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_UnitType(self): return self.UnitType
    def set_UnitType(self, UnitType): self.UnitType = UnitType
    def validate_UnitTypeList(self, value):
        # Validate type UnitTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_FeatureTypeList(self, value):
        # Validate type FeatureTypeList, a restriction on xs:normalizedString.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FeatureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FeatureType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FeatureType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.UnitType is not None and 'UnitType' not in already_processed:
            already_processed.append('UnitType')
            outfile.write(' UnitType=%s' % (quote_attrib(self.UnitType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FeatureType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FeatureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.UnitType is not None and 'UnitType' not in already_processed:
            already_processed.append('UnitType')
            showIndent(outfile, level)
            outfile.write('UnitType = "%s",\n' % (self.UnitType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('UnitType', node)
        if value is not None and 'UnitType' not in already_processed:
            already_processed.append('UnitType')
            self.UnitType = value
            self.validate_UnitTypeList(self.UnitType)    # validate type UnitTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_FeatureTypeList(self.Type)    # validate type FeatureTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FeatureType


class BodyMarkType(GeneratedsSuper):
    """Free text name/description of the body part where the mark is
    locatedFree text description of where on the body part the mark
    is located. E.g. left hand side, front, back, etc"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, Part=None, ValidFrom=None, Location=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.Part = _cast(None, Part)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Location = _cast(None, Location)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BodyMarkType.subclass:
            return BodyMarkType.subclass(*args_, **kwargs_)
        else:
            return BodyMarkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_Part(self): return self.Part
    def set_Part(self, Part): self.Part = Part
    def validate_BodyMarkPartList(self, value):
        # Validate type BodyMarkPartList, a restriction on xs:normalizedString.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def validate_BodyMarkPartLocationList(self, value):
        # Validate type BodyMarkPartLocationList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BodyMarkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BodyMarkType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BodyMarkType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.Part is not None and 'Part' not in already_processed:
            already_processed.append('Part')
            outfile.write(' Part=%s' % (quote_attrib(self.Part), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Location is not None and 'Location' not in already_processed:
            already_processed.append('Location')
            outfile.write(' Location=%s' % (quote_attrib(self.Location), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BodyMarkType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BodyMarkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.Part is not None and 'Part' not in already_processed:
            already_processed.append('Part')
            showIndent(outfile, level)
            outfile.write('Part = "%s",\n' % (self.Part,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Location is not None and 'Location' not in already_processed:
            already_processed.append('Location')
            showIndent(outfile, level)
            outfile.write('Location = "%s",\n' % (self.Location,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('Part', node)
        if value is not None and 'Part' not in already_processed:
            already_processed.append('Part')
            self.Part = value
            self.validate_BodyMarkPartList(self.Part)    # validate type BodyMarkPartList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Location', node)
        if value is not None and 'Location' not in already_processed:
            already_processed.append('Location')
            self.Location = value
            self.validate_BodyMarkPartLocationList(self.Location)    # validate type BodyMarkPartLocationList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BodyMarkType


class DisabilityType(GeneratedsSuper):
    """Free text description of the cause of the disability, e.g. birth
    defect, accident, etc."""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Cause=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Cause = _cast(None, Cause)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DisabilityType.subclass:
            return DisabilityType.subclass(*args_, **kwargs_)
        else:
            return DisabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Cause(self): return self.Cause
    def set_Cause(self, Cause): self.Cause = Cause
    def validate_DisabilityCauseList(self, value):
        # Validate type DisabilityCauseList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DisabilityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DisabilityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DisabilityType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Cause is not None and 'Cause' not in already_processed:
            already_processed.append('Cause')
            outfile.write(' Cause=%s' % (quote_attrib(self.Cause), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DisabilityType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DisabilityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Cause is not None and 'Cause' not in already_processed:
            already_processed.append('Cause')
            showIndent(outfile, level)
            outfile.write('Cause = "%s",\n' % (self.Cause,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Cause', node)
        if value is not None and 'Cause' not in already_processed:
            already_processed.append('Cause')
            self.Cause = value
            self.validate_DisabilityCauseList(self.Cause)    # validate type DisabilityCauseList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DisabilityType


class AllergyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValidTo=None, ValidFrom=None, DataQualityType=None, valueOf_=None):
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AllergyType.subclass:
            return AllergyType.subclass(*args_, **kwargs_)
        else:
            return AllergyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='AllergyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllergyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllergyType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AllergyType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AllergyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AllergyType


class HealthConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValidTo=None, ValidFrom=None, DataQualityType=None, valueOf_=None):
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if HealthConditionType.subclass:
            return HealthConditionType.subclass(*args_, **kwargs_)
        else:
            return HealthConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='HealthConditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HealthConditionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HealthConditionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HealthConditionType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HealthConditionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HealthConditionType


class PreferenceType(GeneratedsSuper):
    """Type of preference. e.g. seating position"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PreferenceType.subclass:
            return PreferenceType.subclass(*args_, **kwargs_)
        else:
            return PreferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PreferenceTypeList(self, value):
        # Validate type PreferenceTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PreferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PreferenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PreferenceType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PreferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PreferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PreferenceTypeList(self.Type)    # validate type PreferenceTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PreferenceType


class QualificationType(GeneratedsSuper):
    """Status of the entity. e.g. Old, Current, Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, QualificationElement=None, Institution=None):
        self.Status = _cast(None, Status)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        if QualificationElement is None:
            self.QualificationElement = []
        else:
            self.QualificationElement = QualificationElement
        self.Institution = Institution
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if QualificationType.subclass:
            return QualificationType.subclass(*args_, **kwargs_)
        else:
            return QualificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QualificationElement(self): return self.QualificationElement
    def set_QualificationElement(self, QualificationElement): self.QualificationElement = QualificationElement
    def add_QualificationElement(self, value): self.QualificationElement.append(value)
    def insert_QualificationElement(self, index, value): self.QualificationElement[index] = value
    def get_Institution(self): return self.Institution
    def set_Institution(self, Institution): self.Institution = Institution
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='QualificationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QualificationType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QualificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for QualificationElement_ in self.QualificationElement:
            QualificationElement_.export(outfile, level, namespace_, name_='QualificationElement', pretty_print=pretty_print)
        if self.Institution is not None:
            self.Institution.export(outfile, level, namespace_, name_='Institution', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.QualificationElement or
            self.Institution is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QualificationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('QualificationElement=[\n')
        level += 1
        for QualificationElement_ in self.QualificationElement:
            showIndent(outfile, level)
            outfile.write('model_.QualificationElementType(\n')
            QualificationElement_.exportLiteral(outfile, level, name_='QualificationElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Institution is not None:
            showIndent(outfile, level)
            outfile.write('Institution=model_.InstitutionType(\n')
            self.Institution.exportLiteral(outfile, level, name_='Institution')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QualificationElement':
            obj_ = QualificationElementType.factory()
            obj_.build(child_)
            self.QualificationElement.append(obj_)
        elif nodeName_ == 'Institution':
            obj_ = InstitutionType.factory()
            obj_.build(child_)
            self.set_Institution(obj_)
# end class QualificationType


class QualificationElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if QualificationElementType.subclass:
            return QualificationElementType.subclass(*args_, **kwargs_)
        else:
            return QualificationElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_QualificationElementList(self, value):
        # Validate type QualificationElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='QualificationElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualificationElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QualificationElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QualificationElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QualificationElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_QualificationElementList(self.Type)    # validate type QualificationElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QualificationElementType


class InstitutionType(OrganisationNameType):
    subclass = None
    superclass = OrganisationNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None):
        super(InstitutionType, self).__init__(Status, LanguageCode, NameKeyRef, type_, ValidTo, DateValidFrom, label, DateValidTo, href, ValidFrom, NameKey, Usage, DataQualityType, OrganisationID, Type, ID, OrganisationIDType, NameElement, SubDivisionName, )
        pass
    def factory(*args_, **kwargs_):
        if InstitutionType.subclass:
            return InstitutionType.subclass(*args_, **kwargs_)
        else:
            return InstitutionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='InstitutionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstitutionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstitutionType'):
        super(InstitutionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstitutionType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstitutionType', fromsubclass_=False, pretty_print=True):
        super(InstitutionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(InstitutionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InstitutionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstitutionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstitutionType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(InstitutionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstitutionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstitutionType


class VisaType(GeneratedsSuper):
    """Status of the entity. e.g. Old, Current, Inactive, Active, etc"""
    subclass = None
    superclass = None
    def __init__(self, Status=None, EntryByDate=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, DataQualityType=None, ValidFrom=None, VisaElement=None):
        self.Status = _cast(None, Status)
        self.EntryByDate = _cast(None, EntryByDate)
        self.ValidTo = _cast(None, ValidTo)
        self.DateValidFrom = _cast(None, DateValidFrom)
        self.DateValidTo = _cast(None, DateValidTo)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidFrom = _cast(None, ValidFrom)
        if VisaElement is None:
            self.VisaElement = []
        else:
            self.VisaElement = VisaElement
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VisaType.subclass:
            return VisaType.subclass(*args_, **kwargs_)
        else:
            return VisaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VisaElement(self): return self.VisaElement
    def set_VisaElement(self, VisaElement): self.VisaElement = VisaElement
    def add_VisaElement(self, value): self.VisaElement.append(value)
    def insert_VisaElement(self, index, value): self.VisaElement[index] = value
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_EntryByDate(self): return self.EntryByDate
    def set_EntryByDate(self, EntryByDate): self.EntryByDate = EntryByDate
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_DateValidFrom(self): return self.DateValidFrom
    def set_DateValidFrom(self, DateValidFrom): self.DateValidFrom = DateValidFrom
    def get_DateValidTo(self): return self.DateValidTo
    def set_DateValidTo(self, DateValidTo): self.DateValidTo = DateValidTo
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VisaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VisaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VisaType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.EntryByDate is not None and 'EntryByDate' not in already_processed:
            already_processed.append('EntryByDate')
            outfile.write(' EntryByDate=%s' % (self.gds_format_string(quote_attrib(self.EntryByDate).encode(ExternalEncoding), input_name='EntryByDate'), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            outfile.write(' DateValidFrom=%s' % (self.gds_format_string(quote_attrib(self.DateValidFrom).encode(ExternalEncoding), input_name='DateValidFrom'), ))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            outfile.write(' DateValidTo=%s' % (self.gds_format_string(quote_attrib(self.DateValidTo).encode(ExternalEncoding), input_name='DateValidTo'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VisaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VisaElement_ in self.VisaElement:
            VisaElement_.export(outfile, level, namespace_, name_='VisaElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.VisaElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VisaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.EntryByDate is not None and 'EntryByDate' not in already_processed:
            already_processed.append('EntryByDate')
            showIndent(outfile, level)
            outfile.write('EntryByDate = "%s",\n' % (self.EntryByDate,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.DateValidFrom is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            showIndent(outfile, level)
            outfile.write('DateValidFrom = "%s",\n' % (self.DateValidFrom,))
        if self.DateValidTo is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            showIndent(outfile, level)
            outfile.write('DateValidTo = "%s",\n' % (self.DateValidTo,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('VisaElement=[\n')
        level += 1
        for VisaElement_ in self.VisaElement:
            showIndent(outfile, level)
            outfile.write('model_.VisaElementType(\n')
            VisaElement_.exportLiteral(outfile, level, name_='VisaElementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('EntryByDate', node)
        if value is not None and 'EntryByDate' not in already_processed:
            already_processed.append('EntryByDate')
            self.EntryByDate = value
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('DateValidFrom', node)
        if value is not None and 'DateValidFrom' not in already_processed:
            already_processed.append('DateValidFrom')
            self.DateValidFrom = value
        value = find_attr_value_('DateValidTo', node)
        if value is not None and 'DateValidTo' not in already_processed:
            already_processed.append('DateValidTo')
            self.DateValidTo = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VisaElement':
            obj_ = VisaElementType.factory()
            obj_.build(child_)
            self.VisaElement.append(obj_)
# end class VisaType


class VisaElementType(GeneratedsSuper):
    """If present, specifies the type of the information provided as text
    value of the element."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, valueOf_=None):
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VisaElementType.subclass:
            return VisaElementType.subclass(*args_, **kwargs_)
        else:
            return VisaElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_VisaElementList(self, value):
        # Validate type VisaElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VisaElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VisaElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VisaElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VisaElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VisaElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_VisaElementList(self.Type)    # validate type VisaElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VisaElementType


class PersonNameType1(PersonNameType):
    subclass = None
    superclass = PersonNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, PersonID=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, PersonIDType=None, NameKey=None, Usage=None, DataQualityType=None, ValidFrom=None, Type=None, ID=None, NameElement=None):
        super(PersonNameType1, self).__init__(Status, LanguageCode, NameKeyRef, PersonID, type_, ValidTo, DateValidFrom, label, DateValidTo, href, PersonIDType, NameKey, Usage, DataQualityType, ValidFrom, Type, ID, NameElement, )
        pass
    def factory(*args_, **kwargs_):
        if PersonNameType1.subclass:
            return PersonNameType1.subclass(*args_, **kwargs_)
        else:
            return PersonNameType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PersonNameType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonNameType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonNameType1'):
        super(PersonNameType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PersonNameType1')
    def exportChildren(self, outfile, level, namespace_='', name_='PersonNameType1', fromsubclass_=False, pretty_print=True):
        super(PersonNameType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(PersonNameType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonNameType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PersonNameType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PersonNameType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PersonNameType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PersonNameType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PersonNameType1


class OrganisationNameType1(OrganisationNameType):
    subclass = None
    superclass = OrganisationNameType
    def __init__(self, Status=None, LanguageCode=None, NameKeyRef=None, type_=None, ValidTo=None, DateValidFrom=None, label=None, DateValidTo=None, href=None, ValidFrom=None, NameKey=None, Usage=None, DataQualityType=None, OrganisationID=None, Type=None, ID=None, OrganisationIDType=None, NameElement=None, SubDivisionName=None):
        super(OrganisationNameType1, self).__init__(Status, LanguageCode, NameKeyRef, type_, ValidTo, DateValidFrom, label, DateValidTo, href, ValidFrom, NameKey, Usage, DataQualityType, OrganisationID, Type, ID, OrganisationIDType, NameElement, SubDivisionName, )
        pass
    def factory(*args_, **kwargs_):
        if OrganisationNameType1.subclass:
            return OrganisationNameType1.subclass(*args_, **kwargs_)
        else:
            return OrganisationNameType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='OrganisationNameType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationNameType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrganisationNameType1'):
        super(OrganisationNameType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationNameType1')
    def exportChildren(self, outfile, level, namespace_='', name_='OrganisationNameType1', fromsubclass_=False, pretty_print=True):
        super(OrganisationNameType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(OrganisationNameType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OrganisationNameType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrganisationNameType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrganisationNameType1, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(OrganisationNameType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OrganisationNameType1, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OrganisationNameType1


class NameElementType(GeneratedsSuper):
    """Clarifies the meaning of the element.Could be first name, middle
    name, etc. that is defined in the List list. Omit this attribute
    if the type of the name element is not known."""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, ElementType=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.ElementType = _cast(None, ElementType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType.subclass:
            return NameElementType.subclass(*args_, **kwargs_)
        else:
            return NameElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_ElementType(self): return self.ElementType
    def set_ElementType(self, ElementType): self.ElementType = ElementType
    def validate_PersonNameElementList(self, value):
        # Validate type PersonNameElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.ElementType is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            outfile.write(' ElementType=%s' % (quote_attrib(self.ElementType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.ElementType is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            showIndent(outfile, level)
            outfile.write('ElementType = "%s",\n' % (self.ElementType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ElementType', node)
        if value is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            self.ElementType = value
            self.validate_PersonNameElementList(self.ElementType)    # validate type PersonNameElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType


class NameElementType1(GeneratedsSuper):
    """Clarifies the meaning of the element. Example: name, type . Omit
    this attribute if the type of the name element is not known."""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, ElementType=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.ElementType = _cast(None, ElementType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType1.subclass:
            return NameElementType1.subclass(*args_, **kwargs_)
        else:
            return NameElementType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_ElementType(self): return self.ElementType
    def set_ElementType(self, ElementType): self.ElementType = ElementType
    def validate_OrganisationNameElementList(self, value):
        # Validate type OrganisationNameElementList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType1'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.ElementType is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            outfile.write(' ElementType=%s' % (quote_attrib(self.ElementType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType1', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.ElementType is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            showIndent(outfile, level)
            outfile.write('ElementType = "%s",\n' % (self.ElementType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ElementType', node)
        if value is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            self.ElementType = value
            self.validate_OrganisationNameElementList(self.ElementType)    # validate type OrganisationNameElementList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType1


class SubDivisionNameType(GeneratedsSuper):
    """Type of sub division. e.g. department, warehouse, branch"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, Type=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if SubDivisionNameType.subclass:
            return SubDivisionNameType.subclass(*args_, **kwargs_)
        else:
            return SubDivisionNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SubDivisionTypeList(self, value):
        # Validate type SubDivisionTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='SubDivisionNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubDivisionNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubDivisionNameType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubDivisionNameType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubDivisionNameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_SubDivisionTypeList(self.Type)    # validate type SubDivisionTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubDivisionNameType


class FreeTextAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValidTo=None, ValidFrom=None, DataQualityType=None, AddressLine=None):
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        if AddressLine is None:
            self.AddressLine = []
        else:
            self.AddressLine = AddressLine
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FreeTextAddressType.subclass:
            return FreeTextAddressType.subclass(*args_, **kwargs_)
        else:
            return FreeTextAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AddressLine(self): return self.AddressLine
    def set_AddressLine(self, AddressLine): self.AddressLine = AddressLine
    def add_AddressLine(self, value): self.AddressLine.append(value)
    def insert_AddressLine(self, index, value): self.AddressLine[index] = value
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FreeTextAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeTextAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreeTextAddressType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FreeTextAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AddressLine_ in self.AddressLine:
            AddressLine_.export(outfile, level, namespace_, name_='AddressLine', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.AddressLine
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreeTextAddressType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AddressLine=[\n')
        level += 1
        for AddressLine_ in self.AddressLine:
            showIndent(outfile, level)
            outfile.write('model_.AddressLineType(\n')
            AddressLine_.exportLiteral(outfile, level, name_='AddressLineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AddressLine':
            obj_ = AddressLineType.factory()
            obj_.build(child_)
            self.AddressLine.append(obj_)
# end class FreeTextAddressType


class AddressLineType(GeneratedsSuper):
    """What does the address line describe? e.g. Street details, suburb
    details, post code details, whole address, etc"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, valueOf_=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AddressLineType.subclass:
            return AddressLineType.subclass(*args_, **kwargs_)
        else:
            return AddressLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AddressLineTypeList(self, value):
        # Validate type AddressLineTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='AddressLineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddressLineType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AddressLineType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AddressLineType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AddressLineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_AddressLineTypeList(self.Type)    # validate type AddressLineTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AddressLineType


class CountryType3(CountryType):
    subclass = None
    superclass = CountryType
    def __init__(self, NameElement=None):
        super(CountryType3, self).__init__(NameElement, )
        pass
    def factory(*args_, **kwargs_):
        if CountryType3.subclass:
            return CountryType3.subclass(*args_, **kwargs_)
        else:
            return CountryType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CountryType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CountryType3'):
        super(CountryType3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CountryType3')
    def exportChildren(self, outfile, level, namespace_='', name_='CountryType3', fromsubclass_=False, pretty_print=True):
        super(CountryType3, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(CountryType3, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CountryType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CountryType3, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CountryType3, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(CountryType3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CountryType3, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CountryType3


class AdministrativeAreaType(GeneratedsSuper):
    """Type of administrative area. e.g. state, city, town, etc"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, NameElement=None, SubAdministrativeArea=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        self.SubAdministrativeArea = SubAdministrativeArea
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AdministrativeAreaType.subclass:
            return AdministrativeAreaType.subclass(*args_, **kwargs_)
        else:
            return AdministrativeAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_SubAdministrativeArea(self): return self.SubAdministrativeArea
    def set_SubAdministrativeArea(self, SubAdministrativeArea): self.SubAdministrativeArea = SubAdministrativeArea
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_AdministrativeAreaTypeList(self, value):
        # Validate type AdministrativeAreaTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='AdministrativeAreaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdministrativeAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdministrativeAreaType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AdministrativeAreaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
        if self.SubAdministrativeArea is not None:
            self.SubAdministrativeArea.export(outfile, level, namespace_, name_='SubAdministrativeArea', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement or
            self.SubAdministrativeArea is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AdministrativeAreaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType2(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SubAdministrativeArea is not None:
            showIndent(outfile, level)
            outfile.write('SubAdministrativeArea=model_.SubAdministrativeAreaType(\n')
            self.SubAdministrativeArea.exportLiteral(outfile, level, name_='SubAdministrativeArea')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_AdministrativeAreaTypeList(self.Type)    # validate type AdministrativeAreaTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType2.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
        elif nodeName_ == 'SubAdministrativeArea':
            obj_ = SubAdministrativeAreaType.factory()
            obj_.build(child_)
            self.set_SubAdministrativeArea(obj_)
# end class AdministrativeAreaType


class NameElementType2(GeneratedsSuper):
    """semantics of data associated with nameName of administrative area
    represented as a code. e.g. "COL" for COLORADOType of code used
    to represent name as a code"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, NameCodeType=None, NameCode=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.NameCodeType = _cast(None, NameCodeType)
        self.NameCode = _cast(None, NameCode)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType2.subclass:
            return NameElementType2.subclass(*args_, **kwargs_)
        else:
            return NameElementType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_AdministrativeAreaNameTypeList(self, value):
        # Validate type AdministrativeAreaNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_NameCodeType(self): return self.NameCodeType
    def set_NameCodeType(self, NameCodeType): self.NameCodeType = NameCodeType
    def get_NameCode(self): return self.NameCode
    def set_NameCode(self, NameCode): self.NameCode = NameCode
    def validate_AdministrativeAreaNameCodeList(self, value):
        # Validate type AdministrativeAreaNameCodeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType2'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            outfile.write(' NameCodeType=%s' % (quote_attrib(self.NameCodeType), ))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            outfile.write(' NameCode=%s' % (quote_attrib(self.NameCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType2', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            showIndent(outfile, level)
            outfile.write('NameCodeType = %s,\n' % (self.NameCodeType,))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            showIndent(outfile, level)
            outfile.write('NameCode = "%s",\n' % (self.NameCode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_AdministrativeAreaNameTypeList(self.NameType)    # validate type AdministrativeAreaNameTypeList
        value = find_attr_value_('NameCodeType', node)
        if value is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            self.NameCodeType = value
        value = find_attr_value_('NameCode', node)
        if value is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            self.NameCode = value
            self.validate_AdministrativeAreaNameCodeList(self.NameCode)    # validate type AdministrativeAreaNameCodeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType2


class SubAdministrativeAreaType(GeneratedsSuper):
    """Type of sub administrative area"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, NameElement=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if SubAdministrativeAreaType.subclass:
            return SubAdministrativeAreaType.subclass(*args_, **kwargs_)
        else:
            return SubAdministrativeAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SubAdministrativeAreaTypeList(self, value):
        # Validate type SubAdministrativeAreaTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='SubAdministrativeAreaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubAdministrativeAreaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubAdministrativeAreaType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubAdministrativeAreaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubAdministrativeAreaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType3(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_SubAdministrativeAreaTypeList(self.Type)    # validate type SubAdministrativeAreaTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType3.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
# end class SubAdministrativeAreaType


class NameElementType3(GeneratedsSuper):
    """semantics of data associated with nameName of administrative area
    represented as a code. e.g. "COL" for COLORADOType of code used
    to represent name as a code"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, NameCodeType=None, NameCode=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.NameCodeType = _cast(None, NameCodeType)
        self.NameCode = _cast(None, NameCode)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType3.subclass:
            return NameElementType3.subclass(*args_, **kwargs_)
        else:
            return NameElementType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_SubAdministrativeAreaNameTypeList(self, value):
        # Validate type SubAdministrativeAreaNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_NameCodeType(self): return self.NameCodeType
    def set_NameCodeType(self, NameCodeType): self.NameCodeType = NameCodeType
    def get_NameCode(self): return self.NameCode
    def set_NameCode(self, NameCode): self.NameCode = NameCode
    def validate_SubAdministrativeAreaNameCodeList(self, value):
        # Validate type SubAdministrativeAreaNameCodeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType3'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            outfile.write(' NameCodeType=%s' % (quote_attrib(self.NameCodeType), ))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            outfile.write(' NameCode=%s' % (quote_attrib(self.NameCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType3', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            showIndent(outfile, level)
            outfile.write('NameCodeType = %s,\n' % (self.NameCodeType,))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            showIndent(outfile, level)
            outfile.write('NameCode = "%s",\n' % (self.NameCode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_SubAdministrativeAreaNameTypeList(self.NameType)    # validate type SubAdministrativeAreaNameTypeList
        value = find_attr_value_('NameCodeType', node)
        if value is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            self.NameCodeType = value
        value = find_attr_value_('NameCode', node)
        if value is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            self.NameCode = value
            self.validate_SubAdministrativeAreaNameCodeList(self.NameCode)    # validate type SubAdministrativeAreaNameCodeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType3


class LocalityType(GeneratedsSuper):
    """Type of locality. e.g. suburb, area, zone, village, etc"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, NameElement=None, SubLocality=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        self.SubLocality = SubLocality
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LocalityType.subclass:
            return LocalityType.subclass(*args_, **kwargs_)
        else:
            return LocalityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_SubLocality(self): return self.SubLocality
    def set_SubLocality(self, SubLocality): self.SubLocality = SubLocality
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_LocalityTypeList(self, value):
        # Validate type LocalityTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LocalityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalityType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LocalityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
        if self.SubLocality is not None:
            self.SubLocality.export(outfile, level, namespace_, name_='SubLocality', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement or
            self.SubLocality is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType4(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType4')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SubLocality is not None:
            showIndent(outfile, level)
            outfile.write('SubLocality=model_.SubLocalityType(\n')
            self.SubLocality.exportLiteral(outfile, level, name_='SubLocality')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_LocalityTypeList(self.Type)    # validate type LocalityTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType4.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
        elif nodeName_ == 'SubLocality':
            obj_ = SubLocalityType.factory()
            obj_.build(child_)
            self.set_SubLocality(obj_)
# end class LocalityType


class NameElementType4(GeneratedsSuper):
    """semantics of data associated with namename of locality represented
    as a codetype of code used to represent name as a code"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, NameCodeType=None, NameCode=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.NameCodeType = _cast(None, NameCodeType)
        self.NameCode = _cast(None, NameCode)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType4.subclass:
            return NameElementType4.subclass(*args_, **kwargs_)
        else:
            return NameElementType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_LocalityNameTypeList(self, value):
        # Validate type LocalityNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_NameCodeType(self): return self.NameCodeType
    def set_NameCodeType(self, NameCodeType): self.NameCodeType = NameCodeType
    def get_NameCode(self): return self.NameCode
    def set_NameCode(self, NameCode): self.NameCode = NameCode
    def validate_LocalityNameCodeList(self, value):
        # Validate type LocalityNameCodeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType4')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType4'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            outfile.write(' NameCodeType=%s' % (quote_attrib(self.NameCodeType), ))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            outfile.write(' NameCode=%s' % (quote_attrib(self.NameCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType4', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            showIndent(outfile, level)
            outfile.write('NameCodeType = %s,\n' % (self.NameCodeType,))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            showIndent(outfile, level)
            outfile.write('NameCode = "%s",\n' % (self.NameCode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_LocalityNameTypeList(self.NameType)    # validate type LocalityNameTypeList
        value = find_attr_value_('NameCodeType', node)
        if value is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            self.NameCodeType = value
        value = find_attr_value_('NameCode', node)
        if value is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            self.NameCode = value
            self.validate_LocalityNameCodeList(self.NameCode)    # validate type LocalityNameCodeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType4


class SubLocalityType(GeneratedsSuper):
    """Type of sub locality"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, NameElement=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if NameElement is None:
            self.NameElement = []
        else:
            self.NameElement = NameElement
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if SubLocalityType.subclass:
            return SubLocalityType.subclass(*args_, **kwargs_)
        else:
            return SubLocalityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NameElement(self): return self.NameElement
    def set_NameElement(self, NameElement): self.NameElement = NameElement
    def add_NameElement(self, value): self.NameElement.append(value)
    def insert_NameElement(self, index, value): self.NameElement[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SubLocalityTypeList(self, value):
        # Validate type SubLocalityTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='SubLocalityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubLocalityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubLocalityType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubLocalityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NameElement_ in self.NameElement:
            NameElement_.export(outfile, level, namespace_, name_='NameElement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NameElement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubLocalityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NameElement=[\n')
        level += 1
        for NameElement_ in self.NameElement:
            showIndent(outfile, level)
            outfile.write('model_.NameElementType5(\n')
            NameElement_.exportLiteral(outfile, level, name_='NameElementType5')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_SubLocalityTypeList(self.Type)    # validate type SubLocalityTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NameElement':
            obj_ = NameElementType5.factory()
            obj_.build(child_)
            self.NameElement.append(obj_)
# end class SubLocalityType


class NameElementType5(GeneratedsSuper):
    """semantics of data associated with namename of locality represented
    as a codetype of code used to represent name as a code"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, NameCodeType=None, NameCode=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.NameCodeType = _cast(None, NameCodeType)
        self.NameCode = _cast(None, NameCode)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType5.subclass:
            return NameElementType5.subclass(*args_, **kwargs_)
        else:
            return NameElementType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_SubLocalityNameTypeList(self, value):
        # Validate type SubLocalityNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_NameCodeType(self): return self.NameCodeType
    def set_NameCodeType(self, NameCodeType): self.NameCodeType = NameCodeType
    def get_NameCode(self): return self.NameCode
    def set_NameCode(self, NameCode): self.NameCode = NameCode
    def validate_SubLocalityNameCodeList(self, value):
        # Validate type SubLocalityNameCodeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType5')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType5'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            outfile.write(' NameCodeType=%s' % (quote_attrib(self.NameCodeType), ))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            outfile.write(' NameCode=%s' % (quote_attrib(self.NameCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType5', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType5'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            showIndent(outfile, level)
            outfile.write('NameCodeType = %s,\n' % (self.NameCodeType,))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            showIndent(outfile, level)
            outfile.write('NameCode = "%s",\n' % (self.NameCode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_SubLocalityNameTypeList(self.NameType)    # validate type SubLocalityNameTypeList
        value = find_attr_value_('NameCodeType', node)
        if value is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            self.NameCodeType = value
        value = find_attr_value_('NameCode', node)
        if value is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            self.NameCode = value
            self.validate_SubLocalityNameCodeList(self.NameCode)    # validate type SubLocalityNameCodeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType5


class ThoroughfareType1(ThoroughfareType):
    subclass = None
    superclass = ThoroughfareType
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, TypeCode=None, NameElement=None, Number=None, SubThoroughfare=None):
        super(ThoroughfareType1, self).__init__(DataQualityType, ValidTo, ValidFrom, Type, TypeCode, NameElement, Number, )
        if SubThoroughfare is None:
            self.SubThoroughfare = []
        else:
            self.SubThoroughfare = SubThoroughfare
    def factory(*args_, **kwargs_):
        if ThoroughfareType1.subclass:
            return ThoroughfareType1.subclass(*args_, **kwargs_)
        else:
            return ThoroughfareType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubThoroughfare(self): return self.SubThoroughfare
    def set_SubThoroughfare(self, SubThoroughfare): self.SubThoroughfare = SubThoroughfare
    def add_SubThoroughfare(self, value): self.SubThoroughfare.append(value)
    def insert_SubThoroughfare(self, index, value): self.SubThoroughfare[index] = value
    def export(self, outfile, level, namespace_='', name_='ThoroughfareType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThoroughfareType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThoroughfareType1'):
        super(ThoroughfareType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ThoroughfareType1')
    def exportChildren(self, outfile, level, namespace_='', name_='ThoroughfareType1', fromsubclass_=False, pretty_print=True):
        super(ThoroughfareType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubThoroughfare_ in self.SubThoroughfare:
            SubThoroughfare_.export(outfile, level, namespace_, name_='SubThoroughfare', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.SubThoroughfare or
            super(ThoroughfareType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ThoroughfareType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ThoroughfareType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ThoroughfareType1, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SubThoroughfare=[\n')
        level += 1
        for SubThoroughfare_ in self.SubThoroughfare:
            showIndent(outfile, level)
            outfile.write('model_.SubThoroughfareType(\n')
            SubThoroughfare_.exportLiteral(outfile, level, name_='SubThoroughfareType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ThoroughfareType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubThoroughfare':
            obj_ = SubThoroughfareType.factory()
            obj_.build(child_)
            self.SubThoroughfare.append(obj_)
        super(ThoroughfareType1, self).buildChildren(child_, node, nodeName_, True)
# end class ThoroughfareType1


class SubThoroughfareType(ThoroughfareType):
    subclass = None
    superclass = ThoroughfareType
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, TypeCode=None, NameElement=None, Number=None):
        super(SubThoroughfareType, self).__init__(DataQualityType, ValidTo, ValidFrom, Type, TypeCode, NameElement, Number, )
        pass
    def factory(*args_, **kwargs_):
        if SubThoroughfareType.subclass:
            return SubThoroughfareType.subclass(*args_, **kwargs_)
        else:
            return SubThoroughfareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SubThoroughfareType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubThoroughfareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubThoroughfareType'):
        super(SubThoroughfareType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubThoroughfareType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubThoroughfareType', fromsubclass_=False, pretty_print=True):
        super(SubThoroughfareType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(SubThoroughfareType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubThoroughfareType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubThoroughfareType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubThoroughfareType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(SubThoroughfareType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubThoroughfareType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubThoroughfareType


class PremisesType1(PremisesType):
    """Type of code use for Premises Type attribute"""
    subclass = None
    superclass = PremisesType
    def __init__(self, NameElement=None, Number=None, Type=None, TypeCode=None, SubPremises=None):
        super(PremisesType1, self).__init__(NameElement, Number, )
        self.Type = _cast(None, Type)
        self.TypeCode = _cast(None, TypeCode)
        if SubPremises is None:
            self.SubPremises = []
        else:
            self.SubPremises = SubPremises
    def factory(*args_, **kwargs_):
        if PremisesType1.subclass:
            return PremisesType1.subclass(*args_, **kwargs_)
        else:
            return PremisesType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubPremises(self): return self.SubPremises
    def set_SubPremises(self, SubPremises): self.SubPremises = SubPremises
    def add_SubPremises(self, value): self.SubPremises.append(value)
    def insert_SubPremises(self, index, value): self.SubPremises[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PremisesTypeList(self, value):
        # Validate type PremisesTypeList, a restriction on xs:normalizedString.
        pass
    def get_TypeCode(self): return self.TypeCode
    def set_TypeCode(self, TypeCode): self.TypeCode = TypeCode
    def export(self, outfile, level, namespace_='', name_='PremisesType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PremisesType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PremisesType1'):
        super(PremisesType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PremisesType1')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.TypeCode is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            outfile.write(' TypeCode=%s' % (quote_attrib(self.TypeCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PremisesType1', fromsubclass_=False, pretty_print=True):
        super(PremisesType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubPremises_ in self.SubPremises:
            SubPremises_.export(outfile, level, namespace_, name_='SubPremises', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.SubPremises or
            super(PremisesType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PremisesType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.TypeCode is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            showIndent(outfile, level)
            outfile.write('TypeCode = %s,\n' % (self.TypeCode,))
        super(PremisesType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PremisesType1, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SubPremises=[\n')
        level += 1
        for SubPremises_ in self.SubPremises:
            showIndent(outfile, level)
            outfile.write('model_.SubPremisesType(\n')
            SubPremises_.exportLiteral(outfile, level, name_='SubPremisesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PremisesTypeList(self.Type)    # validate type PremisesTypeList
        value = find_attr_value_('TypeCode', node)
        if value is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            self.TypeCode = value
        super(PremisesType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubPremises':
            obj_ = SubPremisesType.factory()
            obj_.build(child_)
            self.SubPremises.append(obj_)
        super(PremisesType1, self).buildChildren(child_, node, nodeName_, True)
# end class PremisesType1


class SubPremisesType(PremisesType):
    """Type of code used for sub premises type attribute"""
    subclass = None
    superclass = PremisesType
    def __init__(self, NameElement=None, Number=None, Type=None, TypeCode=None):
        super(SubPremisesType, self).__init__(NameElement, Number, )
        self.Type = _cast(None, Type)
        self.TypeCode = _cast(None, TypeCode)
        pass
    def factory(*args_, **kwargs_):
        if SubPremisesType.subclass:
            return SubPremisesType.subclass(*args_, **kwargs_)
        else:
            return SubPremisesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_SubPremisesTypeList(self, value):
        # Validate type SubPremisesTypeList, a restriction on xs:normalizedString.
        pass
    def get_TypeCode(self): return self.TypeCode
    def set_TypeCode(self, TypeCode): self.TypeCode = TypeCode
    def export(self, outfile, level, namespace_='', name_='SubPremisesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubPremisesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubPremisesType'):
        super(SubPremisesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubPremisesType')
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.TypeCode is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            outfile.write(' TypeCode=%s' % (quote_attrib(self.TypeCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubPremisesType', fromsubclass_=False, pretty_print=True):
        super(SubPremisesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(SubPremisesType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubPremisesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        if self.TypeCode is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            showIndent(outfile, level)
            outfile.write('TypeCode = %s,\n' % (self.TypeCode,))
        super(SubPremisesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubPremisesType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_SubPremisesTypeList(self.Type)    # validate type SubPremisesTypeList
        value = find_attr_value_('TypeCode', node)
        if value is not None and 'TypeCode' not in already_processed:
            already_processed.append('TypeCode')
            self.TypeCode = value
        super(SubPremisesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubPremisesType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubPremisesType


class PostCodeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValidTo=None, ValidFrom=None, DataQualityType=None, Identifier=None):
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.DataQualityType = _cast(None, DataQualityType)
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PostCodeType.subclass:
            return PostCodeType.subclass(*args_, **kwargs_)
        else:
            return PostCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PostCodeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostCodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostCodeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PostCodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Identifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostCodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            Identifier_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
# end class PostCodeType


class RuralDeliveryType(GeneratedsSuper):
    """Type of rural delivery. For some addresses, delivery to rural areas
    happens via water, air or road"""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, Identifier=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RuralDeliveryType.subclass:
            return RuralDeliveryType.subclass(*args_, **kwargs_)
        else:
            return RuralDeliveryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_RuralDeliveryTypeList(self, value):
        # Validate type RuralDeliveryTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RuralDeliveryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RuralDeliveryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RuralDeliveryType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RuralDeliveryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Identifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RuralDeliveryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            Identifier_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_RuralDeliveryTypeList(self.Type)    # validate type RuralDeliveryTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
# end class RuralDeliveryType


class PostalDeliveryPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, Identifier=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PostalDeliveryPointType.subclass:
            return PostalDeliveryPointType.subclass(*args_, **kwargs_)
        else:
            return PostalDeliveryPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PostalDeliveryPointTypeList(self, value):
        # Validate type PostalDeliveryPointTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PostalDeliveryPointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalDeliveryPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostalDeliveryPointType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PostalDeliveryPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Identifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostalDeliveryPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            Identifier_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PostalDeliveryPointTypeList(self.Type)    # validate type PostalDeliveryPointTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
# end class PostalDeliveryPointType


class PostOfficeType(GeneratedsSuper):
    """Indicates the type of postal delivery office from where the mail
    will be distributed to the final delivery point by a delivery
    mode. Example: Post Office, Mail Collection Centre, Letter
    Carrier Depot, Station, etc."""
    subclass = None
    superclass = None
    def __init__(self, DataQualityType=None, ValidTo=None, ValidFrom=None, Type=None, Identifier=None):
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Type = _cast(None, Type)
        if Identifier is None:
            self.Identifier = []
        else:
            self.Identifier = Identifier
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PostOfficeType.subclass:
            return PostOfficeType.subclass(*args_, **kwargs_)
        else:
            return PostOfficeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identifier(self): return self.Identifier
    def set_Identifier(self, Identifier): self.Identifier = Identifier
    def add_Identifier(self, value): self.Identifier.append(value)
    def insert_Identifier(self, index, value): self.Identifier[index] = value
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PostOfficeTypeList(self, value):
        # Validate type PostOfficeTypeList, a restriction on xs:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PostOfficeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostOfficeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PostOfficeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PostOfficeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Identifier_ in self.Identifier:
            Identifier_.export(outfile, level, namespace_, name_='Identifier', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Identifier
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostOfficeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Identifier=[\n')
        level += 1
        for Identifier_ in self.Identifier:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierType(\n')
            Identifier_.exportLiteral(outfile, level, name_='IdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
            self.validate_PostOfficeTypeList(self.Type)    # validate type PostOfficeTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identifier':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.Identifier.append(obj_)
# end class PostOfficeType


class GeoRSSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GeoRSSType.subclass:
            return GeoRSSType.subclass(*args_, **kwargs_)
        else:
            return GeoRSSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GeoRSSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeoRSSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GeoRSSType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GeoRSSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeoRSSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'GeoRSSType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class GeoRSSType


class LocationByCoordinatesType(GeneratedsSuper):
    """The collection of the coordinate numeric values for latitude amd
    longtitude depends on the agreed position of the meridian.
    Declaration of the meridian is necessary as it cannot be assumed
    in the dataType of code used. e.g. EPSG CodeThe collection of
    the coordinate numeric values depends on the agreed datum within
    which the measurement was taken. Declaration of the datum is
    necessary as it cannot be assumed in the dataType of code used.
    e.g. EPSG Code, WGS-84Coordinates have limited utility and
    application depending on the projection required for
    visualisation in a map. Declaration of projection is necessary
    as it cannot be assumed in dataType of code used. e.g. EPSG Code"""
    subclass = None
    superclass = None
    def __init__(self, Projection=None, MeridianCodeType=None, DatumCodeType=None, Datum=None, DataQualityType=None, ValidTo=None, ValidFrom=None, Meridian=None, ProjectionCodeType=None, Latitude=None, Longitude=None):
        self.Projection = _cast(None, Projection)
        self.MeridianCodeType = _cast(None, MeridianCodeType)
        self.DatumCodeType = _cast(None, DatumCodeType)
        self.Datum = _cast(None, Datum)
        self.DataQualityType = _cast(None, DataQualityType)
        self.ValidTo = _cast(None, ValidTo)
        self.ValidFrom = _cast(None, ValidFrom)
        self.Meridian = _cast(None, Meridian)
        self.ProjectionCodeType = _cast(None, ProjectionCodeType)
        self.Latitude = Latitude
        self.Longitude = Longitude
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LocationByCoordinatesType.subclass:
            return LocationByCoordinatesType.subclass(*args_, **kwargs_)
        else:
            return LocationByCoordinatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Latitude(self): return self.Latitude
    def set_Latitude(self, Latitude): self.Latitude = Latitude
    def get_Longitude(self): return self.Longitude
    def set_Longitude(self, Longitude): self.Longitude = Longitude
    def get_Projection(self): return self.Projection
    def set_Projection(self, Projection): self.Projection = Projection
    def validate_ProjectionCodeList(self, value):
        # Validate type ProjectionCodeList, a restriction on xs:normalizedString.
        pass
    def get_MeridianCodeType(self): return self.MeridianCodeType
    def set_MeridianCodeType(self, MeridianCodeType): self.MeridianCodeType = MeridianCodeType
    def get_DatumCodeType(self): return self.DatumCodeType
    def set_DatumCodeType(self, DatumCodeType): self.DatumCodeType = DatumCodeType
    def get_Datum(self): return self.Datum
    def set_Datum(self, Datum): self.Datum = Datum
    def validate_DatumCodeList(self, value):
        # Validate type DatumCodeList, a restriction on xs:normalizedString.
        pass
    def get_DataQualityType(self): return self.DataQualityType
    def set_DataQualityType(self, DataQualityType): self.DataQualityType = DataQualityType
    def validate_DataQualityTypeList(self, value):
        # Validate type DataQualityTypeList, a restriction on xs:string.
        pass
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_Meridian(self): return self.Meridian
    def set_Meridian(self, Meridian): self.Meridian = Meridian
    def validate_MeridianCodeList(self, value):
        # Validate type MeridianCodeList, a restriction on xs:normalizedString.
        pass
    def get_ProjectionCodeType(self): return self.ProjectionCodeType
    def set_ProjectionCodeType(self, ProjectionCodeType): self.ProjectionCodeType = ProjectionCodeType
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LocationByCoordinatesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationByCoordinatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationByCoordinatesType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Projection is not None and 'Projection' not in already_processed:
            already_processed.append('Projection')
            outfile.write(' Projection=%s' % (quote_attrib(self.Projection), ))
        if self.MeridianCodeType is not None and 'MeridianCodeType' not in already_processed:
            already_processed.append('MeridianCodeType')
            outfile.write(' MeridianCodeType=%s' % (quote_attrib(self.MeridianCodeType), ))
        if self.DatumCodeType is not None and 'DatumCodeType' not in already_processed:
            already_processed.append('DatumCodeType')
            outfile.write(' DatumCodeType=%s' % (quote_attrib(self.DatumCodeType), ))
        if self.Datum is not None and 'Datum' not in already_processed:
            already_processed.append('Datum')
            outfile.write(' Datum=%s' % (quote_attrib(self.Datum), ))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            outfile.write(' DataQualityType=%s' % (quote_attrib(self.DataQualityType), ))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            outfile.write(' ValidTo=%s' % (self.gds_format_string(quote_attrib(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), ))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            outfile.write(' ValidFrom=%s' % (self.gds_format_string(quote_attrib(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), ))
        if self.Meridian is not None and 'Meridian' not in already_processed:
            already_processed.append('Meridian')
            outfile.write(' Meridian=%s' % (quote_attrib(self.Meridian), ))
        if self.ProjectionCodeType is not None and 'ProjectionCodeType' not in already_processed:
            already_processed.append('ProjectionCodeType')
            outfile.write(' ProjectionCodeType=%s' % (quote_attrib(self.ProjectionCodeType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LocationByCoordinatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Latitude is not None:
            self.Latitude.export(outfile, level, namespace_, name_='Latitude', pretty_print=pretty_print)
        if self.Longitude is not None:
            self.Longitude.export(outfile, level, namespace_, name_='Longitude', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Latitude is not None or
            self.Longitude is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationByCoordinatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Projection is not None and 'Projection' not in already_processed:
            already_processed.append('Projection')
            showIndent(outfile, level)
            outfile.write('Projection = "%s",\n' % (self.Projection,))
        if self.MeridianCodeType is not None and 'MeridianCodeType' not in already_processed:
            already_processed.append('MeridianCodeType')
            showIndent(outfile, level)
            outfile.write('MeridianCodeType = %s,\n' % (self.MeridianCodeType,))
        if self.DatumCodeType is not None and 'DatumCodeType' not in already_processed:
            already_processed.append('DatumCodeType')
            showIndent(outfile, level)
            outfile.write('DatumCodeType = %s,\n' % (self.DatumCodeType,))
        if self.Datum is not None and 'Datum' not in already_processed:
            already_processed.append('Datum')
            showIndent(outfile, level)
            outfile.write('Datum = "%s",\n' % (self.Datum,))
        if self.DataQualityType is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            showIndent(outfile, level)
            outfile.write('DataQualityType = "%s",\n' % (self.DataQualityType,))
        if self.ValidTo is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            showIndent(outfile, level)
            outfile.write('ValidTo = "%s",\n' % (self.ValidTo,))
        if self.ValidFrom is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            showIndent(outfile, level)
            outfile.write('ValidFrom = "%s",\n' % (self.ValidFrom,))
        if self.Meridian is not None and 'Meridian' not in already_processed:
            already_processed.append('Meridian')
            showIndent(outfile, level)
            outfile.write('Meridian = "%s",\n' % (self.Meridian,))
        if self.ProjectionCodeType is not None and 'ProjectionCodeType' not in already_processed:
            already_processed.append('ProjectionCodeType')
            showIndent(outfile, level)
            outfile.write('ProjectionCodeType = %s,\n' % (self.ProjectionCodeType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Latitude is not None:
            showIndent(outfile, level)
            outfile.write('Latitude=model_.LatitudeType(\n')
            self.Latitude.exportLiteral(outfile, level, name_='Latitude')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Longitude is not None:
            showIndent(outfile, level)
            outfile.write('Longitude=model_.LongitudeType(\n')
            self.Longitude.exportLiteral(outfile, level, name_='Longitude')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Projection', node)
        if value is not None and 'Projection' not in already_processed:
            already_processed.append('Projection')
            self.Projection = value
            self.validate_ProjectionCodeList(self.Projection)    # validate type ProjectionCodeList
        value = find_attr_value_('MeridianCodeType', node)
        if value is not None and 'MeridianCodeType' not in already_processed:
            already_processed.append('MeridianCodeType')
            self.MeridianCodeType = value
        value = find_attr_value_('DatumCodeType', node)
        if value is not None and 'DatumCodeType' not in already_processed:
            already_processed.append('DatumCodeType')
            self.DatumCodeType = value
        value = find_attr_value_('Datum', node)
        if value is not None and 'Datum' not in already_processed:
            already_processed.append('Datum')
            self.Datum = value
            self.validate_DatumCodeList(self.Datum)    # validate type DatumCodeList
        value = find_attr_value_('DataQualityType', node)
        if value is not None and 'DataQualityType' not in already_processed:
            already_processed.append('DataQualityType')
            self.DataQualityType = value
            self.validate_DataQualityTypeList(self.DataQualityType)    # validate type DataQualityTypeList
        value = find_attr_value_('ValidTo', node)
        if value is not None and 'ValidTo' not in already_processed:
            already_processed.append('ValidTo')
            self.ValidTo = value
        value = find_attr_value_('ValidFrom', node)
        if value is not None and 'ValidFrom' not in already_processed:
            already_processed.append('ValidFrom')
            self.ValidFrom = value
        value = find_attr_value_('Meridian', node)
        if value is not None and 'Meridian' not in already_processed:
            already_processed.append('Meridian')
            self.Meridian = value
            self.validate_MeridianCodeList(self.Meridian)    # validate type MeridianCodeList
        value = find_attr_value_('ProjectionCodeType', node)
        if value is not None and 'ProjectionCodeType' not in already_processed:
            already_processed.append('ProjectionCodeType')
            self.ProjectionCodeType = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Latitude':
            obj_ = LatitudeType.factory()
            obj_.build(child_)
            self.set_Latitude(obj_)
        elif nodeName_ == 'Longitude':
            obj_ = LongitudeType.factory()
            obj_.build(child_)
            self.set_Longitude(obj_)
# end class LocationByCoordinatesType


class LatitudeType(GeneratedsSuper):
    """Measure of the latitude in degreesMeasure of the latitude in
    minutesMeasure of the latitude in secondsThe direction of
    latitude measurement offset from the equator"""
    subclass = None
    superclass = None
    def __init__(self, Direction=None, MinutesMeasure=None, SecondsMeasure=None, DegreesMeasure=None):
        self.Direction = _cast(None, Direction)
        self.MinutesMeasure = _cast(None, MinutesMeasure)
        self.SecondsMeasure = _cast(None, SecondsMeasure)
        self.DegreesMeasure = _cast(None, DegreesMeasure)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LatitudeType.subclass:
            return LatitudeType.subclass(*args_, **kwargs_)
        else:
            return LatitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    def validate_DirectionTypeList(self, value):
        # Validate type DirectionTypeList, a restriction on xs:normalizedString.
        pass
    def get_MinutesMeasure(self): return self.MinutesMeasure
    def set_MinutesMeasure(self, MinutesMeasure): self.MinutesMeasure = MinutesMeasure
    def get_SecondsMeasure(self): return self.SecondsMeasure
    def set_SecondsMeasure(self, SecondsMeasure): self.SecondsMeasure = SecondsMeasure
    def get_DegreesMeasure(self): return self.DegreesMeasure
    def set_DegreesMeasure(self, DegreesMeasure): self.DegreesMeasure = DegreesMeasure
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LatitudeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LatitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LatitudeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Direction is not None and 'Direction' not in already_processed:
            already_processed.append('Direction')
            outfile.write(' Direction=%s' % (quote_attrib(self.Direction), ))
        if self.MinutesMeasure is not None and 'MinutesMeasure' not in already_processed:
            already_processed.append('MinutesMeasure')
            outfile.write(' MinutesMeasure=%s' % (quote_attrib(self.MinutesMeasure), ))
        if self.SecondsMeasure is not None and 'SecondsMeasure' not in already_processed:
            already_processed.append('SecondsMeasure')
            outfile.write(' SecondsMeasure=%s' % (quote_attrib(self.SecondsMeasure), ))
        if self.DegreesMeasure is not None and 'DegreesMeasure' not in already_processed:
            already_processed.append('DegreesMeasure')
            outfile.write(' DegreesMeasure=%s' % (quote_attrib(self.DegreesMeasure), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LatitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LatitudeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Direction is not None and 'Direction' not in already_processed:
            already_processed.append('Direction')
            showIndent(outfile, level)
            outfile.write('Direction = "%s",\n' % (self.Direction,))
        if self.MinutesMeasure is not None and 'MinutesMeasure' not in already_processed:
            already_processed.append('MinutesMeasure')
            showIndent(outfile, level)
            outfile.write('MinutesMeasure = %s,\n' % (self.MinutesMeasure,))
        if self.SecondsMeasure is not None and 'SecondsMeasure' not in already_processed:
            already_processed.append('SecondsMeasure')
            showIndent(outfile, level)
            outfile.write('SecondsMeasure = %s,\n' % (self.SecondsMeasure,))
        if self.DegreesMeasure is not None and 'DegreesMeasure' not in already_processed:
            already_processed.append('DegreesMeasure')
            showIndent(outfile, level)
            outfile.write('DegreesMeasure = %s,\n' % (self.DegreesMeasure,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Direction', node)
        if value is not None and 'Direction' not in already_processed:
            already_processed.append('Direction')
            self.Direction = value
            self.validate_DirectionTypeList(self.Direction)    # validate type DirectionTypeList
        value = find_attr_value_('MinutesMeasure', node)
        if value is not None and 'MinutesMeasure' not in already_processed:
            already_processed.append('MinutesMeasure')
            self.MinutesMeasure = value
        value = find_attr_value_('SecondsMeasure', node)
        if value is not None and 'SecondsMeasure' not in already_processed:
            already_processed.append('SecondsMeasure')
            self.SecondsMeasure = value
        value = find_attr_value_('DegreesMeasure', node)
        if value is not None and 'DegreesMeasure' not in already_processed:
            already_processed.append('DegreesMeasure')
            self.DegreesMeasure = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LatitudeType


class LongitudeType(GeneratedsSuper):
    """Measure of the longitude in degreesMeasure of the longitude in
    minutesMeasure of the longitude in secondsThe direction of
    longitude measurement offset from the equator"""
    subclass = None
    superclass = None
    def __init__(self, Direction=None, MinutesMeasure=None, SecondsMeasure=None, DegreesMeasure=None):
        self.Direction = _cast(None, Direction)
        self.MinutesMeasure = _cast(None, MinutesMeasure)
        self.SecondsMeasure = _cast(None, SecondsMeasure)
        self.DegreesMeasure = _cast(None, DegreesMeasure)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LongitudeType.subclass:
            return LongitudeType.subclass(*args_, **kwargs_)
        else:
            return LongitudeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    def validate_DirectionTypeList(self, value):
        # Validate type DirectionTypeList, a restriction on xs:normalizedString.
        pass
    def get_MinutesMeasure(self): return self.MinutesMeasure
    def set_MinutesMeasure(self, MinutesMeasure): self.MinutesMeasure = MinutesMeasure
    def get_SecondsMeasure(self): return self.SecondsMeasure
    def set_SecondsMeasure(self, SecondsMeasure): self.SecondsMeasure = SecondsMeasure
    def get_DegreesMeasure(self): return self.DegreesMeasure
    def set_DegreesMeasure(self, DegreesMeasure): self.DegreesMeasure = DegreesMeasure
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LongitudeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LongitudeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LongitudeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Direction is not None and 'Direction' not in already_processed:
            already_processed.append('Direction')
            outfile.write(' Direction=%s' % (quote_attrib(self.Direction), ))
        if self.MinutesMeasure is not None and 'MinutesMeasure' not in already_processed:
            already_processed.append('MinutesMeasure')
            outfile.write(' MinutesMeasure=%s' % (quote_attrib(self.MinutesMeasure), ))
        if self.SecondsMeasure is not None and 'SecondsMeasure' not in already_processed:
            already_processed.append('SecondsMeasure')
            outfile.write(' SecondsMeasure=%s' % (quote_attrib(self.SecondsMeasure), ))
        if self.DegreesMeasure is not None and 'DegreesMeasure' not in already_processed:
            already_processed.append('DegreesMeasure')
            outfile.write(' DegreesMeasure=%s' % (quote_attrib(self.DegreesMeasure), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LongitudeType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LongitudeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Direction is not None and 'Direction' not in already_processed:
            already_processed.append('Direction')
            showIndent(outfile, level)
            outfile.write('Direction = "%s",\n' % (self.Direction,))
        if self.MinutesMeasure is not None and 'MinutesMeasure' not in already_processed:
            already_processed.append('MinutesMeasure')
            showIndent(outfile, level)
            outfile.write('MinutesMeasure = %s,\n' % (self.MinutesMeasure,))
        if self.SecondsMeasure is not None and 'SecondsMeasure' not in already_processed:
            already_processed.append('SecondsMeasure')
            showIndent(outfile, level)
            outfile.write('SecondsMeasure = %s,\n' % (self.SecondsMeasure,))
        if self.DegreesMeasure is not None and 'DegreesMeasure' not in already_processed:
            already_processed.append('DegreesMeasure')
            showIndent(outfile, level)
            outfile.write('DegreesMeasure = %s,\n' % (self.DegreesMeasure,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Direction', node)
        if value is not None and 'Direction' not in already_processed:
            already_processed.append('Direction')
            self.Direction = value
            self.validate_DirectionTypeList(self.Direction)    # validate type DirectionTypeList
        value = find_attr_value_('MinutesMeasure', node)
        if value is not None and 'MinutesMeasure' not in already_processed:
            already_processed.append('MinutesMeasure')
            self.MinutesMeasure = value
        value = find_attr_value_('SecondsMeasure', node)
        if value is not None and 'SecondsMeasure' not in already_processed:
            already_processed.append('SecondsMeasure')
            self.SecondsMeasure = value
        value = find_attr_value_('DegreesMeasure', node)
        if value is not None and 'DegreesMeasure' not in already_processed:
            already_processed.append('DegreesMeasure')
            self.DegreesMeasure = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LongitudeType


class NameElementType6(GeneratedsSuper):
    """Semantics of data associated with name. Name of the country
    represented as a codeType of code used to represent name of
    country, e.g. iso-3166"""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, NameCodeType=None, NameCode=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.NameCodeType = _cast(None, NameCodeType)
        self.NameCode = _cast(None, NameCode)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType6.subclass:
            return NameElementType6.subclass(*args_, **kwargs_)
        else:
            return NameElementType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_CountryNameTypeList(self, value):
        # Validate type CountryNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_NameCodeType(self): return self.NameCodeType
    def set_NameCodeType(self, NameCodeType): self.NameCodeType = NameCodeType
    def get_NameCode(self): return self.NameCode
    def set_NameCode(self, NameCode): self.NameCode = NameCode
    def validate_CountryNameCodeList(self, value):
        # Validate type CountryNameCodeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType6')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType6'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            outfile.write(' NameCodeType=%s' % (quote_attrib(self.NameCodeType), ))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            outfile.write(' NameCode=%s' % (quote_attrib(self.NameCode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType6', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType6'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        if self.NameCodeType is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            showIndent(outfile, level)
            outfile.write('NameCodeType = %s,\n' % (self.NameCodeType,))
        if self.NameCode is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            showIndent(outfile, level)
            outfile.write('NameCode = "%s",\n' % (self.NameCode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_CountryNameTypeList(self.NameType)    # validate type CountryNameTypeList
        value = find_attr_value_('NameCodeType', node)
        if value is not None and 'NameCodeType' not in already_processed:
            already_processed.append('NameCodeType')
            self.NameCodeType = value
        value = find_attr_value_('NameCode', node)
        if value is not None and 'NameCode' not in already_processed:
            already_processed.append('NameCode')
            self.NameCode = value
            self.validate_CountryNameCodeList(self.NameCode)    # validate type CountryNameCodeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType6


class NameElementType7(GeneratedsSuper):
    """Describes the type / part of name this element contains."""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType7.subclass:
            return NameElementType7.subclass(*args_, **kwargs_)
        else:
            return NameElementType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_PremisesElementTypeList(self, value):
        # Validate type PremisesElementTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType7')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType7'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType7', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType7'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_PremisesElementTypeList(self.NameType)    # validate type PremisesElementTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType7


class NameElementType8(GeneratedsSuper):
    """Describes the type / part of name this element contains."""
    subclass = None
    superclass = None
    def __init__(self, Abbreviation=None, NameType=None, valueOf_=None):
        self.Abbreviation = _cast(bool, Abbreviation)
        self.NameType = _cast(None, NameType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NameElementType8.subclass:
            return NameElementType8.subclass(*args_, **kwargs_)
        else:
            return NameElementType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Abbreviation(self): return self.Abbreviation
    def set_Abbreviation(self, Abbreviation): self.Abbreviation = Abbreviation
    def get_NameType(self): return self.NameType
    def set_NameType(self, NameType): self.NameType = NameType
    def validate_ThoroughfareNameTypeList(self, value):
        # Validate type ThoroughfareNameTypeList, a restriction on xs:normalizedString.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NameElementType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameElementType8')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameElementType8'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            outfile.write(' Abbreviation="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Abbreviation)), input_name='Abbreviation'))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            outfile.write(' NameType=%s' % (quote_attrib(self.NameType), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NameElementType8', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NameElementType8'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Abbreviation is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            showIndent(outfile, level)
            outfile.write('Abbreviation = %s,\n' % (self.Abbreviation,))
        if self.NameType is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            showIndent(outfile, level)
            outfile.write('NameType = "%s",\n' % (self.NameType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Abbreviation', node)
        if value is not None and 'Abbreviation' not in already_processed:
            already_processed.append('Abbreviation')
            if value in ('true', '1'):
                self.Abbreviation = True
            elif value in ('false', '0'):
                self.Abbreviation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('NameType', node)
        if value is not None and 'NameType' not in already_processed:
            already_processed.append('NameType')
            self.NameType = value
            self.validate_ThoroughfareNameTypeList(self.NameType)    # validate type ThoroughfareNameTypeList
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameElementType8


class PersonDetails(PersonDetailsType):
    """A container for defining the unique characteristics of a person only"""
    subclass = None
    superclass = PersonDetailsType
    def __init__(self, Status=None, LanguageCode=None, PersonDetailsKeyRef=None, ValidTo=None, DateValidFrom=None, DateValidTo=None, PersonDetailsKey=None, Usage=None, DataQualityType=None, ValidFrom=None, FreeTextLines=None, PersonName=None, Addresses=None, Accounts=None, ContactNumbers=None, Documents=None, ElectronicAddressIdentifiers=None, Events=None, Identifiers=None, Memberships=None, Relationships=None, Revenues=None, Stocks=None, Vehicles=None, PersonInfo=None, BirthInfo=None, CountriesOfResidence=None, Favourites=None, Habits=None, Hobbies=None, Languages=None, Nationalities=None, Occupations=None, PhysicalInfo=None, Preferences=None, Qualifications=None, Visas=None):
        super(PersonDetails, self).__init__(Status, LanguageCode, PersonDetailsKeyRef, ValidTo, DateValidFrom, DateValidTo, PersonDetailsKey, Usage, DataQualityType, ValidFrom, FreeTextLines, PersonName, Addresses, Accounts, ContactNumbers, Documents, ElectronicAddressIdentifiers, Events, Identifiers, Memberships, Relationships, Revenues, Stocks, Vehicles, PersonInfo, BirthInfo, CountriesOfResidence, Favourites, Habits, Hobbies, Languages, Nationalities, Occupations, PhysicalInfo, Preferences, Qualifications, Visas, )
        pass
    def factory(*args_, **kwargs_):
        if PersonDetails.subclass:
            return PersonDetails.subclass(*args_, **kwargs_)
        else:
            return PersonDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PersonDetails', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PersonDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonDetails'):
        super(PersonDetails, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PersonDetails')
    def exportChildren(self, outfile, level, namespace_='', name_='PersonDetails', fromsubclass_=False, pretty_print=True):
        super(PersonDetails, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(PersonDetails, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PersonDetails, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PersonDetails, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PersonDetails, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PersonDetails, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PersonDetails


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Party'
        rootClass = PartyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Party'
        rootClass = PartyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Party",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Party'
        rootClass = PartyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from ciq import *\n\n')
    sys.stdout.write('import ciq as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccountElementType",
    "AccountType",
    "Accounts",
    "AddressLineType",
    "AddressType",
    "AddressType1",
    "Addresses",
    "AdministrativeAreaType",
    "AllergyType",
    "BirthInfo",
    "BirthInfoElementType",
    "BodyMarkType",
    "ContactNumberElementType",
    "ContactNumberType",
    "ContactNumbers",
    "CountriesOfResidence",
    "CountryType",
    "CountryType1",
    "CountryType2",
    "CountryType3",
    "DisabilityType",
    "DocumentElementType",
    "DocumentType",
    "Documents",
    "ElectronicAddressIdentifierType",
    "ElectronicAddressIdentifiers",
    "EmployerType",
    "EventType",
    "Events",
    "FavouriteType",
    "Favourites",
    "FeatureType",
    "FreeTextAddressType",
    "FreeTextLineType",
    "FreeTextLineType1",
    "FreeTextLines",
    "GeoRSSType",
    "HabitType",
    "Habits",
    "HealthConditionType",
    "Hobbies",
    "HobbyType",
    "IdentifierElementType",
    "IdentifierType",
    "IdentifierType1",
    "Identifiers",
    "InstitutionType",
    "IssuerNameType",
    "LanguageType",
    "Languages",
    "LatitudeType",
    "LocalityType",
    "LocationByCoordinatesType",
    "LongitudeType",
    "MembershipElementType",
    "MembershipType",
    "Memberships",
    "NameElementType",
    "NameElementType1",
    "NameElementType2",
    "NameElementType3",
    "NameElementType4",
    "NameElementType5",
    "NameElementType6",
    "NameElementType7",
    "NameElementType8",
    "NameLine",
    "Nationalities",
    "OccupationElementType",
    "OccupationType",
    "Occupations",
    "OrganisationDetailsType",
    "OrganisationInfo",
    "OrganisationNameType",
    "OrganisationNameType1",
    "OrganisationType",
    "OrganisationType1",
    "PartyNameType",
    "PartyType",
    "PersonDetails",
    "PersonDetailsType",
    "PersonInfo",
    "PersonNameType",
    "PersonNameType1",
    "PhysicalInfo",
    "PostCodeType",
    "PostOfficeType",
    "PostalDeliveryPointType",
    "PreferenceType",
    "Preferences",
    "PremisesType",
    "PremisesType1",
    "QualificationElementType",
    "QualificationType",
    "Qualifications",
    "RelationshipType",
    "Relationships",
    "RevenueType",
    "Revenues",
    "RuralDeliveryType",
    "StockType",
    "Stocks",
    "SubAdministrativeAreaType",
    "SubDivisionNameType",
    "SubLocalityType",
    "SubPremisesType",
    "SubThoroughfareType",
    "ThoroughfareType",
    "ThoroughfareType1",
    "VehicleElementType",
    "VehicleType",
    "Vehicles",
    "VisaElementType",
    "VisaType",
    "Visas"
    ]
