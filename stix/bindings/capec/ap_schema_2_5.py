#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Dec 05 14:55:33 2012 by generateDS.py version 2.7c.
#

import sys
import getopt
import re as re_
import cybox.bindings.cybox_core_1_0 as cybox_core_binding

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Attack_Pattern_Catalog(GeneratedsSuper):
    """This is the enumerated catalog of common attack patterns."""
    subclass = None
    superclass = None
    def __init__(self, Catalog_Date=None, Catalog_Version=None, Catalog_Name=None, Views=None, Categories=None, Attack_Patterns=None, Compound_Elements=None, Common_Attack_Steps=None, Common_Attack_Surfaces=None, Environments=None):
        self.Catalog_Date = _cast(None, Catalog_Date)
        self.Catalog_Version = _cast(None, Catalog_Version)
        self.Catalog_Name = _cast(None, Catalog_Name)
        self.Views = Views
        self.Categories = Categories
        self.Attack_Patterns = Attack_Patterns
        self.Compound_Elements = Compound_Elements
        self.Common_Attack_Steps = Common_Attack_Steps
        self.Common_Attack_Surfaces = Common_Attack_Surfaces
        self.Environments = Environments
    def factory(*args_, **kwargs_):
        if Attack_Pattern_Catalog.subclass:
            return Attack_Pattern_Catalog.subclass(*args_, **kwargs_)
        else:
            return Attack_Pattern_Catalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Views(self): return self.Views
    def set_Views(self, Views): self.Views = Views
    def get_Categories(self): return self.Categories
    def set_Categories(self, Categories): self.Categories = Categories
    def get_Attack_Patterns(self): return self.Attack_Patterns
    def set_Attack_Patterns(self, Attack_Patterns): self.Attack_Patterns = Attack_Patterns
    def get_Compound_Elements(self): return self.Compound_Elements
    def set_Compound_Elements(self, Compound_Elements): self.Compound_Elements = Compound_Elements
    def get_Common_Attack_Steps(self): return self.Common_Attack_Steps
    def set_Common_Attack_Steps(self, Common_Attack_Steps): self.Common_Attack_Steps = Common_Attack_Steps
    def get_Common_Attack_Surfaces(self): return self.Common_Attack_Surfaces
    def set_Common_Attack_Surfaces(self, Common_Attack_Surfaces): self.Common_Attack_Surfaces = Common_Attack_Surfaces
    def get_Environments(self): return self.Environments
    def set_Environments(self, Environments): self.Environments = Environments
    def get_Catalog_Date(self): return self.Catalog_Date
    def set_Catalog_Date(self, Catalog_Date): self.Catalog_Date = Catalog_Date
    def get_Catalog_Version(self): return self.Catalog_Version
    def set_Catalog_Version(self, Catalog_Version): self.Catalog_Version = Catalog_Version
    def get_Catalog_Name(self): return self.Catalog_Name
    def set_Catalog_Name(self, Catalog_Name): self.Catalog_Name = Catalog_Name
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Pattern_Catalog', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Pattern_Catalog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Pattern_Catalog'):
        if self.Catalog_Date is not None and 'Catalog_Date' not in already_processed:
            already_processed.append('Catalog_Date')
            outfile.write(' Catalog_Date=%s' % (self.gds_format_string(quote_attrib(self.Catalog_Date).encode(ExternalEncoding), input_name='Catalog_Date'), ))
        if self.Catalog_Version is not None and 'Catalog_Version' not in already_processed:
            already_processed.append('Catalog_Version')
            outfile.write(' Catalog_Version=%s' % (self.gds_format_string(quote_attrib(self.Catalog_Version).encode(ExternalEncoding), input_name='Catalog_Version'), ))
        if self.Catalog_Name is not None and 'Catalog_Name' not in already_processed:
            already_processed.append('Catalog_Name')
            outfile.write(' Catalog_Name=%s' % (self.gds_format_string(quote_attrib(self.Catalog_Name).encode(ExternalEncoding), input_name='Catalog_Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Pattern_Catalog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Views is not None:
            self.Views.export(outfile, level, namespace_, name_='Views', pretty_print=pretty_print)
        if self.Categories is not None:
            self.Categories.export(outfile, level, namespace_, name_='Categories', pretty_print=pretty_print)
        if self.Attack_Patterns is not None:
            self.Attack_Patterns.export(outfile, level, namespace_, name_='Attack_Patterns', pretty_print=pretty_print)
        if self.Compound_Elements is not None:
            self.Compound_Elements.export(outfile, level, namespace_, name_='Compound_Elements', pretty_print=pretty_print)
        if self.Common_Attack_Steps is not None:
            self.Common_Attack_Steps.export(outfile, level, namespace_, name_='Common_Attack_Steps', pretty_print=pretty_print)
        if self.Common_Attack_Surfaces is not None:
            self.Common_Attack_Surfaces.export(outfile, level, namespace_, name_='Common_Attack_Surfaces', pretty_print=pretty_print)
        if self.Environments is not None:
            self.Environments.export(outfile, level, namespace_, name_='Environments', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Views is not None or
            self.Categories is not None or
            self.Attack_Patterns is not None or
            self.Compound_Elements is not None or
            self.Common_Attack_Steps is not None or
            self.Common_Attack_Surfaces is not None or
            self.Environments is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Pattern_Catalog'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Catalog_Date is not None and 'Catalog_Date' not in already_processed:
            already_processed.append('Catalog_Date')
            showIndent(outfile, level)
            outfile.write('Catalog_Date = "%s",\n' % (self.Catalog_Date,))
        if self.Catalog_Version is not None and 'Catalog_Version' not in already_processed:
            already_processed.append('Catalog_Version')
            showIndent(outfile, level)
            outfile.write('Catalog_Version = "%s",\n' % (self.Catalog_Version,))
        if self.Catalog_Name is not None and 'Catalog_Name' not in already_processed:
            already_processed.append('Catalog_Name')
            showIndent(outfile, level)
            outfile.write('Catalog_Name = "%s",\n' % (self.Catalog_Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Views is not None:
            showIndent(outfile, level)
            outfile.write('Views=model_.Views(\n')
            self.Views.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Categories is not None:
            showIndent(outfile, level)
            outfile.write('Categories=model_.Categories(\n')
            self.Categories.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Patterns=model_.Attack_Patterns(\n')
            self.Attack_Patterns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Compound_Elements is not None:
            showIndent(outfile, level)
            outfile.write('Compound_Elements=model_.Compound_Elements(\n')
            self.Compound_Elements.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Common_Attack_Steps is not None:
            showIndent(outfile, level)
            outfile.write('Common_Attack_Steps=model_.Common_Attack_Steps(\n')
            self.Common_Attack_Steps.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Common_Attack_Surfaces is not None:
            showIndent(outfile, level)
            outfile.write('Common_Attack_Surfaces=model_.Common_Attack_Surfaces(\n')
            self.Common_Attack_Surfaces.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Environments is not None:
            showIndent(outfile, level)
            outfile.write('Environments=model_.Environments(\n')
            self.Environments.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Catalog_Date', node)
        if value is not None and 'Catalog_Date' not in already_processed:
            already_processed.append('Catalog_Date')
            self.Catalog_Date = value
        value = find_attr_value_('Catalog_Version', node)
        if value is not None and 'Catalog_Version' not in already_processed:
            already_processed.append('Catalog_Version')
            self.Catalog_Version = value
        value = find_attr_value_('Catalog_Name', node)
        if value is not None and 'Catalog_Name' not in already_processed:
            already_processed.append('Catalog_Name')
            self.Catalog_Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Views':
            obj_ = Views.factory()
            obj_.build(child_)
            self.set_Views(obj_)
        elif nodeName_ == 'Categories':
            obj_ = Categories.factory()
            obj_.build(child_)
            self.set_Categories(obj_)
        elif nodeName_ == 'Attack_Patterns':
            obj_ = Attack_Patterns.factory()
            obj_.build(child_)
            self.set_Attack_Patterns(obj_)
        elif nodeName_ == 'Compound_Elements':
            obj_ = Compound_Elements.factory()
            obj_.build(child_)
            self.set_Compound_Elements(obj_)
        elif nodeName_ == 'Common_Attack_Steps':
            obj_ = Common_Attack_Steps.factory()
            obj_.build(child_)
            self.set_Common_Attack_Steps(obj_)
        elif nodeName_ == 'Common_Attack_Surfaces':
            obj_ = Common_Attack_Surfaces.factory()
            obj_.build(child_)
            self.set_Common_Attack_Surfaces(obj_)
        elif nodeName_ == 'Environments':
            obj_ = Environments.factory()
            obj_.build(child_)
            self.set_Environments(obj_)
# end class Attack_Pattern_Catalog


class Views(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, View=None):
        if View is None:
            self.View = []
        else:
            self.View = View
    def factory(*args_, **kwargs_):
        if Views.subclass:
            return Views.subclass(*args_, **kwargs_)
        else:
            return Views(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_View(self): return self.View
    def set_View(self, View): self.View = View
    def add_View(self, value): self.View.append(value)
    def insert_View(self, index, value): self.View[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Views', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Views')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Views'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Views', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for View_ in self.View:
            View_.export(outfile, level, namespace_, name_='View', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.View
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Views'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('View=[\n')
        level += 1
        for View_ in self.View:
            showIndent(outfile, level)
            outfile.write('model_.View(\n')
            View_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'View':
            obj_ = View.factory()
            obj_.build(child_)
            self.View.append(obj_)
# end class Views


class Categories(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Category=None):
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
    def factory(*args_, **kwargs_):
        if Categories.subclass:
            return Categories.subclass(*args_, **kwargs_)
        else:
            return Categories(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category(self, index, value): self.Category[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Categories', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Categories')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Categories'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Categories', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Category
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Categories'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.Category(\n')
            Category_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Category':
            obj_ = Category.factory()
            obj_.build(child_)
            self.Category.append(obj_)
# end class Categories


class Attack_Patterns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Pattern=None):
        if Attack_Pattern is None:
            self.Attack_Pattern = []
        else:
            self.Attack_Pattern = Attack_Pattern
    def factory(*args_, **kwargs_):
        if Attack_Patterns.subclass:
            return Attack_Patterns.subclass(*args_, **kwargs_)
        else:
            return Attack_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Pattern(self): return self.Attack_Pattern
    def set_Attack_Pattern(self, Attack_Pattern): self.Attack_Pattern = Attack_Pattern
    def add_Attack_Pattern(self, value): self.Attack_Pattern.append(value)
    def insert_Attack_Pattern(self, index, value): self.Attack_Pattern[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attack_Pattern_ in self.Attack_Pattern:
            Attack_Pattern_.export(outfile, level, namespace_, name_='Attack_Pattern', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Pattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attack_Pattern=[\n')
        level += 1
        for Attack_Pattern_ in self.Attack_Pattern:
            showIndent(outfile, level)
            outfile.write('model_.Attack_Pattern(\n')
            Attack_Pattern_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Pattern':
            obj_ = Attack_PatternType.factory()
            obj_.build(child_)
            self.Attack_Pattern.append(obj_)
# end class Attack_Patterns


class Compound_Elements(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Compound_Element=None):
        self.Compound_Element = Compound_Element
    def factory(*args_, **kwargs_):
        if Compound_Elements.subclass:
            return Compound_Elements.subclass(*args_, **kwargs_)
        else:
            return Compound_Elements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Compound_Element(self): return self.Compound_Element
    def set_Compound_Element(self, Compound_Element): self.Compound_Element = Compound_Element
    def export(self, outfile, level, namespace_='capec:', name_='Compound_Elements', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Compound_Elements')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Compound_Elements'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Compound_Elements', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Compound_Element is not None:
            self.Compound_Element.export(outfile, level, namespace_, name_='Compound_Element', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Compound_Element is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Compound_Elements'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Compound_Element is not None:
            showIndent(outfile, level)
            outfile.write('Compound_Element=model_.Compound_Element(\n')
            self.Compound_Element.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Compound_Element':
            obj_ = Compound_Element.factory()
            obj_.build(child_)
            self.set_Compound_Element(obj_)
# end class Compound_Elements


class Common_Attack_Steps(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Common_Attack_Step=None):
        if Common_Attack_Step is None:
            self.Common_Attack_Step = []
        else:
            self.Common_Attack_Step = Common_Attack_Step
    def factory(*args_, **kwargs_):
        if Common_Attack_Steps.subclass:
            return Common_Attack_Steps.subclass(*args_, **kwargs_)
        else:
            return Common_Attack_Steps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Common_Attack_Step(self): return self.Common_Attack_Step
    def set_Common_Attack_Step(self, Common_Attack_Step): self.Common_Attack_Step = Common_Attack_Step
    def add_Common_Attack_Step(self, value): self.Common_Attack_Step.append(value)
    def insert_Common_Attack_Step(self, index, value): self.Common_Attack_Step[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Common_Attack_Steps', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_Attack_Steps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_Attack_Steps'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_Attack_Steps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Common_Attack_Step_ in self.Common_Attack_Step:
            Common_Attack_Step_.export(outfile, level, namespace_, name_='Common_Attack_Step', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Common_Attack_Step
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Common_Attack_Steps'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Common_Attack_Step=[\n')
        level += 1
        for Common_Attack_Step_ in self.Common_Attack_Step:
            showIndent(outfile, level)
            outfile.write('model_.Common_Attack_Step(\n')
            Common_Attack_Step_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Common_Attack_Step':
            obj_ = Common_Attack_Step.factory()
            obj_.build(child_)
            self.Common_Attack_Step.append(obj_)
# end class Common_Attack_Steps


class Common_Attack_Surfaces(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Common_Attack_Surface=None):
        if Common_Attack_Surface is None:
            self.Common_Attack_Surface = []
        else:
            self.Common_Attack_Surface = Common_Attack_Surface
    def factory(*args_, **kwargs_):
        if Common_Attack_Surfaces.subclass:
            return Common_Attack_Surfaces.subclass(*args_, **kwargs_)
        else:
            return Common_Attack_Surfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Common_Attack_Surface(self): return self.Common_Attack_Surface
    def set_Common_Attack_Surface(self, Common_Attack_Surface): self.Common_Attack_Surface = Common_Attack_Surface
    def add_Common_Attack_Surface(self, value): self.Common_Attack_Surface.append(value)
    def insert_Common_Attack_Surface(self, index, value): self.Common_Attack_Surface[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Common_Attack_Surfaces', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_Attack_Surfaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_Attack_Surfaces'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_Attack_Surfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Common_Attack_Surface_ in self.Common_Attack_Surface:
            Common_Attack_Surface_.export(outfile, level, namespace_, name_='Common_Attack_Surface', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Common_Attack_Surface
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Common_Attack_Surfaces'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Common_Attack_Surface=[\n')
        level += 1
        for Common_Attack_Surface_ in self.Common_Attack_Surface:
            showIndent(outfile, level)
            outfile.write('model_.Common_Attack_Surface(\n')
            Common_Attack_Surface_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Common_Attack_Surface':
            obj_ = Common_Attack_Surface.factory()
            obj_.build(child_)
            self.Common_Attack_Surface.append(obj_)
# end class Common_Attack_Surfaces


class Environments(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Environment=None):
        if Environment is None:
            self.Environment = []
        else:
            self.Environment = Environment
    def factory(*args_, **kwargs_):
        if Environments.subclass:
            return Environments.subclass(*args_, **kwargs_)
        else:
            return Environments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Environment(self): return self.Environment
    def set_Environment(self, Environment): self.Environment = Environment
    def add_Environment(self, value): self.Environment.append(value)
    def insert_Environment(self, index, value): self.Environment[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Environments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Environments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Environments'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Environments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Environment_ in self.Environment:
            Environment_.export(outfile, level, namespace_, name_='Environment', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Environment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Environments'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Environment=[\n')
        level += 1
        for Environment_ in self.Environment:
            showIndent(outfile, level)
            outfile.write('model_.Environment(\n')
            Environment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Environment':
            obj_ = Environment.factory()
            obj_.build(child_)
            self.Environment.append(obj_)
# end class Environments


class View(GeneratedsSuper):
    """Each View element represents a perspective with which one might look
    at the attack patterns in CAPEC. The ID attribute provides a
    unique identifier for the entry. It will be static for the
    lifetime of the entry. In the event that this entry becomes
    deprecated, the ID will not be reused and a pointer will be left
    in this entry to the replacement. This is required for all
    Views. The Name is a descriptive attribute used to give the
    reader an idea of what perspective this view represents. All
    words in the name should be capitalized except for articles and
    prepositions unless they begin or end the name. Subsequent words
    in a hyphenated chain are also not capitalized. This is required
    for all Views. The Status attribute defines the status level for
    this view."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ID=None, Name=None, View_Attributes=None):
        self.Status = _cast(None, Status)
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        self.View_Attributes = View_Attributes
    def factory(*args_, **kwargs_):
        if View.subclass:
            return View.subclass(*args_, **kwargs_)
        else:
            return View(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_View_Attributes(self): return self.View_Attributes
    def set_View_Attributes(self, View_Attributes): self.View_Attributes = View_Attributes
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='View', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='View')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='View'):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='View', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.View_Attributes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sView_Attributes>%s</%sView_Attributes>%s' % (namespace_, self.gds_format_string(quote_xml(self.View_Attributes).encode(ExternalEncoding), input_name='View_Attributes'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.View_Attributes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='View'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.View_Attributes is not None:
            showIndent(outfile, level)
            outfile.write('View_Attributes=%s,\n' % quote_python(self.View_Attributes).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'View_Attributes':
            View_Attributes_ = child_.text
            View_Attributes_ = self.gds_validate_string(View_Attributes_, node, 'View_Attributes')
            self.View_Attributes = View_Attributes_
# end class View


class Category(GeneratedsSuper):
    """This attribute provides a unique identifier for the entry. It will
    be static for the lifetime of the entry. In the event that this
    entry becomes deprecated, the ID will not be reused and a
    pointer will be left in this entry to the replacement. This is
    required for all Categories. The Name is a descriptive name used
    to give the reader an idea of what the commonality is amongst
    the children of this category. All words in the name should be
    capitalized except for articles and prepositions unless they
    begin or end the name. Subsequent words in a hyphenated chain
    are also not capitalized. This is required for all Categories.
    The Status attribute defines the status level for this category."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, ID=None, Name=None, Description=None, Related_Weaknesses=None, Attack_Prerequisites=None, Methods_of_Attack=None, Attacker_Skills_or_Knowledge_Required=None, Resources_Required=None, Attack_Motivation_Consequences=None, Relationships=None, Relationship_Notes=None, Maintenance_Notes=None, Background_Details=None, Other_Notes=None, Alternate_Terms=None, Research_Gaps=None, References=None, Content_History=None):
        self.Status = _cast(None, Status)
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        self.Description = Description
        self.Related_Weaknesses = Related_Weaknesses
        self.Attack_Prerequisites = Attack_Prerequisites
        self.Methods_of_Attack = Methods_of_Attack
        self.Attacker_Skills_or_Knowledge_Required = Attacker_Skills_or_Knowledge_Required
        self.Resources_Required = Resources_Required
        self.Attack_Motivation_Consequences = Attack_Motivation_Consequences
        self.Relationships = Relationships
        self.Relationship_Notes = Relationship_Notes
        self.Maintenance_Notes = Maintenance_Notes
        self.Background_Details = Background_Details
        self.Other_Notes = Other_Notes
        self.Alternate_Terms = Alternate_Terms
        self.Research_Gaps = Research_Gaps
        self.References = References
        self.Content_History = Content_History
    def factory(*args_, **kwargs_):
        if Category.subclass:
            return Category.subclass(*args_, **kwargs_)
        else:
            return Category(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Related_Weaknesses(self): return self.Related_Weaknesses
    def set_Related_Weaknesses(self, Related_Weaknesses): self.Related_Weaknesses = Related_Weaknesses
    def get_Attack_Prerequisites(self): return self.Attack_Prerequisites
    def set_Attack_Prerequisites(self, Attack_Prerequisites): self.Attack_Prerequisites = Attack_Prerequisites
    def get_Methods_of_Attack(self): return self.Methods_of_Attack
    def set_Methods_of_Attack(self, Methods_of_Attack): self.Methods_of_Attack = Methods_of_Attack
    def get_Attacker_Skills_or_Knowledge_Required(self): return self.Attacker_Skills_or_Knowledge_Required
    def set_Attacker_Skills_or_Knowledge_Required(self, Attacker_Skills_or_Knowledge_Required): self.Attacker_Skills_or_Knowledge_Required = Attacker_Skills_or_Knowledge_Required
    def get_Resources_Required(self): return self.Resources_Required
    def set_Resources_Required(self, Resources_Required): self.Resources_Required = Resources_Required
    def get_Attack_Motivation_Consequences(self): return self.Attack_Motivation_Consequences
    def set_Attack_Motivation_Consequences(self, Attack_Motivation_Consequences): self.Attack_Motivation_Consequences = Attack_Motivation_Consequences
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_Relationship_Notes(self): return self.Relationship_Notes
    def set_Relationship_Notes(self, Relationship_Notes): self.Relationship_Notes = Relationship_Notes
    def get_Maintenance_Notes(self): return self.Maintenance_Notes
    def set_Maintenance_Notes(self, Maintenance_Notes): self.Maintenance_Notes = Maintenance_Notes
    def get_Background_Details(self): return self.Background_Details
    def set_Background_Details(self, Background_Details): self.Background_Details = Background_Details
    def get_Other_Notes(self): return self.Other_Notes
    def set_Other_Notes(self, Other_Notes): self.Other_Notes = Other_Notes
    def get_Alternate_Terms(self): return self.Alternate_Terms
    def set_Alternate_Terms(self, Alternate_Terms): self.Alternate_Terms = Alternate_Terms
    def get_Research_Gaps(self): return self.Research_Gaps
    def set_Research_Gaps(self, Research_Gaps): self.Research_Gaps = Research_Gaps
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Content_History(self): return self.Content_History
    def set_Content_History(self, Content_History): self.Content_History = Content_History
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Category', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Category')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Category'):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Category', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Related_Weaknesses is not None:
            self.Related_Weaknesses.export(outfile, level, namespace_, name_='Related_Weaknesses', pretty_print=pretty_print)
        if self.Attack_Prerequisites is not None:
            self.Attack_Prerequisites.export(outfile, level, namespace_, name_='Attack_Prerequisites', pretty_print=pretty_print)
        if self.Methods_of_Attack is not None:
            self.Methods_of_Attack.export(outfile, level, namespace_, name_='Methods_of_Attack', pretty_print=pretty_print)
        if self.Attacker_Skills_or_Knowledge_Required is not None:
            self.Attacker_Skills_or_Knowledge_Required.export(outfile, level, namespace_, name_='Attacker_Skills_or_Knowledge_Required', pretty_print=pretty_print)
        if self.Resources_Required is not None:
            self.Resources_Required.export(outfile, level, namespace_, name_='Resources_Required', pretty_print=pretty_print)
        if self.Attack_Motivation_Consequences is not None:
            self.Attack_Motivation_Consequences.export(outfile, level, namespace_, name_='Attack_Motivation-Consequences', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
        if self.Relationship_Notes is not None:
            self.Relationship_Notes.export(outfile, level, namespace_, name_='Relationship_Notes', pretty_print=pretty_print)
        if self.Maintenance_Notes is not None:
            self.Maintenance_Notes.export(outfile, level, namespace_, name_='Maintenance_Notes', pretty_print=pretty_print)
        if self.Background_Details is not None:
            self.Background_Details.export(outfile, level, namespace_, name_='Background_Details', pretty_print=pretty_print)
        if self.Other_Notes is not None:
            self.Other_Notes.export(outfile, level, namespace_, name_='Other_Notes', pretty_print=pretty_print)
        if self.Alternate_Terms is not None:
            self.Alternate_Terms.export(outfile, level, namespace_, name_='Alternate_Terms', pretty_print=pretty_print)
        if self.Research_Gaps is not None:
            self.Research_Gaps.export(outfile, level, namespace_, name_='Research_Gaps', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        if self.Content_History is not None:
            self.Content_History.export(outfile, level, namespace_, name_='Content_History', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Related_Weaknesses is not None or
            self.Attack_Prerequisites is not None or
            self.Methods_of_Attack is not None or
            self.Attacker_Skills_or_Knowledge_Required is not None or
            self.Resources_Required is not None or
            self.Attack_Motivation_Consequences is not None or
            self.Relationships is not None or
            self.Relationship_Notes is not None or
            self.Maintenance_Notes is not None or
            self.Background_Details is not None or
            self.Other_Notes is not None or
            self.Alternate_Terms is not None or
            self.Research_Gaps is not None or
            self.References is not None or
            self.Content_History is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Category'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Weaknesses is not None:
            showIndent(outfile, level)
            outfile.write('Related_Weaknesses=model_.Related_Weaknesses(\n')
            self.Related_Weaknesses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Prerequisites is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Prerequisites=model_.Attack_Prerequisites(\n')
            self.Attack_Prerequisites.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Methods_of_Attack is not None:
            showIndent(outfile, level)
            outfile.write('Methods_of_Attack=model_.Methods_of_Attack(\n')
            self.Methods_of_Attack.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attacker_Skills_or_Knowledge_Required is not None:
            showIndent(outfile, level)
            outfile.write('Attacker_Skills_or_Knowledge_Required=model_.Attacker_Skills_or_Knowledge_Required(\n')
            self.Attacker_Skills_or_Knowledge_Required.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Resources_Required is not None:
            showIndent(outfile, level)
            outfile.write('Resources_Required=model_.Structured_Text_Type(\n')
            self.Resources_Required.exportLiteral(outfile, level, name_='Resources_Required')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Motivation_Consequences is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Motivation_Consequences=model_.Attack_Motivation_Consequences(\n')
            self.Attack_Motivation_Consequences.exportLiteral(outfile, level, name_='Attack_Motivation_Consequences')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.Relationships(\n')
            self.Relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationship_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Notes=model_.Relationship_Notes(\n')
            self.Relationship_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Maintenance_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Maintenance_Notes=model_.Maintenance_Notes(\n')
            self.Maintenance_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Background_Details is not None:
            showIndent(outfile, level)
            outfile.write('Background_Details=model_.Background_Details(\n')
            self.Background_Details.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Other_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Other_Notes=model_.Other_Notes(\n')
            self.Other_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Alternate_Terms is not None:
            showIndent(outfile, level)
            outfile.write('Alternate_Terms=model_.Alternate_Terms(\n')
            self.Alternate_Terms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Research_Gaps is not None:
            showIndent(outfile, level)
            outfile.write('Research_Gaps=model_.Research_Gaps(\n')
            self.Research_Gaps.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.Reference_List_Type(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_History is not None:
            showIndent(outfile, level)
            outfile.write('Content_History=model_.Content_History(\n')
            self.Content_History.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Description.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Related_Weaknesses':
            obj_ = Related_Weaknesses.factory()
            obj_.build(child_)
            self.set_Related_Weaknesses(obj_)
        elif nodeName_ == 'Attack_Prerequisites':
            obj_ = Attack_Prerequisites.factory()
            obj_.build(child_)
            self.set_Attack_Prerequisites(obj_)
        elif nodeName_ == 'Methods_of_Attack':
            obj_ = Methods_of_Attack.factory()
            obj_.build(child_)
            self.set_Methods_of_Attack(obj_)
        elif nodeName_ == 'Attacker_Skills_or_Knowledge_Required':
            obj_ = Attacker_Skills_or_Knowledge_Required.factory()
            obj_.build(child_)
            self.set_Attacker_Skills_or_Knowledge_Required(obj_)
        elif nodeName_ == 'Resources_Required':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Resources_Required(obj_)
        elif nodeName_ == 'Attack_Motivation-Consequences':
            obj_ = Attack_Motivation_Consequences.factory()
            obj_.build(child_)
            self.set_Attack_Motivation_Consequences(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = Relationships.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
        elif nodeName_ == 'Relationship_Notes':
            obj_ = Relationship_Notes.factory()
            obj_.build(child_)
            self.set_Relationship_Notes(obj_)
        elif nodeName_ == 'Maintenance_Notes':
            obj_ = Maintenance_Notes.factory()
            obj_.build(child_)
            self.set_Maintenance_Notes(obj_)
        elif nodeName_ == 'Background_Details':
            obj_ = Background_Details.factory()
            obj_.build(child_)
            self.set_Background_Details(obj_)
        elif nodeName_ == 'Other_Notes':
            obj_ = Other_Notes.factory()
            obj_.build(child_)
            self.set_Other_Notes(obj_)
        elif nodeName_ == 'Alternate_Terms':
            obj_ = Alternate_Terms.factory()
            obj_.build(child_)
            self.set_Alternate_Terms(obj_)
        elif nodeName_ == 'Research_Gaps':
            obj_ = Research_Gaps.factory()
            obj_.build(child_)
            self.set_Research_Gaps(obj_)
        elif nodeName_ == 'References':
            obj_ = Reference_List_Type.factory()
            obj_.build(child_)
            self.set_References(obj_)
        elif nodeName_ == 'Content_History':
            obj_ = Content_History.factory()
            obj_.build(child_)
            self.set_Content_History(obj_)
# end class Category


class Description(GeneratedsSuper):
    """This field provides a description of this Category. Its primary
    subelement is Description_Summary which is intended to serve as
    a minimalistic description which provides the information
    necessary to understand the primary focus of this entry.
    Additionally, it has the subelement Extended_Description which
    is optional and is used to provide further information
    pertaining to this attack pattern."""
    subclass = None
    superclass = None
    def __init__(self, Description_Summary=None, Extended_Description=None):
        self.Description_Summary = Description_Summary
        self.Extended_Description = Extended_Description
    def factory(*args_, **kwargs_):
        if Description.subclass:
            return Description.subclass(*args_, **kwargs_)
        else:
            return Description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description_Summary(self): return self.Description_Summary
    def set_Description_Summary(self, Description_Summary): self.Description_Summary = Description_Summary
    def get_Extended_Description(self): return self.Extended_Description
    def set_Extended_Description(self, Extended_Description): self.Extended_Description = Extended_Description
    def export(self, outfile, level, namespace_='capec:', name_='Description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Description'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Description', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description_Summary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription_Summary>%s</%sDescription_Summary>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description_Summary).encode(ExternalEncoding), input_name='Description_Summary'), namespace_, eol_))
        if self.Extended_Description is not None:
            self.Extended_Description.export(outfile, level, namespace_, name_='Extended_Description', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description_Summary is not None or
            self.Extended_Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Description'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description_Summary is not None:
            showIndent(outfile, level)
            outfile.write('Description_Summary=%s,\n' % quote_python(self.Description_Summary).encode(ExternalEncoding))
        if self.Extended_Description is not None:
            showIndent(outfile, level)
            outfile.write('Extended_Description=model_.Structured_Text_Type(\n')
            self.Extended_Description.exportLiteral(outfile, level, name_='Extended_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description_Summary':
            Description_Summary_ = child_.text
            Description_Summary_ = self.gds_validate_string(Description_Summary_, node, 'Description_Summary')
            self.Description_Summary = Description_Summary_
        elif nodeName_ == 'Extended_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Extended_Description(obj_)
# end class Description


class Related_Weaknesses(GeneratedsSuper):
    """Which specific weaknesses does this attack target and leverage?
    Specific weaknesses (underlying issues that may cause
    vulnerabilities) reference the industry-standard Common Weakness
    Enumeration (CWE). This list should include not only those
    weaknesses that are directly targeted by the attack but also
    those whose presence can directly increase the likelihood of the
    attack succeeding or the impact if it does succeed."""
    subclass = None
    superclass = None
    def __init__(self, Related_Weakness=None):
        if Related_Weakness is None:
            self.Related_Weakness = []
        else:
            self.Related_Weakness = Related_Weakness
    def factory(*args_, **kwargs_):
        if Related_Weaknesses.subclass:
            return Related_Weaknesses.subclass(*args_, **kwargs_)
        else:
            return Related_Weaknesses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Weakness(self): return self.Related_Weakness
    def set_Related_Weakness(self, Related_Weakness): self.Related_Weakness = Related_Weakness
    def add_Related_Weakness(self, value): self.Related_Weakness.append(value)
    def insert_Related_Weakness(self, index, value): self.Related_Weakness[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Related_Weaknesses', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Weaknesses')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Weaknesses'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Weaknesses', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Weakness_ in self.Related_Weakness:
            Related_Weakness_.export(outfile, level, namespace_, name_='Related_Weakness', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Related_Weakness
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Weaknesses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Weakness=[\n')
        level += 1
        for Related_Weakness_ in self.Related_Weakness:
            showIndent(outfile, level)
            outfile.write('model_.Related_Weakness(\n')
            Related_Weakness_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Weakness':
            obj_ = Related_Weakness.factory()
            obj_.build(child_)
            self.Related_Weakness.append(obj_)
# end class Related_Weaknesses


class Related_Weakness(GeneratedsSuper):
    """This field describes an individual related weakness."""
    subclass = None
    superclass = None
    def __init__(self, CWE_ID=None, Weakness_Relationship_Type=None):
        self.CWE_ID = CWE_ID
        self.Weakness_Relationship_Type = Weakness_Relationship_Type
    def factory(*args_, **kwargs_):
        if Related_Weakness.subclass:
            return Related_Weakness.subclass(*args_, **kwargs_)
        else:
            return Related_Weakness(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CWE_ID(self): return self.CWE_ID
    def set_CWE_ID(self, CWE_ID): self.CWE_ID = CWE_ID
    def get_Weakness_Relationship_Type(self): return self.Weakness_Relationship_Type
    def set_Weakness_Relationship_Type(self, Weakness_Relationship_Type): self.Weakness_Relationship_Type = Weakness_Relationship_Type
    def export(self, outfile, level, namespace_='capec:', name_='Related_Weakness', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Weakness')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Weakness'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Weakness', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CWE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCWE_ID>%s</%sCWE_ID>%s' % (namespace_, self.gds_format_integer(self.CWE_ID, input_name='CWE_ID'), namespace_, eol_))
        if self.Weakness_Relationship_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeakness_Relationship_Type>%s</%sWeakness_Relationship_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.Weakness_Relationship_Type).encode(ExternalEncoding), input_name='Weakness_Relationship_Type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.CWE_ID is not None or
            self.Weakness_Relationship_Type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Weakness'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CWE_ID is not None:
            showIndent(outfile, level)
            outfile.write('CWE_ID=%d,\n' % self.CWE_ID)
        if self.Weakness_Relationship_Type is not None:
            showIndent(outfile, level)
            outfile.write('Weakness_Relationship_Type=%s,\n' % quote_python(self.Weakness_Relationship_Type).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CWE_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CWE_ID')
            self.CWE_ID = ival_
        elif nodeName_ == 'Weakness_Relationship_Type':
            Weakness_Relationship_Type_ = child_.text
            Weakness_Relationship_Type_ = self.gds_validate_string(Weakness_Relationship_Type_, node, 'Weakness_Relationship_Type')
            self.Weakness_Relationship_Type = Weakness_Relationship_Type_
# end class Related_Weakness


class Weakness_Relationship_Type(GeneratedsSuper):
    """This field describes the nature of the relationship between this
    weakness and the attack pattern. Weaknesses that are
    specifically targeted by the attack are of type “Targeted”.
    Weaknesses which are not specifically targeted but whose
    presence may increase the likelihood of the attack succeeding or
    the impact of the attack if it does succeed are of type
    “Secondary”."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Weakness_Relationship_Type.subclass:
            return Weakness_Relationship_Type.subclass(*args_, **kwargs_)
        else:
            return Weakness_Relationship_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Weakness_Relationship_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Weakness_Relationship_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Weakness_Relationship_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Weakness_Relationship_Type', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Weakness_Relationship_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Weakness_Relationship_Type


class Attack_Prerequisites(GeneratedsSuper):
    """This field describes the conditions that must exist or the
    functionality and characteristics that the target software must
    have or behavior it must exhibit for an attack of this type to
    succeed."""
    subclass = None
    superclass = None
    def __init__(self, Attack_Prerequisite=None):
        if Attack_Prerequisite is None:
            self.Attack_Prerequisite = []
        else:
            self.Attack_Prerequisite = Attack_Prerequisite
    def factory(*args_, **kwargs_):
        if Attack_Prerequisites.subclass:
            return Attack_Prerequisites.subclass(*args_, **kwargs_)
        else:
            return Attack_Prerequisites(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Prerequisite(self): return self.Attack_Prerequisite
    def set_Attack_Prerequisite(self, Attack_Prerequisite): self.Attack_Prerequisite = Attack_Prerequisite
    def add_Attack_Prerequisite(self, value): self.Attack_Prerequisite.append(value)
    def insert_Attack_Prerequisite(self, index, value): self.Attack_Prerequisite[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Prerequisites', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Prerequisites')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Prerequisites'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Prerequisites', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attack_Prerequisite_ in self.Attack_Prerequisite:
            Attack_Prerequisite_.export(outfile, level, namespace_, name_='Attack_Prerequisite', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Prerequisite
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Prerequisites'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attack_Prerequisite=[\n')
        level += 1
        for Attack_Prerequisite_ in self.Attack_Prerequisite:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Attack_Prerequisite_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Prerequisite':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Attack_Prerequisite.append(obj_)
# end class Attack_Prerequisites


class Methods_of_Attack(GeneratedsSuper):
    """This field describes the mechanism of attack used by this pattern.
    This field can help define the applicable attack surface
    required for this attack."""
    subclass = None
    superclass = None
    def __init__(self, Method_of_Attack=None):
        if Method_of_Attack is None:
            self.Method_of_Attack = []
        else:
            self.Method_of_Attack = Method_of_Attack
    def factory(*args_, **kwargs_):
        if Methods_of_Attack.subclass:
            return Methods_of_Attack.subclass(*args_, **kwargs_)
        else:
            return Methods_of_Attack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Method_of_Attack(self): return self.Method_of_Attack
    def set_Method_of_Attack(self, Method_of_Attack): self.Method_of_Attack = Method_of_Attack
    def add_Method_of_Attack(self, value): self.Method_of_Attack.append(value)
    def insert_Method_of_Attack(self, index, value): self.Method_of_Attack[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Methods_of_Attack', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Methods_of_Attack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Methods_of_Attack'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Methods_of_Attack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Method_of_Attack_ in self.Method_of_Attack:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMethod_of_Attack>%s</%sMethod_of_Attack>%s' % (namespace_, self.gds_format_string(quote_xml(Method_of_Attack_).encode(ExternalEncoding), input_name='Method_of_Attack'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Method_of_Attack
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Methods_of_Attack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Method_of_Attack=[\n')
        level += 1
        for Method_of_Attack_ in self.Method_of_Attack:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Method_of_Attack_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Method_of_Attack':
            Method_of_Attack_ = child_.text
            Method_of_Attack_ = self.gds_validate_string(Method_of_Attack_, node, 'Method_of_Attack')
            self.Method_of_Attack.append(Method_of_Attack_)
# end class Methods_of_Attack


class Method_of_Attack(GeneratedsSuper):
    """This field describes the mechanism of attack used by this pattern.
    In order to assist in normalization and classification, this
    field involves a selection from an enumerated list of defined
    vectors which is currently incomplete and will grow as new
    relevant vectors are identified. This field can help define the
    applicable attack surface required for this attack."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Method_of_Attack.subclass:
            return Method_of_Attack.subclass(*args_, **kwargs_)
        else:
            return Method_of_Attack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Method_of_Attack', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Method_of_Attack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Method_of_Attack'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Method_of_Attack', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Method_of_Attack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Method_of_Attack


class Attacker_Skills_or_Knowledge_Required(GeneratedsSuper):
    """This field describes the level of skills or specific knowledge
    required by an attacker to execute this type of attack."""
    subclass = None
    superclass = None
    def __init__(self, Attacker_Skill_or_Knowledge_Required=None):
        if Attacker_Skill_or_Knowledge_Required is None:
            self.Attacker_Skill_or_Knowledge_Required = []
        else:
            self.Attacker_Skill_or_Knowledge_Required = Attacker_Skill_or_Knowledge_Required
    def factory(*args_, **kwargs_):
        if Attacker_Skills_or_Knowledge_Required.subclass:
            return Attacker_Skills_or_Knowledge_Required.subclass(*args_, **kwargs_)
        else:
            return Attacker_Skills_or_Knowledge_Required(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attacker_Skill_or_Knowledge_Required(self): return self.Attacker_Skill_or_Knowledge_Required
    def set_Attacker_Skill_or_Knowledge_Required(self, Attacker_Skill_or_Knowledge_Required): self.Attacker_Skill_or_Knowledge_Required = Attacker_Skill_or_Knowledge_Required
    def add_Attacker_Skill_or_Knowledge_Required(self, value): self.Attacker_Skill_or_Knowledge_Required.append(value)
    def insert_Attacker_Skill_or_Knowledge_Required(self, index, value): self.Attacker_Skill_or_Knowledge_Required[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attacker_Skills_or_Knowledge_Required', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attacker_Skills_or_Knowledge_Required')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attacker_Skills_or_Knowledge_Required'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attacker_Skills_or_Knowledge_Required', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attacker_Skill_or_Knowledge_Required_ in self.Attacker_Skill_or_Knowledge_Required:
            Attacker_Skill_or_Knowledge_Required_.export(outfile, level, namespace_, name_='Attacker_Skill_or_Knowledge_Required', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attacker_Skill_or_Knowledge_Required
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attacker_Skills_or_Knowledge_Required'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attacker_Skill_or_Knowledge_Required=[\n')
        level += 1
        for Attacker_Skill_or_Knowledge_Required_ in self.Attacker_Skill_or_Knowledge_Required:
            showIndent(outfile, level)
            outfile.write('model_.Attacker_Skill_or_Knowledge_Required(\n')
            Attacker_Skill_or_Knowledge_Required_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attacker_Skill_or_Knowledge_Required':
            obj_ = Attacker_Skill_or_Knowledge_Required.factory()
            obj_.build(child_)
            self.Attacker_Skill_or_Knowledge_Required.append(obj_)
# end class Attacker_Skills_or_Knowledge_Required


class Attacker_Skill_or_Knowledge_Required(GeneratedsSuper):
    """This field describes the level of skill or specific knowledge
    required by an attacker to execute this type of attack."""
    subclass = None
    superclass = None
    def __init__(self, Skill_or_Knowledge_Level=None, Skill_or_Knowledge_Type=None):
        self.Skill_or_Knowledge_Level = Skill_or_Knowledge_Level
        self.Skill_or_Knowledge_Type = Skill_or_Knowledge_Type
    def factory(*args_, **kwargs_):
        if Attacker_Skill_or_Knowledge_Required.subclass:
            return Attacker_Skill_or_Knowledge_Required.subclass(*args_, **kwargs_)
        else:
            return Attacker_Skill_or_Knowledge_Required(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Skill_or_Knowledge_Level(self): return self.Skill_or_Knowledge_Level
    def set_Skill_or_Knowledge_Level(self, Skill_or_Knowledge_Level): self.Skill_or_Knowledge_Level = Skill_or_Knowledge_Level
    def get_Skill_or_Knowledge_Type(self): return self.Skill_or_Knowledge_Type
    def set_Skill_or_Knowledge_Type(self, Skill_or_Knowledge_Type): self.Skill_or_Knowledge_Type = Skill_or_Knowledge_Type
    def export(self, outfile, level, namespace_='capec:', name_='Attacker_Skill_or_Knowledge_Required', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attacker_Skill_or_Knowledge_Required')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attacker_Skill_or_Knowledge_Required'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attacker_Skill_or_Knowledge_Required', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Skill_or_Knowledge_Level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSkill_or_Knowledge_Level>%s</%sSkill_or_Knowledge_Level>%s' % (namespace_, self.gds_format_string(quote_xml(self.Skill_or_Knowledge_Level).encode(ExternalEncoding), input_name='Skill_or_Knowledge_Level'), namespace_, eol_))
        if self.Skill_or_Knowledge_Type is not None:
            self.Skill_or_Knowledge_Type.export(outfile, level, namespace_, name_='Skill_or_Knowledge_Type', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Skill_or_Knowledge_Level is not None or
            self.Skill_or_Knowledge_Type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attacker_Skill_or_Knowledge_Required'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Skill_or_Knowledge_Level is not None:
            showIndent(outfile, level)
            outfile.write('Skill_or_Knowledge_Level=%s,\n' % quote_python(self.Skill_or_Knowledge_Level).encode(ExternalEncoding))
        if self.Skill_or_Knowledge_Type is not None:
            showIndent(outfile, level)
            outfile.write('Skill_or_Knowledge_Type=model_.Structured_Text_Type(\n')
            self.Skill_or_Knowledge_Type.exportLiteral(outfile, level, name_='Skill_or_Knowledge_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Skill_or_Knowledge_Level':
            Skill_or_Knowledge_Level_ = child_.text
            Skill_or_Knowledge_Level_ = self.gds_validate_string(Skill_or_Knowledge_Level_, node, 'Skill_or_Knowledge_Level')
            self.Skill_or_Knowledge_Level = Skill_or_Knowledge_Level_
        elif nodeName_ == 'Skill_or_Knowledge_Type':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Skill_or_Knowledge_Type(obj_)
# end class Attacker_Skill_or_Knowledge_Required


class Skill_or_Knowledge_Level(GeneratedsSuper):
    """This should be communicated on a rough scale (Low, Medium, High).
    For example: • Low - Basic computer familiarity • Low -
    Basic SQL knowledge • Medium - Moderate scripting and shell
    experience and ability to disassemble and decompile • High -
    Expert knowledge of LINUX kernel • High - Detailed knowledge
    of target software development practices and business context
    (former employee) • Etc."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Skill_or_Knowledge_Level.subclass:
            return Skill_or_Knowledge_Level.subclass(*args_, **kwargs_)
        else:
            return Skill_or_Knowledge_Level(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Skill_or_Knowledge_Level', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Skill_or_Knowledge_Level')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Skill_or_Knowledge_Level'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Skill_or_Knowledge_Level', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Skill_or_Knowledge_Level'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Skill_or_Knowledge_Level


class Attack_Motivation_Consequences(GeneratedsSuper):
    """What is the attacker trying to achieve by using this attack? This is
    not the end business/mission goal of the attack within the
    target context but rather the specific technical result desired
    that could be leveraged to achieve the end business/mission
    objective. This information is useful for aligning attack
    patterns to threat models and for determining which attack
    patterns are relevant for a given context."""
    subclass = None
    superclass = None
    def __init__(self, Attack_Motivation_Consequence=None):
        if Attack_Motivation_Consequence is None:
            self.Attack_Motivation_Consequence = []
        else:
            self.Attack_Motivation_Consequence = Attack_Motivation_Consequence
    def factory(*args_, **kwargs_):
        if Attack_Motivation_Consequences.subclass:
            return Attack_Motivation_Consequences.subclass(*args_, **kwargs_)
        else:
            return Attack_Motivation_Consequences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Motivation_Consequence(self): return self.Attack_Motivation_Consequence
    def set_Attack_Motivation_Consequence(self, Attack_Motivation_Consequence): self.Attack_Motivation_Consequence = Attack_Motivation_Consequence
    def add_Attack_Motivation_Consequence(self, value): self.Attack_Motivation_Consequence.append(value)
    def insert_Attack_Motivation_Consequence(self, index, value): self.Attack_Motivation_Consequence[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Motivation-Consequences', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Motivation-Consequences')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Motivation-Consequences'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Motivation-Consequences', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attack_Motivation_Consequence_ in self.Attack_Motivation_Consequence:
            Attack_Motivation_Consequence_.export(outfile, level, namespace_, name_='Attack_Motivation-Consequence', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Motivation_Consequence
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Motivation-Consequences'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attack_Motivation_Consequence=[\n')
        level += 1
        for Attack_Motivation_Consequence_ in self.Attack_Motivation_Consequence:
            showIndent(outfile, level)
            outfile.write('model_.Common_ConsequenceType(\n')
            Attack_Motivation_Consequence_.exportLiteral(outfile, level, name_='Common_ConsequenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Motivation-Consequence':
            obj_ = Common_ConsequenceType.factory()
            obj_.build(child_)
            self.Attack_Motivation_Consequence.append(obj_)
# end class Attack_Motivation_Consequences


class Background_Details(GeneratedsSuper):
    """This structure contains one or more Background_Detail elements, each
    of which holds information regarding the entry or any
    technologies that are related to it, where the background
    information is not related to the nature of the entry itself. It
    should be filled out where appropriate."""
    subclass = None
    superclass = None
    def __init__(self, Background_Detail=None):
        if Background_Detail is None:
            self.Background_Detail = []
        else:
            self.Background_Detail = Background_Detail
    def factory(*args_, **kwargs_):
        if Background_Details.subclass:
            return Background_Details.subclass(*args_, **kwargs_)
        else:
            return Background_Details(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Background_Detail(self): return self.Background_Detail
    def set_Background_Detail(self, Background_Detail): self.Background_Detail = Background_Detail
    def add_Background_Detail(self, value): self.Background_Detail.append(value)
    def insert_Background_Detail(self, index, value): self.Background_Detail[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Background_Details', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Background_Details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Background_Details'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Background_Details', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Background_Detail_ in self.Background_Detail:
            Background_Detail_.export(outfile, level, namespace_, name_='Background_Detail', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Background_Detail
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Background_Details'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Background_Detail=[\n')
        level += 1
        for Background_Detail_ in self.Background_Detail:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Background_Detail_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Background_Detail':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Background_Detail.append(obj_)
# end class Background_Details


class Compound_Element(GeneratedsSuper):
    """This attribute provides a unique identifier for the entry. It will
    be static for the lifetime of the entry. In the event that this
    entry becomes deprecated, the ID will not be reused and a
    pointer will be left in this entry to the replacement. This is
    required for all Compound_Elements. The Name is a descriptive
    name used to give the reader an idea of the meaning behind the
    compound attack pattern structure. All words in the name should
    be capitalized except for articles and prepositions unless they
    begin or end the name. Subsequent words in a hyphenated chain
    are also not capitalized. This is required for all
    Compound_Elements. The Abstraction defines the abstraction level
    for this attack pattern. The abstraction levels for
    Compound_Elements and Attack Patterns are the same. For example,
    if the Compound_Element is a chain, and all elements of the
    chain are Meta level, then the Compound_Element Abstraction
    attribute is Meta. This is required for all Compound_Elements.
    The Structure attribute defines the structural nature of this
    compound element - that is, composed of other attack patterns
    concurrently, as in a composite, or consecutively, as in a
    chain. The Status attribute defines the status level for this
    compound element."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, Name=None, Compound_Element_Structure=None, Compound_Element_Completeness=None, ID=None, Compound_Element_Abstraction=None, Description=None, Relationships=None, Relationship_Notes=None, Maintenance_Notes=None, Background_Details=None, Other_Notes=None, Alternate_Terms=None, Research_Gaps=None, References=None, Content_History=None):
        self.Status = _cast(None, Status)
        self.Name = _cast(None, Name)
        self.Compound_Element_Structure = _cast(None, Compound_Element_Structure)
        self.Compound_Element_Completeness = _cast(None, Compound_Element_Completeness)
        self.ID = _cast(int, ID)
        self.Compound_Element_Abstraction = _cast(None, Compound_Element_Abstraction)
        self.Description = Description
        self.Relationships = Relationships
        self.Relationship_Notes = Relationship_Notes
        self.Maintenance_Notes = Maintenance_Notes
        self.Background_Details = Background_Details
        self.Other_Notes = Other_Notes
        self.Alternate_Terms = Alternate_Terms
        self.Research_Gaps = Research_Gaps
        self.References = References
        self.Content_History = Content_History
    def factory(*args_, **kwargs_):
        if Compound_Element.subclass:
            return Compound_Element.subclass(*args_, **kwargs_)
        else:
            return Compound_Element(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Relationships(self): return self.Relationships
    def set_Relationships(self, Relationships): self.Relationships = Relationships
    def get_Relationship_Notes(self): return self.Relationship_Notes
    def set_Relationship_Notes(self, Relationship_Notes): self.Relationship_Notes = Relationship_Notes
    def get_Maintenance_Notes(self): return self.Maintenance_Notes
    def set_Maintenance_Notes(self, Maintenance_Notes): self.Maintenance_Notes = Maintenance_Notes
    def get_Background_Details(self): return self.Background_Details
    def set_Background_Details(self, Background_Details): self.Background_Details = Background_Details
    def get_Other_Notes(self): return self.Other_Notes
    def set_Other_Notes(self, Other_Notes): self.Other_Notes = Other_Notes
    def get_Alternate_Terms(self): return self.Alternate_Terms
    def set_Alternate_Terms(self, Alternate_Terms): self.Alternate_Terms = Alternate_Terms
    def get_Research_Gaps(self): return self.Research_Gaps
    def set_Research_Gaps(self, Research_Gaps): self.Research_Gaps = Research_Gaps
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Content_History(self): return self.Content_History
    def set_Content_History(self, Content_History): self.Content_History = Content_History
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Compound_Element_Structure(self): return self.Compound_Element_Structure
    def set_Compound_Element_Structure(self, Compound_Element_Structure): self.Compound_Element_Structure = Compound_Element_Structure
    def get_Compound_Element_Completeness(self): return self.Compound_Element_Completeness
    def set_Compound_Element_Completeness(self, Compound_Element_Completeness): self.Compound_Element_Completeness = Compound_Element_Completeness
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Compound_Element_Abstraction(self): return self.Compound_Element_Abstraction
    def set_Compound_Element_Abstraction(self, Compound_Element_Abstraction): self.Compound_Element_Abstraction = Compound_Element_Abstraction
    def export(self, outfile, level, namespace_='capec:', name_='Compound_Element', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Compound_Element')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Compound_Element'):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
        if self.Compound_Element_Structure is not None and 'Compound_Element_Structure' not in already_processed:
            already_processed.append('Compound_Element_Structure')
            outfile.write(' Compound_Element_Structure=%s' % (self.gds_format_string(quote_attrib(self.Compound_Element_Structure).encode(ExternalEncoding), input_name='Compound_Element_Structure'), ))
        if self.Compound_Element_Completeness is not None and 'Compound_Element_Completeness' not in already_processed:
            already_processed.append('Compound_Element_Completeness')
            outfile.write(' Compound_Element_Completeness=%s' % (self.gds_format_string(quote_attrib(self.Compound_Element_Completeness).encode(ExternalEncoding), input_name='Compound_Element_Completeness'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Compound_Element_Abstraction is not None and 'Compound_Element_Abstraction' not in already_processed:
            already_processed.append('Compound_Element_Abstraction')
            outfile.write(' Compound_Element_Abstraction=%s' % (self.gds_format_string(quote_attrib(self.Compound_Element_Abstraction).encode(ExternalEncoding), input_name='Compound_Element_Abstraction'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Compound_Element', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Relationships is not None:
            self.Relationships.export(outfile, level, namespace_, name_='Relationships', pretty_print=pretty_print)
        if self.Relationship_Notes is not None:
            self.Relationship_Notes.export(outfile, level, namespace_, name_='Relationship_Notes', pretty_print=pretty_print)
        if self.Maintenance_Notes is not None:
            self.Maintenance_Notes.export(outfile, level, namespace_, name_='Maintenance_Notes', pretty_print=pretty_print)
        if self.Background_Details is not None:
            self.Background_Details.export(outfile, level, namespace_, name_='Background_Details', pretty_print=pretty_print)
        if self.Other_Notes is not None:
            self.Other_Notes.export(outfile, level, namespace_, name_='Other_Notes', pretty_print=pretty_print)
        if self.Alternate_Terms is not None:
            self.Alternate_Terms.export(outfile, level, namespace_, name_='Alternate_Terms', pretty_print=pretty_print)
        if self.Research_Gaps is not None:
            self.Research_Gaps.export(outfile, level, namespace_, name_='Research_Gaps', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        if self.Content_History is not None:
            self.Content_History.export(outfile, level, namespace_, name_='Content_History', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Relationships is not None or
            self.Relationship_Notes is not None or
            self.Maintenance_Notes is not None or
            self.Background_Details is not None or
            self.Other_Notes is not None or
            self.Alternate_Terms is not None or
            self.Research_Gaps is not None or
            self.References is not None or
            self.Content_History is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Compound_Element'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        if self.Compound_Element_Structure is not None and 'Compound_Element_Structure' not in already_processed:
            already_processed.append('Compound_Element_Structure')
            showIndent(outfile, level)
            outfile.write('Compound_Element_Structure = "%s",\n' % (self.Compound_Element_Structure,))
        if self.Compound_Element_Completeness is not None and 'Compound_Element_Completeness' not in already_processed:
            already_processed.append('Compound_Element_Completeness')
            showIndent(outfile, level)
            outfile.write('Compound_Element_Completeness = "%s",\n' % (self.Compound_Element_Completeness,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Compound_Element_Abstraction is not None and 'Compound_Element_Abstraction' not in already_processed:
            already_processed.append('Compound_Element_Abstraction')
            showIndent(outfile, level)
            outfile.write('Compound_Element_Abstraction = "%s",\n' % (self.Compound_Element_Abstraction,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationships is not None:
            showIndent(outfile, level)
            outfile.write('Relationships=model_.Relationships(\n')
            self.Relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationship_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Notes=model_.Relationship_Notes(\n')
            self.Relationship_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Maintenance_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Maintenance_Notes=model_.Maintenance_Notes(\n')
            self.Maintenance_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Background_Details is not None:
            showIndent(outfile, level)
            outfile.write('Background_Details=model_.Background_Details(\n')
            self.Background_Details.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Other_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Other_Notes=model_.Other_Notes(\n')
            self.Other_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Alternate_Terms is not None:
            showIndent(outfile, level)
            outfile.write('Alternate_Terms=model_.Alternate_Terms(\n')
            self.Alternate_Terms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Research_Gaps is not None:
            showIndent(outfile, level)
            outfile.write('Research_Gaps=model_.Research_Gaps(\n')
            self.Research_Gaps.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.Reference_List_Type(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_History is not None:
            showIndent(outfile, level)
            outfile.write('Content_History=model_.Content_History(\n')
            self.Content_History.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = find_attr_value_('Compound_Element_Structure', node)
        if value is not None and 'Compound_Element_Structure' not in already_processed:
            already_processed.append('Compound_Element_Structure')
            self.Compound_Element_Structure = value
        value = find_attr_value_('Compound_Element_Completeness', node)
        if value is not None and 'Compound_Element_Completeness' not in already_processed:
            already_processed.append('Compound_Element_Completeness')
            self.Compound_Element_Completeness = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Compound_Element_Abstraction', node)
        if value is not None and 'Compound_Element_Abstraction' not in already_processed:
            already_processed.append('Compound_Element_Abstraction')
            self.Compound_Element_Abstraction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Description.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Relationships':
            obj_ = Relationships.factory()
            obj_.build(child_)
            self.set_Relationships(obj_)
        elif nodeName_ == 'Relationship_Notes':
            obj_ = Relationship_Notes.factory()
            obj_.build(child_)
            self.set_Relationship_Notes(obj_)
        elif nodeName_ == 'Maintenance_Notes':
            obj_ = Maintenance_Notes.factory()
            obj_.build(child_)
            self.set_Maintenance_Notes(obj_)
        elif nodeName_ == 'Background_Details':
            obj_ = Background_Details.factory()
            obj_.build(child_)
            self.set_Background_Details(obj_)
        elif nodeName_ == 'Other_Notes':
            obj_ = Other_Notes.factory()
            obj_.build(child_)
            self.set_Other_Notes(obj_)
        elif nodeName_ == 'Alternate_Terms':
            obj_ = Alternate_Terms.factory()
            obj_.build(child_)
            self.set_Alternate_Terms(obj_)
        elif nodeName_ == 'Research_Gaps':
            obj_ = Research_Gaps.factory()
            obj_.build(child_)
            self.set_Research_Gaps(obj_)
        elif nodeName_ == 'References':
            obj_ = Reference_List_Type.factory()
            obj_.build(child_)
            self.set_References(obj_)
        elif nodeName_ == 'Content_History':
            obj_ = Content_History.factory()
            obj_.build(child_)
            self.set_Content_History(obj_)
# end class Compound_Element


class Environment(GeneratedsSuper):
    """Description and globally unique ID for a kind of environment or
    context that is required. Used in Attack Steps, Indicators of
    Susceptibility, and Security Controls, etc."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Environment_Title=None, Environment_Description=None):
        self.ID = _cast(None, ID)
        self.Environment_Title = Environment_Title
        self.Environment_Description = Environment_Description
    def factory(*args_, **kwargs_):
        if Environment.subclass:
            return Environment.subclass(*args_, **kwargs_)
        else:
            return Environment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Environment_Title(self): return self.Environment_Title
    def set_Environment_Title(self, Environment_Title): self.Environment_Title = Environment_Title
    def get_Environment_Description(self): return self.Environment_Description
    def set_Environment_Description(self, Environment_Description): self.Environment_Description = Environment_Description
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Environment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Environment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Environment'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Environment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Environment_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnvironment_Title>%s</%sEnvironment_Title>%s' % (namespace_, self.gds_format_string(quote_xml(self.Environment_Title).encode(ExternalEncoding), input_name='Environment_Title'), namespace_, eol_))
        if self.Environment_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnvironment_Description>%s</%sEnvironment_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.Environment_Description).encode(ExternalEncoding), input_name='Environment_Description'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Environment_Title is not None or
            self.Environment_Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Environment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Environment_Title is not None:
            showIndent(outfile, level)
            outfile.write('Environment_Title=%s,\n' % quote_python(self.Environment_Title).encode(ExternalEncoding))
        if self.Environment_Description is not None:
            showIndent(outfile, level)
            outfile.write('Environment_Description=%s,\n' % quote_python(self.Environment_Description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Environment_Title':
            Environment_Title_ = child_.text
            Environment_Title_ = re_.sub(String_cleanup_pat_, " ", Environment_Title_).strip()
            Environment_Title_ = self.gds_validate_string(Environment_Title_, node, 'Environment_Title')
            self.Environment_Title = Environment_Title_
        elif nodeName_ == 'Environment_Description':
            Environment_Description_ = child_.text
            Environment_Description_ = re_.sub(String_cleanup_pat_, " ", Environment_Description_).strip()
            Environment_Description_ = self.gds_validate_string(Environment_Description_, node, 'Environment_Description')
            self.Environment_Description = Environment_Description_
# end class Environment


class Attack_Execution_Flow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Phases=None):
        self.Attack_Phases = Attack_Phases
    def factory(*args_, **kwargs_):
        if Attack_Execution_Flow.subclass:
            return Attack_Execution_Flow.subclass(*args_, **kwargs_)
        else:
            return Attack_Execution_Flow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Phases(self): return self.Attack_Phases
    def set_Attack_Phases(self, Attack_Phases): self.Attack_Phases = Attack_Phases
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Execution_Flow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Execution_Flow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Execution_Flow'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Execution_Flow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attack_Phases is not None:
            self.Attack_Phases.export(outfile, level, namespace_, name_='Attack_Phases', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Phases is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Execution_Flow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attack_Phases is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Phases=model_.Attack_Phases(\n')
            self.Attack_Phases.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Phases':
            obj_ = Attack_Phases.factory()
            obj_.build(child_)
            self.set_Attack_Phases(obj_)
# end class Attack_Execution_Flow


class Attack_Phases(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Phase=None):
        if Attack_Phase is None:
            self.Attack_Phase = []
        else:
            self.Attack_Phase = Attack_Phase
    def factory(*args_, **kwargs_):
        if Attack_Phases.subclass:
            return Attack_Phases.subclass(*args_, **kwargs_)
        else:
            return Attack_Phases(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Phase(self): return self.Attack_Phase
    def set_Attack_Phase(self, Attack_Phase): self.Attack_Phase = Attack_Phase
    def add_Attack_Phase(self, value): self.Attack_Phase.append(value)
    def insert_Attack_Phase(self, index, value): self.Attack_Phase[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Phases', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Phases')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Phases'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Phases', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attack_Phase_ in self.Attack_Phase:
            Attack_Phase_.export(outfile, level, namespace_, name_='Attack_Phase', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Phase
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Phases'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attack_Phase=[\n')
        level += 1
        for Attack_Phase_ in self.Attack_Phase:
            showIndent(outfile, level)
            outfile.write('model_.Attack_Phase(\n')
            Attack_Phase_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Phase':
            obj_ = Attack_Phase.factory()
            obj_.build(child_)
            self.Attack_Phase.append(obj_)
# end class Attack_Phases


class Attack_Phase(GeneratedsSuper):
    """ Segment the attack steps into the various phases of attack. One of
    three phases "Explore," "Experiment," or "Exploit." Each phase
    should appear at most once, and attack steps should be grouped
    by what kind of activities the attacker is carrying out. The
    exploration and experimentation phases may or may not occur
    during a particular attack, because the attacker may already
    know exactly how to exploit a system. One of three phases
    "Explore," "Experiment," or "Exploit." Each phase should appear
    at most once, and attack steps should be grouped by what kind of
    activities the attacker is carrying out. "Explore,"
    "Experiment," or "Exploit." """
    subclass = None
    superclass = None
    def __init__(self, ID=None, Name=None, Attack_Steps=None):
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        self.Attack_Steps = Attack_Steps
    def factory(*args_, **kwargs_):
        if Attack_Phase.subclass:
            return Attack_Phase.subclass(*args_, **kwargs_)
        else:
            return Attack_Phase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Steps(self): return self.Attack_Steps
    def set_Attack_Steps(self, Attack_Steps): self.Attack_Steps = Attack_Steps
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Phase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Phase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Phase'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Phase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attack_Steps is not None:
            self.Attack_Steps.export(outfile, level, namespace_, name_='Attack_Steps', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Steps is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Phase'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attack_Steps is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Steps=model_.Attack_Steps(\n')
            self.Attack_Steps.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
            self.Name = ' '.join(self.Name.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Steps':
            obj_ = Attack_Steps.factory()
            obj_.build(child_)
            self.set_Attack_Steps(obj_)
# end class Attack_Phase


class Attack_Steps(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Step=None):
        if Attack_Step is None:
            self.Attack_Step = []
        else:
            self.Attack_Step = Attack_Step
    def factory(*args_, **kwargs_):
        if Attack_Steps.subclass:
            return Attack_Steps.subclass(*args_, **kwargs_)
        else:
            return Attack_Steps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Step(self): return self.Attack_Step
    def set_Attack_Step(self, Attack_Step): self.Attack_Step = Attack_Step
    def add_Attack_Step(self, value): self.Attack_Step.append(value)
    def insert_Attack_Step(self, index, value): self.Attack_Step[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Steps', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Steps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Steps'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Steps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attack_Step_ in self.Attack_Step:
            Attack_Step_.export(outfile, level, namespace_, name_='Attack_Step', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Step
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Steps'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attack_Step=[\n')
        level += 1
        for Attack_Step_ in self.Attack_Step:
            showIndent(outfile, level)
            outfile.write('model_.Attack_Step(\n')
            Attack_Step_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Step':
            obj_ = Attack_Step.factory()
            obj_.build(child_)
            self.Attack_Step.append(obj_)
# end class Attack_Steps


class Attack_Step(GeneratedsSuper):
    """Brief description of an individual action step in carrying out the
    attack"""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Common_Attack_Step=None, Custom_Attack_Step=None):
        self.ID = _cast(int, ID)
        self.Common_Attack_Step = Common_Attack_Step
        self.Custom_Attack_Step = Custom_Attack_Step
    def factory(*args_, **kwargs_):
        if Attack_Step.subclass:
            return Attack_Step.subclass(*args_, **kwargs_)
        else:
            return Attack_Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Common_Attack_Step(self): return self.Common_Attack_Step
    def set_Common_Attack_Step(self, Common_Attack_Step): self.Common_Attack_Step = Common_Attack_Step
    def get_Custom_Attack_Step(self): return self.Custom_Attack_Step
    def set_Custom_Attack_Step(self, Custom_Attack_Step): self.Custom_Attack_Step = Custom_Attack_Step
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Step', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Step'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Step', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Common_Attack_Step is not None:
            self.Common_Attack_Step.export(outfile, level, namespace_, name_='Common_Attack_Step', pretty_print=pretty_print)
        if self.Custom_Attack_Step is not None:
            self.Custom_Attack_Step.export(outfile, level, namespace_, name_='Custom_Attack_Step', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Common_Attack_Step is not None or
            self.Custom_Attack_Step is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Step'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Common_Attack_Step is not None:
            showIndent(outfile, level)
            outfile.write('Common_Attack_Step=model_.Common_Attack_Step(\n')
            self.Common_Attack_Step.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Custom_Attack_Step is not None:
            showIndent(outfile, level)
            outfile.write('Custom_Attack_Step=model_.Custom_Attack_StepType(\n')
            self.Custom_Attack_Step.exportLiteral(outfile, level, name_='Custom_Attack_Step')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Common_Attack_Step':
            obj_ = Common_Attack_Step.factory()
            obj_.build(child_)
            self.set_Common_Attack_Step(obj_)
        elif nodeName_ == 'Custom_Attack_Step':
            class_obj_ = self.get_class_obj_(child_, Custom_Attack_StepType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Custom_Attack_Step(obj_)
# end class Attack_Step


class Common_Attack_Step(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Common_Attack_Step_ID=None, Pattern_Specific_Overrides=None):
        self.Common_Attack_Step_ID = _cast(int, Common_Attack_Step_ID)
        self.Pattern_Specific_Overrides = Pattern_Specific_Overrides
    def factory(*args_, **kwargs_):
        if Common_Attack_Step.subclass:
            return Common_Attack_Step.subclass(*args_, **kwargs_)
        else:
            return Common_Attack_Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pattern_Specific_Overrides(self): return self.Pattern_Specific_Overrides
    def set_Pattern_Specific_Overrides(self, Pattern_Specific_Overrides): self.Pattern_Specific_Overrides = Pattern_Specific_Overrides
    def get_Common_Attack_Step_ID(self): return self.Common_Attack_Step_ID
    def set_Common_Attack_Step_ID(self, Common_Attack_Step_ID): self.Common_Attack_Step_ID = Common_Attack_Step_ID
    def export(self, outfile, level, namespace_='capec:', name_='Common_Attack_Step', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_Attack_Step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_Attack_Step'):
        if self.Common_Attack_Step_ID is not None and 'Common_Attack_Step_ID' not in already_processed:
            already_processed.append('Common_Attack_Step_ID')
            outfile.write(' Common_Attack_Step_ID="%s"' % self.gds_format_integer(self.Common_Attack_Step_ID, input_name='Common_Attack_Step_ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_Attack_Step', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Pattern_Specific_Overrides is not None:
            self.Pattern_Specific_Overrides.export(outfile, level, namespace_, name_='Pattern_Specific_Overrides', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Pattern_Specific_Overrides is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Common_Attack_Step'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Common_Attack_Step_ID is not None and 'Common_Attack_Step_ID' not in already_processed:
            already_processed.append('Common_Attack_Step_ID')
            showIndent(outfile, level)
            outfile.write('Common_Attack_Step_ID = %d,\n' % (self.Common_Attack_Step_ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Pattern_Specific_Overrides is not None:
            showIndent(outfile, level)
            outfile.write('Pattern_Specific_Overrides=model_.Custom_Attack_StepType(\n')
            self.Pattern_Specific_Overrides.exportLiteral(outfile, level, name_='Pattern_Specific_Overrides')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Common_Attack_Step_ID', node)
        if value is not None and 'Common_Attack_Step_ID' not in already_processed:
            already_processed.append('Common_Attack_Step_ID')
            try:
                self.Common_Attack_Step_ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pattern_Specific_Overrides':
            class_obj_ = self.get_class_obj_(child_, Custom_Attack_StepType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Pattern_Specific_Overrides(obj_)
# end class Common_Attack_Step


class Attack_Step_Technique(GeneratedsSuper):
    """A particular technique that may accomplish this attack step."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Attack_Step_Technique_Description=None, Leveraged_Attack_Patterns=None, Relevant_Attack_Surface_Elements=None, Observables=None, Environments=None):
        self.ID = _cast(int, ID)
        self.Attack_Step_Technique_Description = Attack_Step_Technique_Description
        self.Leveraged_Attack_Patterns = Leveraged_Attack_Patterns
        self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
        self.Observables = Observables
        self.Environments = Environments
    def factory(*args_, **kwargs_):
        if Attack_Step_Technique.subclass:
            return Attack_Step_Technique.subclass(*args_, **kwargs_)
        else:
            return Attack_Step_Technique(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Step_Technique_Description(self): return self.Attack_Step_Technique_Description
    def set_Attack_Step_Technique_Description(self, Attack_Step_Technique_Description): self.Attack_Step_Technique_Description = Attack_Step_Technique_Description
    def get_Leveraged_Attack_Patterns(self): return self.Leveraged_Attack_Patterns
    def set_Leveraged_Attack_Patterns(self, Leveraged_Attack_Patterns): self.Leveraged_Attack_Patterns = Leveraged_Attack_Patterns
    def get_Relevant_Attack_Surface_Elements(self): return self.Relevant_Attack_Surface_Elements
    def set_Relevant_Attack_Surface_Elements(self, Relevant_Attack_Surface_Elements): self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def get_Environments(self): return self.Environments
    def set_Environments(self, Environments): self.Environments = Environments
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Step_Technique', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Step_Technique')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Step_Technique'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Step_Technique', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attack_Step_Technique_Description is not None:
            self.Attack_Step_Technique_Description.export(outfile, level, namespace_, name_='Attack_Step_Technique_Description', pretty_print=pretty_print)
        if self.Leveraged_Attack_Patterns is not None:
            self.Leveraged_Attack_Patterns.export(outfile, level, namespace_, name_='Leveraged_Attack_Patterns', pretty_print=pretty_print)
        if self.Relevant_Attack_Surface_Elements is not None:
            self.Relevant_Attack_Surface_Elements.export(outfile, level, namespace_, name_='Relevant_Attack_Surface_Elements', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
        if self.Environments is not None:
            self.Environments.export(outfile, level, namespace_, name_='Environments', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Step_Technique_Description is not None or
            self.Leveraged_Attack_Patterns is not None or
            self.Relevant_Attack_Surface_Elements is not None or
            self.Observables is not None or
            self.Environments is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Step_Technique'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attack_Step_Technique_Description is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Step_Technique_Description=model_.Structured_Text_Type(\n')
            self.Attack_Step_Technique_Description.exportLiteral(outfile, level, name_='Attack_Step_Technique_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Leveraged_Attack_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Leveraged_Attack_Patterns=model_.Leveraged_Attack_Patterns(\n')
            self.Leveraged_Attack_Patterns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Attack_Surface_Elements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Attack_Surface_Elements=model_.Relevant_Attack_Surface_ElementsType(\n')
            self.Relevant_Attack_Surface_Elements.exportLiteral(outfile, level, name_='Relevant_Attack_Surface_Elements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Environments is not None:
            showIndent(outfile, level)
            outfile.write('Environments=%s,\n' % quote_python(self.Environments).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Step_Technique_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Attack_Step_Technique_Description(obj_)
        elif nodeName_ == 'Leveraged_Attack_Patterns':
            obj_ = Leveraged_Attack_Patterns.factory()
            obj_.build(child_)
            self.set_Leveraged_Attack_Patterns(obj_)
        elif nodeName_ == 'Relevant_Attack_Surface_Elements':
            obj_ = Relevant_Attack_Surface_ElementsType.factory()
            obj_.build(child_)
            self.set_Relevant_Attack_Surface_Elements(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
        elif nodeName_ == 'Environments':
            obj_ = Environments.factory()
            obj_.build(child_)
            self.set_Environments(obj_)
# end class Attack_Step_Technique


class Leveraged_Attack_Patterns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Leveraged_Attack_Pattern_ID=None):
        if Leveraged_Attack_Pattern_ID is None:
            self.Leveraged_Attack_Pattern_ID = []
        else:
            self.Leveraged_Attack_Pattern_ID = Leveraged_Attack_Pattern_ID
    def factory(*args_, **kwargs_):
        if Leveraged_Attack_Patterns.subclass:
            return Leveraged_Attack_Patterns.subclass(*args_, **kwargs_)
        else:
            return Leveraged_Attack_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Leveraged_Attack_Pattern_ID(self): return self.Leveraged_Attack_Pattern_ID
    def set_Leveraged_Attack_Pattern_ID(self, Leveraged_Attack_Pattern_ID): self.Leveraged_Attack_Pattern_ID = Leveraged_Attack_Pattern_ID
    def add_Leveraged_Attack_Pattern_ID(self, value): self.Leveraged_Attack_Pattern_ID.append(value)
    def insert_Leveraged_Attack_Pattern_ID(self, index, value): self.Leveraged_Attack_Pattern_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Leveraged_Attack_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Leveraged_Attack_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Leveraged_Attack_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Leveraged_Attack_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Leveraged_Attack_Pattern_ID_ in self.Leveraged_Attack_Pattern_ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLeveraged_Attack_Pattern_ID>%s</%sLeveraged_Attack_Pattern_ID>%s' % (namespace_, self.gds_format_string(quote_xml(Leveraged_Attack_Pattern_ID_).encode(ExternalEncoding), input_name='Leveraged_Attack_Pattern_ID'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Leveraged_Attack_Pattern_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Leveraged_Attack_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Leveraged_Attack_Pattern_ID=[\n')
        level += 1
        for Leveraged_Attack_Pattern_ID_ in self.Leveraged_Attack_Pattern_ID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Leveraged_Attack_Pattern_ID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Leveraged_Attack_Pattern_ID':
            Leveraged_Attack_Pattern_ID_ = child_.text
            Leveraged_Attack_Pattern_ID_ = self.gds_validate_string(Leveraged_Attack_Pattern_ID_, node, 'Leveraged_Attack_Pattern_ID')
            self.Leveraged_Attack_Pattern_ID.append(Leveraged_Attack_Pattern_ID_)
# end class Leveraged_Attack_Patterns


class Leveraged_Attack_Pattern_ID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Leveraged_Attack_Pattern_ID.subclass:
            return Leveraged_Attack_Pattern_ID.subclass(*args_, **kwargs_)
        else:
            return Leveraged_Attack_Pattern_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Leveraged_Attack_Pattern_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Leveraged_Attack_Pattern_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Leveraged_Attack_Pattern_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Leveraged_Attack_Pattern_ID', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Leveraged_Attack_Pattern_ID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Leveraged_Attack_Pattern_ID


class Relationships(GeneratedsSuper):
    """The Relationships structure contains one or more Relationship
    elements, each of which identifies an association between this
    structure, whether it is a Attack Pattern, Category, or
    Compound_Element and another structure."""
    subclass = None
    superclass = None
    def __init__(self, Relationship=None):
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
    def factory(*args_, **kwargs_):
        if Relationships.subclass:
            return Relationships.subclass(*args_, **kwargs_)
        else:
            return Relationships(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship(self, index, value): self.Relationship[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relationships', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationships')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationships'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationships', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, namespace_, name_='Relationship', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relationship
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationships'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.RelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='RelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship':
            obj_ = RelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
# end class Relationships


class RelationshipType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relationship_Views=None, Relationship_Chains=None, Relationship_Target_Form=None, Relationship_Nature=None, Relationship_Target_ID=None, Relationship_Description=None):
        self.Relationship_Views = Relationship_Views
        self.Relationship_Chains = Relationship_Chains
        self.Relationship_Target_Form = Relationship_Target_Form
        if Relationship_Nature is None:
            self.Relationship_Nature = []
        else:
            self.Relationship_Nature = Relationship_Nature
        self.Relationship_Target_ID = Relationship_Target_ID
        self.Relationship_Description = Relationship_Description
    def factory(*args_, **kwargs_):
        if RelationshipType.subclass:
            return RelationshipType.subclass(*args_, **kwargs_)
        else:
            return RelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship_Views(self): return self.Relationship_Views
    def set_Relationship_Views(self, Relationship_Views): self.Relationship_Views = Relationship_Views
    def get_Relationship_Chains(self): return self.Relationship_Chains
    def set_Relationship_Chains(self, Relationship_Chains): self.Relationship_Chains = Relationship_Chains
    def get_Relationship_Target_Form(self): return self.Relationship_Target_Form
    def set_Relationship_Target_Form(self, Relationship_Target_Form): self.Relationship_Target_Form = Relationship_Target_Form
    def get_Relationship_Nature(self): return self.Relationship_Nature
    def set_Relationship_Nature(self, Relationship_Nature): self.Relationship_Nature = Relationship_Nature
    def add_Relationship_Nature(self, value): self.Relationship_Nature.append(value)
    def insert_Relationship_Nature(self, index, value): self.Relationship_Nature[index] = value
    def get_Relationship_Target_ID(self): return self.Relationship_Target_ID
    def set_Relationship_Target_ID(self, Relationship_Target_ID): self.Relationship_Target_ID = Relationship_Target_ID
    def get_Relationship_Description(self): return self.Relationship_Description
    def set_Relationship_Description(self, Relationship_Description): self.Relationship_Description = Relationship_Description
    def export(self, outfile, level, namespace_='capec:', name_='RelationshipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='RelationshipType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='RelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Relationship_Views is not None:
            self.Relationship_Views.export(outfile, level, namespace_, name_='Relationship_Views', pretty_print=pretty_print)
        if self.Relationship_Chains is not None:
            self.Relationship_Chains.export(outfile, level, namespace_, name_='Relationship_Chains', pretty_print=pretty_print)
        if self.Relationship_Target_Form is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Target_Form>%s</%sRelationship_Target_Form>%s' % (namespace_, self.gds_format_string(quote_xml(self.Relationship_Target_Form).encode(ExternalEncoding), input_name='Relationship_Target_Form'), namespace_, eol_))
        for Relationship_Nature_ in self.Relationship_Nature:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Nature>%s</%sRelationship_Nature>%s' % (namespace_, self.gds_format_string(quote_xml(Relationship_Nature_).encode(ExternalEncoding), input_name='Relationship_Nature'), namespace_, eol_))
        if self.Relationship_Target_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Target_ID>%s</%sRelationship_Target_ID>%s' % (namespace_, self.gds_format_integer(self.Relationship_Target_ID, input_name='Relationship_Target_ID'), namespace_, eol_))
        if self.Relationship_Description is not None:
            self.Relationship_Description.export(outfile, level, namespace_, name_='Relationship_Description', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relationship_Views is not None or
            self.Relationship_Chains is not None or
            self.Relationship_Target_Form is not None or
            self.Relationship_Nature or
            self.Relationship_Target_ID is not None or
            self.Relationship_Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RelationshipType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Relationship_Views is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Views=model_.Relationship_Views(\n')
            self.Relationship_Views.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationship_Chains is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Chains=model_.Relationship_Chains(\n')
            self.Relationship_Chains.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationship_Target_Form is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Target_Form=%s,\n' % quote_python(self.Relationship_Target_Form).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Relationship_Nature=[\n')
        level += 1
        for Relationship_Nature_ in self.Relationship_Nature:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relationship_Nature_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Relationship_Target_ID is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Target_ID=%d,\n' % self.Relationship_Target_ID)
        if self.Relationship_Description is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Description=model_.Structured_Text_Type(\n')
            self.Relationship_Description.exportLiteral(outfile, level, name_='Relationship_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship_Views':
            obj_ = Relationship_Views.factory()
            obj_.build(child_)
            self.set_Relationship_Views(obj_)
        elif nodeName_ == 'Relationship_Chains':
            obj_ = Relationship_Chains.factory()
            obj_.build(child_)
            self.set_Relationship_Chains(obj_)
        elif nodeName_ == 'Relationship_Target_Form':
            Relationship_Target_Form_ = child_.text
            Relationship_Target_Form_ = self.gds_validate_string(Relationship_Target_Form_, node, 'Relationship_Target_Form')
            self.Relationship_Target_Form = Relationship_Target_Form_
        elif nodeName_ == 'Relationship_Nature':
            Relationship_Nature_ = child_.text
            Relationship_Nature_ = self.gds_validate_string(Relationship_Nature_, node, 'Relationship_Nature')
            self.Relationship_Nature.append(Relationship_Nature_)
        elif nodeName_ == 'Relationship_Target_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Relationship_Target_ID')
            self.Relationship_Target_ID = ival_
        elif nodeName_ == 'Relationship_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Relationship_Description(obj_)
# end class RelationshipType


class Relationship_Views(GeneratedsSuper):
    """This element contains a list of the individual Views to which this
    relationship pertains."""
    subclass = None
    superclass = None
    def __init__(self, Relationship_View_ID=None):
        if Relationship_View_ID is None:
            self.Relationship_View_ID = []
        else:
            self.Relationship_View_ID = Relationship_View_ID
    def factory(*args_, **kwargs_):
        if Relationship_Views.subclass:
            return Relationship_Views.subclass(*args_, **kwargs_)
        else:
            return Relationship_Views(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship_View_ID(self): return self.Relationship_View_ID
    def set_Relationship_View_ID(self, Relationship_View_ID): self.Relationship_View_ID = Relationship_View_ID
    def add_Relationship_View_ID(self, value): self.Relationship_View_ID.append(value)
    def insert_Relationship_View_ID(self, index, value): self.Relationship_View_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_Views', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_Views')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_Views'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_Views', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_View_ID_ in self.Relationship_View_ID:
            Relationship_View_ID_.export(outfile, level, namespace_, name_='Relationship_View_ID', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relationship_View_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_Views'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship_View_ID=[\n')
        level += 1
        for Relationship_View_ID_ in self.Relationship_View_ID:
            showIndent(outfile, level)
            outfile.write('model_.Relationship_View_ID(\n')
            Relationship_View_ID_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship_View_ID':
            obj_ = Relationship_View_ID.factory()
            obj_.build(child_)
            self.Relationship_View_ID.append(obj_)
# end class Relationship_Views


class Relationship_View_ID(GeneratedsSuper):
    """Specifies the unique ID of the individual view element to which this
    relationship pertains. This ID must correspond to a View. The
    ordinal attribute is used to determine if this relationship is
    the primary ChildOf relationship for this entry for a given
    Relationship_View_ID element.. This attribute can only have the
    value "Primary" and should only be included for the primary
    parent/child relationship."""
    subclass = None
    superclass = None
    def __init__(self, Ordinal=None, valueOf_=None):
        self.Ordinal = _cast(None, Ordinal)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Relationship_View_ID.subclass:
            return Relationship_View_ID.subclass(*args_, **kwargs_)
        else:
            return Relationship_View_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ordinal(self): return self.Ordinal
    def set_Ordinal(self, Ordinal): self.Ordinal = Ordinal
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_View_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_View_ID')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_View_ID'):
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.append('Ordinal')
            outfile.write(' Ordinal=%s' % (self.gds_format_string(quote_attrib(self.Ordinal).encode(ExternalEncoding), input_name='Ordinal'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_View_ID', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_View_ID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.append('Ordinal')
            showIndent(outfile, level)
            outfile.write('Ordinal = "%s",\n' % (self.Ordinal,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ordinal', node)
        if value is not None and 'Ordinal' not in already_processed:
            already_processed.append('Ordinal')
            self.Ordinal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relationship_View_ID


class Relationship_Chains(GeneratedsSuper):
    """This element contains a list of the individual Chains this
    relationship pertains to."""
    subclass = None
    superclass = None
    def __init__(self, Relationship_Chain_ID=None):
        if Relationship_Chain_ID is None:
            self.Relationship_Chain_ID = []
        else:
            self.Relationship_Chain_ID = Relationship_Chain_ID
    def factory(*args_, **kwargs_):
        if Relationship_Chains.subclass:
            return Relationship_Chains.subclass(*args_, **kwargs_)
        else:
            return Relationship_Chains(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship_Chain_ID(self): return self.Relationship_Chain_ID
    def set_Relationship_Chain_ID(self, Relationship_Chain_ID): self.Relationship_Chain_ID = Relationship_Chain_ID
    def add_Relationship_Chain_ID(self, value): self.Relationship_Chain_ID.append(value)
    def insert_Relationship_Chain_ID(self, index, value): self.Relationship_Chain_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_Chains', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_Chains')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_Chains'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_Chains', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_Chain_ID_ in self.Relationship_Chain_ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Chain_ID>%s</%sRelationship_Chain_ID>%s' % (namespace_, self.gds_format_integer(Relationship_Chain_ID_, input_name='Relationship_Chain_ID'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Relationship_Chain_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_Chains'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship_Chain_ID=[\n')
        level += 1
        for Relationship_Chain_ID_ in self.Relationship_Chain_ID:
            showIndent(outfile, level)
            outfile.write('%d,\n' % Relationship_Chain_ID_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship_Chain_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Relationship_Chain_ID')
            self.Relationship_Chain_ID.append(ival_)
# end class Relationship_Chains


class Relationship_Target_Form(GeneratedsSuper):
    """The Relationship_Target_Form element defines the form of the target
    of this relationship, such as Category, Attack Pattern, View or
    Compound_Element."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relationship_Target_Form.subclass:
            return Relationship_Target_Form.subclass(*args_, **kwargs_)
        else:
            return Relationship_Target_Form(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_Target_Form', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_Target_Form')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_Target_Form'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_Target_Form', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_Target_Form'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relationship_Target_Form


class Relationship_Nature(GeneratedsSuper):
    """The Relationship_Nature element defines the nature of the
    relationship between this element and the target element, such
    as ChildOf, HasMember or Requires to name a few."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relationship_Nature.subclass:
            return Relationship_Nature.subclass(*args_, **kwargs_)
        else:
            return Relationship_Nature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_Nature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_Nature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_Nature'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_Nature', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_Nature'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relationship_Nature


class Relationship_Notes(GeneratedsSuper):
    """This structure houses one or more Relationship_Note elements, which
    each contain details regarding the relationships between CAPEC
    entries."""
    subclass = None
    superclass = None
    def __init__(self, Relationship_Note=None):
        if Relationship_Note is None:
            self.Relationship_Note = []
        else:
            self.Relationship_Note = Relationship_Note
    def factory(*args_, **kwargs_):
        if Relationship_Notes.subclass:
            return Relationship_Notes.subclass(*args_, **kwargs_)
        else:
            return Relationship_Notes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship_Note(self): return self.Relationship_Note
    def set_Relationship_Note(self, Relationship_Note): self.Relationship_Note = Relationship_Note
    def add_Relationship_Note(self, value): self.Relationship_Note.append(value)
    def insert_Relationship_Note(self, index, value): self.Relationship_Note[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_Notes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_Notes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_Notes'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_Notes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_Note_ in self.Relationship_Note:
            Relationship_Note_.export(outfile, level, namespace_, name_='Relationship_Note', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relationship_Note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_Notes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship_Note=[\n')
        level += 1
        for Relationship_Note_ in self.Relationship_Note:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Relationship_Note_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship_Note':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Relationship_Note.append(obj_)
# end class Relationship_Notes


class Maintenance_Notes(GeneratedsSuper):
    """This element contains one or more Maintenance_Note elements which
    each contain significant maintenance tasks within this entry
    that still need to be addressed, such as clarifying the concepts
    involved or improving relationships. It should be filled out in
    any entry that is still undergoing significant review by the
    CAPEC team."""
    subclass = None
    superclass = None
    def __init__(self, Maintenance_Note=None):
        if Maintenance_Note is None:
            self.Maintenance_Note = []
        else:
            self.Maintenance_Note = Maintenance_Note
    def factory(*args_, **kwargs_):
        if Maintenance_Notes.subclass:
            return Maintenance_Notes.subclass(*args_, **kwargs_)
        else:
            return Maintenance_Notes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Maintenance_Note(self): return self.Maintenance_Note
    def set_Maintenance_Note(self, Maintenance_Note): self.Maintenance_Note = Maintenance_Note
    def add_Maintenance_Note(self, value): self.Maintenance_Note.append(value)
    def insert_Maintenance_Note(self, index, value): self.Maintenance_Note[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Maintenance_Notes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Maintenance_Notes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Maintenance_Notes'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Maintenance_Notes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Maintenance_Note_ in self.Maintenance_Note:
            Maintenance_Note_.export(outfile, level, namespace_, name_='Maintenance_Note', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Maintenance_Note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Maintenance_Notes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Maintenance_Note=[\n')
        level += 1
        for Maintenance_Note_ in self.Maintenance_Note:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Maintenance_Note_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Maintenance_Note':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Maintenance_Note.append(obj_)
# end class Maintenance_Notes


class Other_Notes(GeneratedsSuper):
    """This element contains one or more Note elements, each of which
    provide any additional notes or comments that cannot be captured
    using other elements. New elements might be defined in the
    future to contain this information. It should be filled out
    where needed."""
    subclass = None
    superclass = None
    def __init__(self, Note=None):
        if Note is None:
            self.Note = []
        else:
            self.Note = Note
    def factory(*args_, **kwargs_):
        if Other_Notes.subclass:
            return Other_Notes.subclass(*args_, **kwargs_)
        else:
            return Other_Notes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Note(self): return self.Note
    def set_Note(self, Note): self.Note = Note
    def add_Note(self, value): self.Note.append(value)
    def insert_Note(self, index, value): self.Note[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Other_Notes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Other_Notes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Other_Notes'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Other_Notes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Note_ in self.Note:
            Note_.export(outfile, level, namespace_, name_='Note', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Other_Notes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Note=[\n')
        level += 1
        for Note_ in self.Note:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Note_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Note':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Note.append(obj_)
# end class Other_Notes


class Alternate_Terms(GeneratedsSuper):
    """This element contains one or more Alternate_Term elements, each of
    which contains other names used to describe this attack pattern."""
    subclass = None
    superclass = None
    def __init__(self, Alternate_Term=None):
        if Alternate_Term is None:
            self.Alternate_Term = []
        else:
            self.Alternate_Term = Alternate_Term
    def factory(*args_, **kwargs_):
        if Alternate_Terms.subclass:
            return Alternate_Terms.subclass(*args_, **kwargs_)
        else:
            return Alternate_Terms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Alternate_Term(self): return self.Alternate_Term
    def set_Alternate_Term(self, Alternate_Term): self.Alternate_Term = Alternate_Term
    def add_Alternate_Term(self, value): self.Alternate_Term.append(value)
    def insert_Alternate_Term(self, index, value): self.Alternate_Term[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Alternate_Terms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Alternate_Terms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Alternate_Terms'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Alternate_Terms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Alternate_Term_ in self.Alternate_Term:
            Alternate_Term_.export(outfile, level, namespace_, name_='Alternate_Term', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Alternate_Term
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Alternate_Terms'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Alternate_Term=[\n')
        level += 1
        for Alternate_Term_ in self.Alternate_Term:
            showIndent(outfile, level)
            outfile.write('model_.Alternate_Term(\n')
            Alternate_Term_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Alternate_Term':
            obj_ = Alternate_Term.factory()
            obj_.build(child_)
            self.Alternate_Term.append(obj_)
# end class Alternate_Terms


class Alternate_Term(GeneratedsSuper):
    """This element contains alternate terms by which this attack pattern
    may be known and a description to explain the context in which
    the term may be relevant. This is not required for all entries
    and should only be included where appropriate."""
    subclass = None
    superclass = None
    def __init__(self, Term=None, Alternate_Term_Description=None):
        self.Term = Term
        self.Alternate_Term_Description = Alternate_Term_Description
    def factory(*args_, **kwargs_):
        if Alternate_Term.subclass:
            return Alternate_Term.subclass(*args_, **kwargs_)
        else:
            return Alternate_Term(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Term(self): return self.Term
    def set_Term(self, Term): self.Term = Term
    def get_Alternate_Term_Description(self): return self.Alternate_Term_Description
    def set_Alternate_Term_Description(self, Alternate_Term_Description): self.Alternate_Term_Description = Alternate_Term_Description
    def export(self, outfile, level, namespace_='capec:', name_='Alternate_Term', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Alternate_Term')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Alternate_Term'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Alternate_Term', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Term is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTerm>%s</%sTerm>%s' % (namespace_, self.gds_format_string(quote_xml(self.Term).encode(ExternalEncoding), input_name='Term'), namespace_, eol_))
        if self.Alternate_Term_Description is not None:
            self.Alternate_Term_Description.export(outfile, level, namespace_, name_='Alternate_Term_Description', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Term is not None or
            self.Alternate_Term_Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Alternate_Term'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Term is not None:
            showIndent(outfile, level)
            outfile.write('Term=%s,\n' % quote_python(self.Term).encode(ExternalEncoding))
        if self.Alternate_Term_Description is not None:
            showIndent(outfile, level)
            outfile.write('Alternate_Term_Description=model_.Structured_Text_Type(\n')
            self.Alternate_Term_Description.exportLiteral(outfile, level, name_='Alternate_Term_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Term':
            Term_ = child_.text
            Term_ = self.gds_validate_string(Term_, node, 'Term')
            self.Term = Term_
        elif nodeName_ == 'Alternate_Term_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Alternate_Term_Description(obj_)
# end class Alternate_Term


class Research_Gaps(GeneratedsSuper):
    """This structure contains one or more Research gap elements, each of
    which identifies potential opportunities for the attack research
    community to conduct further exploration of issues related to
    this attack pattern. It is intended to highlight parts of CAPEC
    that have not received sufficient attention from researchers.
    This should be filled out where appropriate for attack patterns
    and categories."""
    subclass = None
    superclass = None
    def __init__(self, Research_Gap=None):
        if Research_Gap is None:
            self.Research_Gap = []
        else:
            self.Research_Gap = Research_Gap
    def factory(*args_, **kwargs_):
        if Research_Gaps.subclass:
            return Research_Gaps.subclass(*args_, **kwargs_)
        else:
            return Research_Gaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Research_Gap(self): return self.Research_Gap
    def set_Research_Gap(self, Research_Gap): self.Research_Gap = Research_Gap
    def add_Research_Gap(self, value): self.Research_Gap.append(value)
    def insert_Research_Gap(self, index, value): self.Research_Gap[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Research_Gaps', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Research_Gaps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Research_Gaps'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Research_Gaps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Research_Gap_ in self.Research_Gap:
            Research_Gap_.export(outfile, level, namespace_, name_='Research_Gap', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Research_Gap
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Research_Gaps'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Research_Gap=[\n')
        level += 1
        for Research_Gap_ in self.Research_Gap:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Research_Gap_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Research_Gap':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Research_Gap.append(obj_)
# end class Research_Gaps


class Content_History(GeneratedsSuper):
    """This element is used to keep track of the author of the attack
    pattern entry and anyone who has made modifications to the
    content. This provides a means of contacting the authors and
    modifiers for clarifying ambiguities, merging overlapping
    contributions, etc. This should be filled out for all entries."""
    subclass = None
    superclass = None
    def __init__(self, Submissions=None, Contributions=None, Modifications=None, Previous_Entry_Names=None):
        self.Submissions = Submissions
        self.Contributions = Contributions
        self.Modifications = Modifications
        self.Previous_Entry_Names = Previous_Entry_Names
    def factory(*args_, **kwargs_):
        if Content_History.subclass:
            return Content_History.subclass(*args_, **kwargs_)
        else:
            return Content_History(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Submissions(self): return self.Submissions
    def set_Submissions(self, Submissions): self.Submissions = Submissions
    def get_Contributions(self): return self.Contributions
    def set_Contributions(self, Contributions): self.Contributions = Contributions
    def get_Modifications(self): return self.Modifications
    def set_Modifications(self, Modifications): self.Modifications = Modifications
    def get_Previous_Entry_Names(self): return self.Previous_Entry_Names
    def set_Previous_Entry_Names(self, Previous_Entry_Names): self.Previous_Entry_Names = Previous_Entry_Names
    def export(self, outfile, level, namespace_='capec:', name_='Content_History', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Content_History')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Content_History'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Content_History', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Submissions is not None:
            self.Submissions.export(outfile, level, namespace_, name_='Submissions', pretty_print=pretty_print)
        if self.Contributions is not None:
            self.Contributions.export(outfile, level, namespace_, name_='Contributions', pretty_print=pretty_print)
        if self.Modifications is not None:
            self.Modifications.export(outfile, level, namespace_, name_='Modifications', pretty_print=pretty_print)
        if self.Previous_Entry_Names is not None:
            self.Previous_Entry_Names.export(outfile, level, namespace_, name_='Previous_Entry_Names', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Submissions is not None or
            self.Contributions is not None or
            self.Modifications is not None or
            self.Previous_Entry_Names is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Content_History'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Submissions is not None:
            showIndent(outfile, level)
            outfile.write('Submissions=model_.Submissions(\n')
            self.Submissions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Contributions is not None:
            showIndent(outfile, level)
            outfile.write('Contributions=model_.Contributions(\n')
            self.Contributions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Modifications is not None:
            showIndent(outfile, level)
            outfile.write('Modifications=model_.Modifications(\n')
            self.Modifications.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Previous_Entry_Names is not None:
            showIndent(outfile, level)
            outfile.write('Previous_Entry_Names=model_.Previous_Entry_Names(\n')
            self.Previous_Entry_Names.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Submissions':
            obj_ = Submissions.factory()
            obj_.build(child_)
            self.set_Submissions(obj_)
        elif nodeName_ == 'Contributions':
            obj_ = Contributions.factory()
            obj_.build(child_)
            self.set_Contributions(obj_)
        elif nodeName_ == 'Modifications':
            obj_ = Modifications.factory()
            obj_.build(child_)
            self.set_Modifications(obj_)
        elif nodeName_ == 'Previous_Entry_Names':
            obj_ = Previous_Entry_Names.factory()
            obj_.build(child_)
            self.set_Previous_Entry_Names(obj_)
# end class Content_History


class Submissions(GeneratedsSuper):
    """This structure contains one or more Submission elements."""
    subclass = None
    superclass = None
    def __init__(self, Submission=None):
        if Submission is None:
            self.Submission = []
        else:
            self.Submission = Submission
    def factory(*args_, **kwargs_):
        if Submissions.subclass:
            return Submissions.subclass(*args_, **kwargs_)
        else:
            return Submissions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Submission(self): return self.Submission
    def set_Submission(self, Submission): self.Submission = Submission
    def add_Submission(self, value): self.Submission.append(value)
    def insert_Submission(self, index, value): self.Submission[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Submissions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Submissions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Submissions'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Submissions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Submission_ in self.Submission:
            Submission_.export(outfile, level, namespace_, name_='Submission', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Submission
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Submissions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Submission=[\n')
        level += 1
        for Submission_ in self.Submission:
            showIndent(outfile, level)
            outfile.write('model_.Submission(\n')
            Submission_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Submission':
            obj_ = Submission.factory()
            obj_.build(child_)
            self.Submission.append(obj_)
# end class Submissions


class Submission(GeneratedsSuper):
    """This element houses the subelements which identify the submitter and
    the submitter's comments related to this entry. This element has
    a single attribute, Submission_Source, which provides a general
    idea of how the initial information for this entry was obtained,
    whether internal to the CAPEC team, external, donated, etc. This
    attribute identifies how the initial information for this entry
    was obtained."""
    subclass = None
    superclass = None
    def __init__(self, Submission_Source=None, Submitter=None, Submitter_Organization=None, Submission_Date=None, Submission_Comment=None):
        self.Submission_Source = _cast(None, Submission_Source)
        self.Submitter = Submitter
        self.Submitter_Organization = Submitter_Organization
        self.Submission_Date = Submission_Date
        self.Submission_Comment = Submission_Comment
    def factory(*args_, **kwargs_):
        if Submission.subclass:
            return Submission.subclass(*args_, **kwargs_)
        else:
            return Submission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Submitter(self): return self.Submitter
    def set_Submitter(self, Submitter): self.Submitter = Submitter
    def get_Submitter_Organization(self): return self.Submitter_Organization
    def set_Submitter_Organization(self, Submitter_Organization): self.Submitter_Organization = Submitter_Organization
    def get_Submission_Date(self): return self.Submission_Date
    def set_Submission_Date(self, Submission_Date): self.Submission_Date = Submission_Date
    def get_Submission_Comment(self): return self.Submission_Comment
    def set_Submission_Comment(self, Submission_Comment): self.Submission_Comment = Submission_Comment
    def get_Submission_Source(self): return self.Submission_Source
    def set_Submission_Source(self, Submission_Source): self.Submission_Source = Submission_Source
    def export(self, outfile, level, namespace_='capec:', name_='Submission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Submission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Submission'):
        if self.Submission_Source is not None and 'Submission_Source' not in already_processed:
            already_processed.append('Submission_Source')
            outfile.write(' Submission_Source=%s' % (self.gds_format_string(quote_attrib(self.Submission_Source).encode(ExternalEncoding), input_name='Submission_Source'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Submission', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Submitter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmitter>%s</%sSubmitter>%s' % (namespace_, self.gds_format_string(quote_xml(self.Submitter).encode(ExternalEncoding), input_name='Submitter'), namespace_, eol_))
        if self.Submitter_Organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmitter_Organization>%s</%sSubmitter_Organization>%s' % (namespace_, self.gds_format_string(quote_xml(self.Submitter_Organization).encode(ExternalEncoding), input_name='Submitter_Organization'), namespace_, eol_))
        if self.Submission_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmission_Date>%s</%sSubmission_Date>%s' % (namespace_, self.gds_format_string(quote_xml(self.Submission_Date).encode(ExternalEncoding), input_name='Submission_Date'), namespace_, eol_))
        if self.Submission_Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubmission_Comment>%s</%sSubmission_Comment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Submission_Comment).encode(ExternalEncoding), input_name='Submission_Comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Submitter is not None or
            self.Submitter_Organization is not None or
            self.Submission_Date is not None or
            self.Submission_Comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Submission'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Submission_Source is not None and 'Submission_Source' not in already_processed:
            already_processed.append('Submission_Source')
            showIndent(outfile, level)
            outfile.write('Submission_Source = "%s",\n' % (self.Submission_Source,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Submitter is not None:
            showIndent(outfile, level)
            outfile.write('Submitter=%s,\n' % quote_python(self.Submitter).encode(ExternalEncoding))
        if self.Submitter_Organization is not None:
            showIndent(outfile, level)
            outfile.write('Submitter_Organization=%s,\n' % quote_python(self.Submitter_Organization).encode(ExternalEncoding))
        if self.Submission_Date is not None:
            showIndent(outfile, level)
            outfile.write('Submission_Date=%s,\n' % quote_python(self.Submission_Date).encode(ExternalEncoding))
        if self.Submission_Comment is not None:
            showIndent(outfile, level)
            outfile.write('Submission_Comment=%s,\n' % quote_python(self.Submission_Comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Submission_Source', node)
        if value is not None and 'Submission_Source' not in already_processed:
            already_processed.append('Submission_Source')
            self.Submission_Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Submitter':
            Submitter_ = child_.text
            Submitter_ = self.gds_validate_string(Submitter_, node, 'Submitter')
            self.Submitter = Submitter_
        elif nodeName_ == 'Submitter_Organization':
            Submitter_Organization_ = child_.text
            Submitter_Organization_ = self.gds_validate_string(Submitter_Organization_, node, 'Submitter_Organization')
            self.Submitter_Organization = Submitter_Organization_
        elif nodeName_ == 'Submission_Date':
            Submission_Date_ = child_.text
            Submission_Date_ = self.gds_validate_string(Submission_Date_, node, 'Submission_Date')
            self.Submission_Date = Submission_Date_
        elif nodeName_ == 'Submission_Comment':
            Submission_Comment_ = child_.text
            Submission_Comment_ = self.gds_validate_string(Submission_Comment_, node, 'Submission_Comment')
            self.Submission_Comment = Submission_Comment_
# end class Submission


class Contributions(GeneratedsSuper):
    """This structure contains one or more Contribution elements."""
    subclass = None
    superclass = None
    def __init__(self, Contribution=None):
        if Contribution is None:
            self.Contribution = []
        else:
            self.Contribution = Contribution
    def factory(*args_, **kwargs_):
        if Contributions.subclass:
            return Contributions.subclass(*args_, **kwargs_)
        else:
            return Contributions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Contribution(self): return self.Contribution
    def set_Contribution(self, Contribution): self.Contribution = Contribution
    def add_Contribution(self, value): self.Contribution.append(value)
    def insert_Contribution(self, index, value): self.Contribution[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Contributions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Contributions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Contributions'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Contributions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Contribution_ in self.Contribution:
            Contribution_.export(outfile, level, namespace_, name_='Contribution', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Contribution
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Contributions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Contribution=[\n')
        level += 1
        for Contribution_ in self.Contribution:
            showIndent(outfile, level)
            outfile.write('model_.Contribution(\n')
            Contribution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Contribution':
            obj_ = Contribution.factory()
            obj_.build(child_)
            self.Contribution.append(obj_)
# end class Contributions


class Contribution(GeneratedsSuper):
    """This element houses the subelements which identify the contributor
    and contributor's comments related to this entry. This element
    has a single attribute, Contribution_Mode, which indicates
    whether the contribution was part of feedback given to the CAPEC
    team or actual content that was donated. This attribute
    indicates whether the contribution was part of feedback given to
    the CAPEC team or actual content that was donated."""
    subclass = None
    superclass = None
    def __init__(self, Contribution_Mode=None, Contributor=None, Contribution_Organization=None, Contribution_Date=None, Contribution_Comment=None):
        self.Contribution_Mode = _cast(None, Contribution_Mode)
        self.Contributor = Contributor
        self.Contribution_Organization = Contribution_Organization
        self.Contribution_Date = Contribution_Date
        self.Contribution_Comment = Contribution_Comment
    def factory(*args_, **kwargs_):
        if Contribution.subclass:
            return Contribution.subclass(*args_, **kwargs_)
        else:
            return Contribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Contributor(self): return self.Contributor
    def set_Contributor(self, Contributor): self.Contributor = Contributor
    def get_Contribution_Organization(self): return self.Contribution_Organization
    def set_Contribution_Organization(self, Contribution_Organization): self.Contribution_Organization = Contribution_Organization
    def get_Contribution_Date(self): return self.Contribution_Date
    def set_Contribution_Date(self, Contribution_Date): self.Contribution_Date = Contribution_Date
    def get_Contribution_Comment(self): return self.Contribution_Comment
    def set_Contribution_Comment(self, Contribution_Comment): self.Contribution_Comment = Contribution_Comment
    def get_Contribution_Mode(self): return self.Contribution_Mode
    def set_Contribution_Mode(self, Contribution_Mode): self.Contribution_Mode = Contribution_Mode
    def export(self, outfile, level, namespace_='capec:', name_='Contribution', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Contribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Contribution'):
        if self.Contribution_Mode is not None and 'Contribution_Mode' not in already_processed:
            already_processed.append('Contribution_Mode')
            outfile.write(' Contribution_Mode=%s' % (self.gds_format_string(quote_attrib(self.Contribution_Mode).encode(ExternalEncoding), input_name='Contribution_Mode'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Contribution', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Contributor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContributor>%s</%sContributor>%s' % (namespace_, self.gds_format_string(quote_xml(self.Contributor).encode(ExternalEncoding), input_name='Contributor'), namespace_, eol_))
        if self.Contribution_Organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContribution_Organization>%s</%sContribution_Organization>%s' % (namespace_, self.gds_format_string(quote_xml(self.Contribution_Organization).encode(ExternalEncoding), input_name='Contribution_Organization'), namespace_, eol_))
        if self.Contribution_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContribution_Date>%s</%sContribution_Date>%s' % (namespace_, self.gds_format_string(quote_xml(self.Contribution_Date).encode(ExternalEncoding), input_name='Contribution_Date'), namespace_, eol_))
        if self.Contribution_Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sContribution_Comment>%s</%sContribution_Comment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Contribution_Comment).encode(ExternalEncoding), input_name='Contribution_Comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Contributor is not None or
            self.Contribution_Organization is not None or
            self.Contribution_Date is not None or
            self.Contribution_Comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Contribution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Contribution_Mode is not None and 'Contribution_Mode' not in already_processed:
            already_processed.append('Contribution_Mode')
            showIndent(outfile, level)
            outfile.write('Contribution_Mode = "%s",\n' % (self.Contribution_Mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Contributor is not None:
            showIndent(outfile, level)
            outfile.write('Contributor=%s,\n' % quote_python(self.Contributor).encode(ExternalEncoding))
        if self.Contribution_Organization is not None:
            showIndent(outfile, level)
            outfile.write('Contribution_Organization=%s,\n' % quote_python(self.Contribution_Organization).encode(ExternalEncoding))
        if self.Contribution_Date is not None:
            showIndent(outfile, level)
            outfile.write('Contribution_Date=%s,\n' % quote_python(self.Contribution_Date).encode(ExternalEncoding))
        if self.Contribution_Comment is not None:
            showIndent(outfile, level)
            outfile.write('Contribution_Comment=%s,\n' % quote_python(self.Contribution_Comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Contribution_Mode', node)
        if value is not None and 'Contribution_Mode' not in already_processed:
            already_processed.append('Contribution_Mode')
            self.Contribution_Mode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Contributor':
            Contributor_ = child_.text
            Contributor_ = self.gds_validate_string(Contributor_, node, 'Contributor')
            self.Contributor = Contributor_
        elif nodeName_ == 'Contribution_Organization':
            Contribution_Organization_ = child_.text
            Contribution_Organization_ = self.gds_validate_string(Contribution_Organization_, node, 'Contribution_Organization')
            self.Contribution_Organization = Contribution_Organization_
        elif nodeName_ == 'Contribution_Date':
            Contribution_Date_ = child_.text
            Contribution_Date_ = self.gds_validate_string(Contribution_Date_, node, 'Contribution_Date')
            self.Contribution_Date = Contribution_Date_
        elif nodeName_ == 'Contribution_Comment':
            Contribution_Comment_ = child_.text
            Contribution_Comment_ = self.gds_validate_string(Contribution_Comment_, node, 'Contribution_Comment')
            self.Contribution_Comment = Contribution_Comment_
# end class Contribution


class Modifications(GeneratedsSuper):
    """This structure contains one or more Modification elements."""
    subclass = None
    superclass = None
    def __init__(self, Modification=None):
        if Modification is None:
            self.Modification = []
        else:
            self.Modification = Modification
    def factory(*args_, **kwargs_):
        if Modifications.subclass:
            return Modifications.subclass(*args_, **kwargs_)
        else:
            return Modifications(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Modification(self): return self.Modification
    def set_Modification(self, Modification): self.Modification = Modification
    def add_Modification(self, value): self.Modification.append(value)
    def insert_Modification(self, index, value): self.Modification[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Modifications', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Modifications')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Modifications'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Modifications', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Modification_ in self.Modification:
            Modification_.export(outfile, level, namespace_, name_='Modification', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Modification
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Modifications'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Modification=[\n')
        level += 1
        for Modification_ in self.Modification:
            showIndent(outfile, level)
            outfile.write('model_.Modification(\n')
            Modification_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Modification':
            obj_ = Modification.factory()
            obj_.build(child_)
            self.Modification.append(obj_)
# end class Modifications


class Modification(GeneratedsSuper):
    """This element houses the subelements which identify the modifier and
    modifier's comments related to this entry. A new Modification
    element should exist for each modification of the entry content.
    This element has a single attribute, Modification_Source, which
    indicates whether this modification was made by a CAPEC team
    member or an external party. This attribute identifies how
    significant the modification is to the attack pattern with
    regard to the meaning and interpretation of the pattern. If a
    modification has a value of Critical, then the meaning of the
    entry or how it might be interpreted has changed and requires
    attention from anyone previously dependent on the attack
    pattern. This attribute indicates whether this modification was
    created by a CAPEC team member or provided by an external party."""
    subclass = None
    superclass = None
    def __init__(self, Modification_Importance=None, Modification_Source=None, Modifier=None, Modifier_Organization=None, Modification_Date=None, Modification_Comment=None):
        self.Modification_Importance = _cast(None, Modification_Importance)
        self.Modification_Source = _cast(None, Modification_Source)
        self.Modifier = Modifier
        self.Modifier_Organization = Modifier_Organization
        self.Modification_Date = Modification_Date
        self.Modification_Comment = Modification_Comment
    def factory(*args_, **kwargs_):
        if Modification.subclass:
            return Modification.subclass(*args_, **kwargs_)
        else:
            return Modification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Modifier(self): return self.Modifier
    def set_Modifier(self, Modifier): self.Modifier = Modifier
    def get_Modifier_Organization(self): return self.Modifier_Organization
    def set_Modifier_Organization(self, Modifier_Organization): self.Modifier_Organization = Modifier_Organization
    def get_Modification_Date(self): return self.Modification_Date
    def set_Modification_Date(self, Modification_Date): self.Modification_Date = Modification_Date
    def get_Modification_Comment(self): return self.Modification_Comment
    def set_Modification_Comment(self, Modification_Comment): self.Modification_Comment = Modification_Comment
    def get_Modification_Importance(self): return self.Modification_Importance
    def set_Modification_Importance(self, Modification_Importance): self.Modification_Importance = Modification_Importance
    def get_Modification_Source(self): return self.Modification_Source
    def set_Modification_Source(self, Modification_Source): self.Modification_Source = Modification_Source
    def export(self, outfile, level, namespace_='capec:', name_='Modification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Modification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Modification'):
        if self.Modification_Importance is not None and 'Modification_Importance' not in already_processed:
            already_processed.append('Modification_Importance')
            outfile.write(' Modification_Importance=%s' % (self.gds_format_string(quote_attrib(self.Modification_Importance).encode(ExternalEncoding), input_name='Modification_Importance'), ))
        if self.Modification_Source is not None and 'Modification_Source' not in already_processed:
            already_processed.append('Modification_Source')
            outfile.write(' Modification_Source=%s' % (self.gds_format_string(quote_attrib(self.Modification_Source).encode(ExternalEncoding), input_name='Modification_Source'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Modification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Modifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModifier>%s</%sModifier>%s' % (namespace_, self.gds_format_string(quote_xml(self.Modifier).encode(ExternalEncoding), input_name='Modifier'), namespace_, eol_))
        if self.Modifier_Organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModifier_Organization>%s</%sModifier_Organization>%s' % (namespace_, self.gds_format_string(quote_xml(self.Modifier_Organization).encode(ExternalEncoding), input_name='Modifier_Organization'), namespace_, eol_))
        if self.Modification_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModification_Date>%s</%sModification_Date>%s' % (namespace_, self.gds_format_string(quote_xml(self.Modification_Date).encode(ExternalEncoding), input_name='Modification_Date'), namespace_, eol_))
        if self.Modification_Comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModification_Comment>%s</%sModification_Comment>%s' % (namespace_, self.gds_format_string(quote_xml(self.Modification_Comment).encode(ExternalEncoding), input_name='Modification_Comment'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Modifier is not None or
            self.Modifier_Organization is not None or
            self.Modification_Date is not None or
            self.Modification_Comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Modification'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Modification_Importance is not None and 'Modification_Importance' not in already_processed:
            already_processed.append('Modification_Importance')
            showIndent(outfile, level)
            outfile.write('Modification_Importance = "%s",\n' % (self.Modification_Importance,))
        if self.Modification_Source is not None and 'Modification_Source' not in already_processed:
            already_processed.append('Modification_Source')
            showIndent(outfile, level)
            outfile.write('Modification_Source = "%s",\n' % (self.Modification_Source,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Modifier is not None:
            showIndent(outfile, level)
            outfile.write('Modifier=%s,\n' % quote_python(self.Modifier).encode(ExternalEncoding))
        if self.Modifier_Organization is not None:
            showIndent(outfile, level)
            outfile.write('Modifier_Organization=%s,\n' % quote_python(self.Modifier_Organization).encode(ExternalEncoding))
        if self.Modification_Date is not None:
            showIndent(outfile, level)
            outfile.write('Modification_Date=%s,\n' % quote_python(self.Modification_Date).encode(ExternalEncoding))
        if self.Modification_Comment is not None:
            showIndent(outfile, level)
            outfile.write('Modification_Comment=%s,\n' % quote_python(self.Modification_Comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Modification_Importance', node)
        if value is not None and 'Modification_Importance' not in already_processed:
            already_processed.append('Modification_Importance')
            self.Modification_Importance = value
        value = find_attr_value_('Modification_Source', node)
        if value is not None and 'Modification_Source' not in already_processed:
            already_processed.append('Modification_Source')
            self.Modification_Source = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Modifier':
            Modifier_ = child_.text
            Modifier_ = self.gds_validate_string(Modifier_, node, 'Modifier')
            self.Modifier = Modifier_
        elif nodeName_ == 'Modifier_Organization':
            Modifier_Organization_ = child_.text
            Modifier_Organization_ = self.gds_validate_string(Modifier_Organization_, node, 'Modifier_Organization')
            self.Modifier_Organization = Modifier_Organization_
        elif nodeName_ == 'Modification_Date':
            Modification_Date_ = child_.text
            Modification_Date_ = self.gds_validate_string(Modification_Date_, node, 'Modification_Date')
            self.Modification_Date = Modification_Date_
        elif nodeName_ == 'Modification_Comment':
            Modification_Comment_ = child_.text
            Modification_Comment_ = self.gds_validate_string(Modification_Comment_, node, 'Modification_Comment')
            self.Modification_Comment = Modification_Comment_
# end class Modification


class Previous_Entry_Names(GeneratedsSuper):
    """This structure contains one or more Previous_Entry_Name elements,
    each of which describes a previous name that was used for this
    entry. This should be filled out whenever a substantive name
    change occurs."""
    subclass = None
    superclass = None
    def __init__(self, Previous_Entry_Name=None):
        if Previous_Entry_Name is None:
            self.Previous_Entry_Name = []
        else:
            self.Previous_Entry_Name = Previous_Entry_Name
    def factory(*args_, **kwargs_):
        if Previous_Entry_Names.subclass:
            return Previous_Entry_Names.subclass(*args_, **kwargs_)
        else:
            return Previous_Entry_Names(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Previous_Entry_Name(self): return self.Previous_Entry_Name
    def set_Previous_Entry_Name(self, Previous_Entry_Name): self.Previous_Entry_Name = Previous_Entry_Name
    def add_Previous_Entry_Name(self, value): self.Previous_Entry_Name.append(value)
    def insert_Previous_Entry_Name(self, index, value): self.Previous_Entry_Name[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Previous_Entry_Names', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Previous_Entry_Names')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Previous_Entry_Names'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Previous_Entry_Names', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Previous_Entry_Name_ in self.Previous_Entry_Name:
            Previous_Entry_Name_.export(outfile, level, namespace_, name_='Previous_Entry_Name', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Previous_Entry_Name
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Previous_Entry_Names'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Previous_Entry_Name=[\n')
        level += 1
        for Previous_Entry_Name_ in self.Previous_Entry_Name:
            showIndent(outfile, level)
            outfile.write('model_.Previous_Entry_Name(\n')
            Previous_Entry_Name_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Previous_Entry_Name':
            obj_ = Previous_Entry_Name.factory()
            obj_.build(child_)
            self.Previous_Entry_Name.append(obj_)
# end class Previous_Entry_Names


class Previous_Entry_Name(GeneratedsSuper):
    """This element identifies a name that was previously used for this
    entry.This lists the date on which this name was changed to
    something else. Typically, this date will be closely aligned
    with new releases of CAPEC."""
    subclass = None
    superclass = None
    def __init__(self, Name_Change_Date=None, valueOf_=None):
        self.Name_Change_Date = _cast(None, Name_Change_Date)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Previous_Entry_Name.subclass:
            return Previous_Entry_Name.subclass(*args_, **kwargs_)
        else:
            return Previous_Entry_Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name_Change_Date(self): return self.Name_Change_Date
    def set_Name_Change_Date(self, Name_Change_Date): self.Name_Change_Date = Name_Change_Date
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='capec:', name_='Previous_Entry_Name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Previous_Entry_Name')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Previous_Entry_Name'):
        if self.Name_Change_Date is not None and 'Name_Change_Date' not in already_processed:
            already_processed.append('Name_Change_Date')
            outfile.write(' Name_Change_Date=%s' % (self.gds_format_string(quote_attrib(self.Name_Change_Date).encode(ExternalEncoding), input_name='Name_Change_Date'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Previous_Entry_Name', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Previous_Entry_Name'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name_Change_Date is not None and 'Name_Change_Date' not in already_processed:
            already_processed.append('Name_Change_Date')
            showIndent(outfile, level)
            outfile.write('Name_Change_Date = "%s",\n' % (self.Name_Change_Date,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name_Change_Date', node)
        if value is not None and 'Name_Change_Date' not in already_processed:
            already_processed.append('Name_Change_Date')
            self.Name_Change_Date = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Previous_Entry_Name


class ObservablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Observable=None):
        if Observable is None:
            self.Observable = []
        else:
            self.Observable = Observable
    def factory(*args_, **kwargs_):
        if ObservablesType.subclass:
            return ObservablesType.subclass(*args_, **kwargs_)
        else:
            return ObservablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Observable(self): return self.Observable
    def set_Observable(self, Observable): self.Observable = Observable
    def add_Observable(self, value): self.Observable.append(value)
    def insert_Observable(self, index, value): self.Observable[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='ObservablesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObservablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='ObservablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='ObservablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Observable_ in self.Observable:
            Observable_.export(outfile, level, namespace_, name_='Observable', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Observable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObservablesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Observable=[\n')
        level += 1
        for Observable_ in self.Observable:
            showIndent(outfile, level)
            outfile.write('model_.Observable(\n')
            Observable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Observable':
            obj_ = Observable.factory()
            obj_.build(child_)
            self.Observable.append(obj_)
# end class ObservablesType


class Observable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Signature=None, Noisiness=None, Ease_of_Obfuscation=None, Obfuscation_Techniques=None):
        self.Signature = Signature
        self.Noisiness = Noisiness
        self.Ease_of_Obfuscation = Ease_of_Obfuscation
        self.Obfuscation_Techniques = Obfuscation_Techniques
    def factory(*args_, **kwargs_):
        if Observable.subclass:
            return Observable.subclass(*args_, **kwargs_)
        else:
            return Observable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_Noisiness(self): return self.Noisiness
    def set_Noisiness(self, Noisiness): self.Noisiness = Noisiness
    def get_Ease_of_Obfuscation(self): return self.Ease_of_Obfuscation
    def set_Ease_of_Obfuscation(self, Ease_of_Obfuscation): self.Ease_of_Obfuscation = Ease_of_Obfuscation
    def get_Obfuscation_Techniques(self): return self.Obfuscation_Techniques
    def set_Obfuscation_Techniques(self, Obfuscation_Techniques): self.Obfuscation_Techniques = Obfuscation_Techniques
    def export(self, outfile, level, namespace_='capec:', name_='Observable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Observable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Observable'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Observable', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespace_, name_='Signature', pretty_print=pretty_print)
        if self.Noisiness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNoisiness>%s</%sNoisiness>%s' % (namespace_, self.gds_format_string(quote_xml(self.Noisiness).encode(ExternalEncoding), input_name='Noisiness'), namespace_, eol_))
        if self.Ease_of_Obfuscation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEase_of_Obfuscation>%s</%sEase_of_Obfuscation>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ease_of_Obfuscation).encode(ExternalEncoding), input_name='Ease_of_Obfuscation'), namespace_, eol_))
        if self.Obfuscation_Techniques is not None:
            self.Obfuscation_Techniques.export(outfile, level, namespace_, name_='Obfuscation_Techniques', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.Noisiness is not None or
            self.Ease_of_Obfuscation is not None or
            self.Obfuscation_Techniques is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Observable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Noisiness is not None:
            showIndent(outfile, level)
            outfile.write('Noisiness=%s,\n' % quote_python(self.Noisiness).encode(ExternalEncoding))
        if self.Ease_of_Obfuscation is not None:
            showIndent(outfile, level)
            outfile.write('Ease_of_Obfuscation=%s,\n' % quote_python(self.Ease_of_Obfuscation).encode(ExternalEncoding))
        if self.Obfuscation_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Obfuscation_Techniques=model_.Obfuscation_Techniques(\n')
            self.Obfuscation_Techniques.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Signature':
            obj_ = Signature.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'Noisiness':
            Noisiness_ = child_.text
            Noisiness_ = self.gds_validate_string(Noisiness_, node, 'Noisiness')
            self.Noisiness = Noisiness_
        elif nodeName_ == 'Ease_of_Obfuscation':
            Ease_of_Obfuscation_ = child_.text
            Ease_of_Obfuscation_ = self.gds_validate_string(Ease_of_Obfuscation_, node, 'Ease_of_Obfuscation')
            self.Ease_of_Obfuscation = Ease_of_Obfuscation_
        elif nodeName_ == 'Obfuscation_Techniques':
            obj_ = Obfuscation_Techniques.factory()
            obj_.build(child_)
            self.set_Obfuscation_Techniques(obj_)
# end class Observable


class Signature(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location_Sensor=None, Stateful_Measure=None, Event=None):
        self.Location_Sensor = Location_Sensor
        self.Stateful_Measure = Stateful_Measure
        self.Event = Event
    def factory(*args_, **kwargs_):
        if Signature.subclass:
            return Signature.subclass(*args_, **kwargs_)
        else:
            return Signature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location_Sensor(self): return self.Location_Sensor
    def set_Location_Sensor(self, Location_Sensor): self.Location_Sensor = Location_Sensor
    def get_Stateful_Measure(self): return self.Stateful_Measure
    def set_Stateful_Measure(self, Stateful_Measure): self.Stateful_Measure = Stateful_Measure
    def get_Event(self): return self.Event
    def set_Event(self, Event): self.Event = Event
    def export(self, outfile, level, namespace_='capec:', name_='Signature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Signature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Signature'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Signature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Location_Sensor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocation-Sensor>%s</%sLocation-Sensor>%s' % (namespace_, self.gds_format_string(quote_xml(self.Location_Sensor).encode(ExternalEncoding), input_name='Location-Sensor'), namespace_, eol_))
        if self.Stateful_Measure is not None:
            self.Stateful_Measure.export(outfile, level, namespace_, name_='Stateful_Measure', pretty_print=pretty_print)
        if self.Event is not None:
            self.Event.export(outfile, level, namespace_, name_='Event', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Location_Sensor is not None or
            self.Stateful_Measure is not None or
            self.Event is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Signature'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location_Sensor is not None:
            showIndent(outfile, level)
            outfile.write('Location_Sensor=%s,\n' % quote_python(self.Location_Sensor).encode(ExternalEncoding))
        if self.Stateful_Measure is not None:
            showIndent(outfile, level)
            outfile.write('Stateful_Measure=model_.Stateful_Measure(\n')
            self.Stateful_Measure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Event is not None:
            showIndent(outfile, level)
            outfile.write('Event=model_.Event(\n')
            self.Event.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location-Sensor':
            Location_Sensor_ = child_.text
            Location_Sensor_ = self.gds_validate_string(Location_Sensor_, node, 'Location_Sensor')
            self.Location_Sensor = Location_Sensor_
        elif nodeName_ == 'Stateful_Measure':
            obj_ = Stateful_Measure.factory()
            obj_.build(child_)
            self.set_Stateful_Measure(obj_)
        elif nodeName_ == 'Event':
            obj_ = Event.factory()
            obj_.build(child_)
            self.set_Event(obj_)
# end class Signature


class Location_Sensor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Location_Sensor.subclass:
            return Location_Sensor.subclass(*args_, **kwargs_)
        else:
            return Location_Sensor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Location-Sensor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Location-Sensor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Location-Sensor'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Location-Sensor', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Location-Sensor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Location_Sensor


class Stateful_Measure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Description=None, Value_Type=None):
        self.Name = _cast(None, Name)
        self.Description = Description
        self.Value_Type = Value_Type
    def factory(*args_, **kwargs_):
        if Stateful_Measure.subclass:
            return Stateful_Measure.subclass(*args_, **kwargs_)
        else:
            return Stateful_Measure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value_Type(self): return self.Value_Type
    def set_Value_Type(self, Value_Type): self.Value_Type = Value_Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Stateful_Measure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stateful_Measure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Stateful_Measure'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Stateful_Measure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Value_Type is not None:
            self.Value_Type.export(outfile, level, namespace_, name_='Value_Type', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Value_Type is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Stateful_Measure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Structured_Text_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Value_Type is not None:
            showIndent(outfile, level)
            outfile.write('Value_Type=model_.Value_Type(\n')
            self.Value_Type.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Value_Type':
            obj_ = Value_Type.factory()
            obj_.build(child_)
            self.set_Value_Type(obj_)
# end class Stateful_Measure


class Value_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Objective_Value=None, Trend=None, Frequency=None):
        self.Objective_Value = Objective_Value
        self.Trend = Trend
        self.Frequency = Frequency
    def factory(*args_, **kwargs_):
        if Value_Type.subclass:
            return Value_Type.subclass(*args_, **kwargs_)
        else:
            return Value_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Objective_Value(self): return self.Objective_Value
    def set_Objective_Value(self, Objective_Value): self.Objective_Value = Objective_Value
    def get_Trend(self): return self.Trend
    def set_Trend(self, Trend): self.Trend = Trend
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def export(self, outfile, level, namespace_='capec:', name_='Value_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Value_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Value_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Value_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Objective_Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObjective_Value>%s</%sObjective_Value>%s' % (namespace_, self.gds_format_string(quote_xml(self.Objective_Value).encode(ExternalEncoding), input_name='Objective_Value'), namespace_, eol_))
        if self.Trend is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrend>%s</%sTrend>%s' % (namespace_, self.gds_format_string(quote_xml(self.Trend).encode(ExternalEncoding), input_name='Trend'), namespace_, eol_))
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Objective_Value is not None or
            self.Trend is not None or
            self.Frequency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Value_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Objective_Value is not None:
            showIndent(outfile, level)
            outfile.write('Objective_Value=%s,\n' % quote_python(self.Objective_Value).encode(ExternalEncoding))
        if self.Trend is not None:
            showIndent(outfile, level)
            outfile.write('Trend=%s,\n' % quote_python(self.Trend).encode(ExternalEncoding))
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=model_.Frequency(\n')
            self.Frequency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Objective_Value':
            Objective_Value_ = child_.text
            Objective_Value_ = self.gds_validate_string(Objective_Value_, node, 'Objective_Value')
            self.Objective_Value = Objective_Value_
        elif nodeName_ == 'Trend':
            Trend_ = child_.text
            Trend_ = self.gds_validate_string(Trend_, node, 'Trend')
            self.Trend = Trend_
        elif nodeName_ == 'Frequency':
            obj_ = Frequency.factory()
            obj_.build(child_)
            self.set_Frequency(obj_)
# end class Value_Type


class Trend(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Trend.subclass:
            return Trend.subclass(*args_, **kwargs_)
        else:
            return Trend(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Trend', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Trend')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Trend'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Trend', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Trend'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Trend


class Frequency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Units=None, Rate=None, Scale=None):
        self.Units = _cast(None, Units)
        self.Rate = _cast(float, Rate)
        self.Scale = _cast(None, Scale)
        pass
    def factory(*args_, **kwargs_):
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Rate(self): return self.Rate
    def set_Rate(self, Rate): self.Rate = Rate
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def export(self, outfile, level, namespace_='capec:', name_='Frequency', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Frequency'):
        if self.Units is not None and 'Units' not in already_processed:
            already_processed.append('Units')
            outfile.write(' Units=%s' % (self.gds_format_string(quote_attrib(self.Units).encode(ExternalEncoding), input_name='Units'), ))
        if self.Rate is not None and 'Rate' not in already_processed:
            already_processed.append('Rate')
            outfile.write(' Rate="%s"' % self.gds_format_float(self.Rate, input_name='Rate'))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (self.gds_format_string(quote_attrib(self.Scale).encode(ExternalEncoding), input_name='Scale'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Frequency', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Frequency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Units is not None and 'Units' not in already_processed:
            already_processed.append('Units')
            showIndent(outfile, level)
            outfile.write('Units = "%s",\n' % (self.Units,))
        if self.Rate is not None and 'Rate' not in already_processed:
            already_processed.append('Rate')
            showIndent(outfile, level)
            outfile.write('Rate = %f,\n' % (self.Rate,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = "%s",\n' % (self.Scale,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Units', node)
        if value is not None and 'Units' not in already_processed:
            already_processed.append('Units')
            self.Units = value
        value = find_attr_value_('Rate', node)
        if value is not None and 'Rate' not in already_processed:
            already_processed.append('Rate')
            try:
                self.Rate = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (Rate): %s' % exp)
        value = find_attr_value_('Scale', node)
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Frequency


class Event(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Event_Type=None, Description=None, Action=None):
        self.Event_Type = _cast(None, Event_Type)
        self.Description = Description
        self.Action = Action
    def factory(*args_, **kwargs_):
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def get_Event_Type(self): return self.Event_Type
    def set_Event_Type(self, Event_Type): self.Event_Type = Event_Type
    def export(self, outfile, level, namespace_='capec:', name_='Event', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Event'):
        if self.Event_Type is not None and 'Event_Type' not in already_processed:
            already_processed.append('Event_Type')
            outfile.write(' Event_Type=%s' % (self.gds_format_string(quote_attrib(self.Event_Type).encode(ExternalEncoding), input_name='Event_Type'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Event', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Action is not None:
            self.Action.export(outfile, level, namespace_, name_='Action', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Action is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Event'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Event_Type is not None and 'Event_Type' not in already_processed:
            already_processed.append('Event_Type')
            showIndent(outfile, level)
            outfile.write('Event_Type = "%s",\n' % (self.Event_Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Structured_Text_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Action is not None:
            showIndent(outfile, level)
            outfile.write('Action=model_.Action(\n')
            self.Action.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Event_Type', node)
        if value is not None and 'Event_Type' not in already_processed:
            already_processed.append('Event_Type')
            self.Event_Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Action':
            obj_ = Action.factory()
            obj_.build(child_)
            self.set_Action(obj_)
# end class Event


class Action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Object=None):
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if Action.subclass:
            return Action.subclass(*args_, **kwargs_)
        else:
            return Action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Action', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Action'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Action', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Action'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.Object(\n')
            Object_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Object':
            obj_ = Object.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class Action


class Object(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if Object.subclass:
            return Object.subclass(*args_, **kwargs_)
        else:
            return Object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Object', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Object')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Object'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Object', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.Value(\n')
            Value_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = Value.factory()
            obj_.build(child_)
            self.Value.append(obj_)
# end class Object


class Value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Objective_Value=None, Change=None, Delta=None):
        self.Objective_Value = Objective_Value
        self.Change = Change
        self.Delta = Delta
    def factory(*args_, **kwargs_):
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Objective_Value(self): return self.Objective_Value
    def set_Objective_Value(self, Objective_Value): self.Objective_Value = Objective_Value
    def get_Change(self): return self.Change
    def set_Change(self, Change): self.Change = Change
    def get_Delta(self): return self.Delta
    def set_Delta(self, Delta): self.Delta = Delta
    def export(self, outfile, level, namespace_='capec:', name_='Value', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Value'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Value', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Objective_Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObjective_Value>%s</%sObjective_Value>%s' % (namespace_, self.gds_format_string(quote_xml(self.Objective_Value).encode(ExternalEncoding), input_name='Objective_Value'), namespace_, eol_))
        if self.Change is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChange>%s</%sChange>%s' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.Change)), input_name='Change'), namespace_, eol_))
        if self.Delta is not None:
            self.Delta.export(outfile, level, namespace_, name_='Delta', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Objective_Value is not None or
            self.Change is not None or
            self.Delta is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Value'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Objective_Value is not None:
            showIndent(outfile, level)
            outfile.write('Objective_Value=%s,\n' % quote_python(self.Objective_Value).encode(ExternalEncoding))
        if self.Change is not None:
            showIndent(outfile, level)
            outfile.write('Change=%s,\n' % self.Change)
        if self.Delta is not None:
            showIndent(outfile, level)
            outfile.write('Delta=model_.Delta(\n')
            self.Delta.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Objective_Value':
            Objective_Value_ = child_.text
            Objective_Value_ = self.gds_validate_string(Objective_Value_, node, 'Objective_Value')
            self.Objective_Value = Objective_Value_
        elif nodeName_ == 'Change':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Change')
            self.Change = ival_
        elif nodeName_ == 'Delta':
            obj_ = Delta.factory()
            obj_.build(child_)
            self.set_Delta(obj_)
# end class Value


class Delta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Trend=None, Frequency=None):
        self.Trend = Trend
        self.Frequency = Frequency
    def factory(*args_, **kwargs_):
        if Delta.subclass:
            return Delta.subclass(*args_, **kwargs_)
        else:
            return Delta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trend(self): return self.Trend
    def set_Trend(self, Trend): self.Trend = Trend
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def export(self, outfile, level, namespace_='capec:', name_='Delta', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Delta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Delta'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Delta', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Trend is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrend>%s</%sTrend>%s' % (namespace_, self.gds_format_string(quote_xml(self.Trend).encode(ExternalEncoding), input_name='Trend'), namespace_, eol_))
        if self.Frequency is not None:
            self.Frequency.export(outfile, level, namespace_, name_='Frequency', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Trend is not None or
            self.Frequency is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Delta'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Trend is not None:
            showIndent(outfile, level)
            outfile.write('Trend=%s,\n' % quote_python(self.Trend).encode(ExternalEncoding))
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=model_.Frequency(\n')
            self.Frequency.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Trend':
            Trend_ = child_.text
            Trend_ = self.gds_validate_string(Trend_, node, 'Trend')
            self.Trend = Trend_
        elif nodeName_ == 'Frequency':
            obj_ = Frequency.factory()
            obj_.build(child_)
            self.set_Frequency(obj_)
# end class Delta


class Noisiness(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Noisiness.subclass:
            return Noisiness.subclass(*args_, **kwargs_)
        else:
            return Noisiness(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Noisiness', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Noisiness')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Noisiness'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Noisiness', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Noisiness'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Noisiness


class Ease_of_Obfuscation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Ease_of_Obfuscation.subclass:
            return Ease_of_Obfuscation.subclass(*args_, **kwargs_)
        else:
            return Ease_of_Obfuscation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Ease_of_Obfuscation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Ease_of_Obfuscation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Ease_of_Obfuscation'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Ease_of_Obfuscation', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Ease_of_Obfuscation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Ease_of_Obfuscation


class Obfuscation_Techniques(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Obfuscation_Technique=None):
        if Obfuscation_Technique is None:
            self.Obfuscation_Technique = []
        else:
            self.Obfuscation_Technique = Obfuscation_Technique
    def factory(*args_, **kwargs_):
        if Obfuscation_Techniques.subclass:
            return Obfuscation_Techniques.subclass(*args_, **kwargs_)
        else:
            return Obfuscation_Techniques(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Obfuscation_Technique(self): return self.Obfuscation_Technique
    def set_Obfuscation_Technique(self, Obfuscation_Technique): self.Obfuscation_Technique = Obfuscation_Technique
    def add_Obfuscation_Technique(self, value): self.Obfuscation_Technique.append(value)
    def insert_Obfuscation_Technique(self, index, value): self.Obfuscation_Technique[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Obfuscation_Techniques', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Obfuscation_Techniques')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Obfuscation_Techniques'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Obfuscation_Techniques', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Obfuscation_Technique_ in self.Obfuscation_Technique:
            Obfuscation_Technique_.export(outfile, level, namespace_, name_='Obfuscation_Technique', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Obfuscation_Technique
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Obfuscation_Techniques'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Obfuscation_Technique=[\n')
        level += 1
        for Obfuscation_Technique_ in self.Obfuscation_Technique:
            showIndent(outfile, level)
            outfile.write('model_.Obfuscation_Technique(\n')
            Obfuscation_Technique_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Obfuscation_Technique':
            obj_ = Obfuscation_Technique.factory()
            obj_.build(child_)
            self.Obfuscation_Technique.append(obj_)
# end class Obfuscation_Techniques


class Obfuscation_Technique(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Description=None, Observables=None):
        self.Description = Description
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Obfuscation_Technique.subclass:
            return Obfuscation_Technique.subclass(*args_, **kwargs_)
        else:
            return Obfuscation_Technique(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def export(self, outfile, level, namespace_='capec:', name_='Obfuscation_Technique', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Obfuscation_Technique')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Obfuscation_Technique'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Obfuscation_Technique', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Obfuscation_Technique'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Structured_Text_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Observables':
            obj_ = ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Obfuscation_Technique


class Structured_Text_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text_Title=None, Text=None, Code_Example_Language=None, Code=None, Comment=None, Images=None, Block=None):
        if Text_Title is None:
            self.Text_Title = []
        else:
            self.Text_Title = Text_Title
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if Code_Example_Language is None:
            self.Code_Example_Language = []
        else:
            self.Code_Example_Language = Code_Example_Language
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Images = Images
        if Block is None:
            self.Block = []
        else:
            self.Block = Block
    def factory(*args_, **kwargs_):
        if Structured_Text_Type.subclass:
            return Structured_Text_Type.subclass(*args_, **kwargs_)
        else:
            return Structured_Text_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text_Title(self): return self.Text_Title
    def set_Text_Title(self, Text_Title): self.Text_Title = Text_Title
    def add_Text_Title(self, value): self.Text_Title.append(value)
    def insert_Text_Title(self, index, value): self.Text_Title[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_Code_Example_Language(self): return self.Code_Example_Language
    def set_Code_Example_Language(self, Code_Example_Language): self.Code_Example_Language = Code_Example_Language
    def add_Code_Example_Language(self, value): self.Code_Example_Language.append(value)
    def insert_Code_Example_Language(self, index, value): self.Code_Example_Language[index] = value
    def validate_Language_Type(self, value):
        # Validate type Language_Type, a restriction on xs:string.
        pass
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code(self, index, value): self.Code[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_Images(self): return self.Images
    def set_Images(self, Images): self.Images = Images
    def get_Block(self): return self.Block
    def set_Block(self, Block): self.Block = Block
    def add_Block(self, value): self.Block.append(value)
    def insert_Block(self, index, value): self.Block[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Structured_Text_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Structured_Text_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Structured_Text_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Structured_Text_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_Title_ in self.Text_Title:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText_Title>%s</%sText_Title>%s' % (namespace_, self.gds_format_string(quote_xml(Text_Title_).encode(ExternalEncoding), input_name='Text_Title'), namespace_, eol_))
        for Text_ in self.Text:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_, eol_))
        for Code_Example_Language_ in self.Code_Example_Language:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode_Example_Language>%s</%sCode_Example_Language>%s' % (namespace_, self.gds_format_string(quote_xml(Code_Example_Language_).encode(ExternalEncoding), input_name='Code_Example_Language'), namespace_, eol_))
        for Code_ in self.Code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode>%s</%sCode>%s' % (namespace_, self.gds_format_string(quote_xml(Code_).encode(ExternalEncoding), input_name='Code'), namespace_, eol_))
        for Comment_ in self.Comment:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % (namespace_, self.gds_format_string(quote_xml(Comment_).encode(ExternalEncoding), input_name='Comment'), namespace_, eol_))
        if self.Images is not None:
            self.Images.export(outfile, level, namespace_, name_='Images', pretty_print=pretty_print)
        for Block_ in self.Block:
            Block_.export(outfile, level, namespace_, name_='Block', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text_Title or
            self.Text or
            self.Code_Example_Language or
            self.Code or
            self.Comment or
            self.Images is not None or
            self.Block
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Structured_Text_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text_Title=[\n')
        level += 1
        for Text_Title_ in self.Text_Title:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_Title_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code_Example_Language=[\n')
        level += 1
        for Code_Example_Language_ in self.Code_Example_Language:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_Example_Language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Images is not None:
            showIndent(outfile, level)
            outfile.write('Images=model_.Images(\n')
            self.Images.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Block=[\n')
        level += 1
        for Block_ in self.Block:
            showIndent(outfile, level)
            outfile.write('model_.Block(\n')
            Block_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text_Title':
            Text_Title_ = child_.text
            Text_Title_ = self.gds_validate_string(Text_Title_, node, 'Text_Title')
            self.Text_Title.append(Text_Title_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'Code_Example_Language':
            Code_Example_Language_ = child_.text
            Code_Example_Language_ = self.gds_validate_string(Code_Example_Language_, node, 'Code_Example_Language')
            self.Code_Example_Language.append(Code_Example_Language_)
            self.validate_Language_Type(self.Code_Example_Language)    # validate type Language_Type
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code.append(Code_)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment.append(Comment_)
        elif nodeName_ == 'Images':
            obj_ = Images.factory()
            obj_.build(child_)
            self.set_Images(obj_)
        elif nodeName_ == 'Block':
            obj_ = Block.factory()
            obj_.build(child_)
            self.Block.append(obj_)
# end class Structured_Text_Type


class Images(GeneratedsSuper):
    """Presentation Element: This element is used to define an image."""
    subclass = None
    superclass = None
    def __init__(self, Image=None):
        if Image is None:
            self.Image = []
        else:
            self.Image = Image
    def factory(*args_, **kwargs_):
        if Images.subclass:
            return Images.subclass(*args_, **kwargs_)
        else:
            return Images(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Image(self): return self.Image
    def set_Image(self, Image): self.Image = Image
    def add_Image(self, value): self.Image.append(value)
    def insert_Image(self, index, value): self.Image[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Images', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Images')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Images'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Images', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Image_ in self.Image:
            Image_.export(outfile, level, namespace_, name_='Image', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Image
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Images'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Image=[\n')
        level += 1
        for Image_ in self.Image:
            showIndent(outfile, level)
            outfile.write('model_.Image(\n')
            Image_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Image':
            obj_ = Image.factory()
            obj_.build(child_)
            self.Image.append(obj_)
# end class Images


class Image(GeneratedsSuper):
    """Presentation Element: This element is used to define an image."""
    subclass = None
    superclass = None
    def __init__(self, Image_Location=None, Image_Title=None):
        self.Image_Location = Image_Location
        self.Image_Title = Image_Title
    def factory(*args_, **kwargs_):
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Image_Location(self): return self.Image_Location
    def set_Image_Location(self, Image_Location): self.Image_Location = Image_Location
    def get_Image_Title(self): return self.Image_Title
    def set_Image_Title(self, Image_Title): self.Image_Title = Image_Title
    def export(self, outfile, level, namespace_='capec:', name_='Image', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Image')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Image'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Image', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Image_Location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage_Location>%s</%sImage_Location>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image_Location).encode(ExternalEncoding), input_name='Image_Location'), namespace_, eol_))
        if self.Image_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sImage_Title>%s</%sImage_Title>%s' % (namespace_, self.gds_format_string(quote_xml(self.Image_Title).encode(ExternalEncoding), input_name='Image_Title'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Image_Location is not None or
            self.Image_Title is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Image'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Image_Location is not None:
            showIndent(outfile, level)
            outfile.write('Image_Location=%s,\n' % quote_python(self.Image_Location).encode(ExternalEncoding))
        if self.Image_Title is not None:
            showIndent(outfile, level)
            outfile.write('Image_Title=%s,\n' % quote_python(self.Image_Title).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Image_Location':
            Image_Location_ = child_.text
            Image_Location_ = self.gds_validate_string(Image_Location_, node, 'Image_Location')
            self.Image_Location = Image_Location_
        elif nodeName_ == 'Image_Title':
            Image_Title_ = child_.text
            Image_Title_ = self.gds_validate_string(Image_Title_, node, 'Image_Title')
            self.Image_Title = Image_Title_
# end class Image


class Block(GeneratedsSuper):
    """Block is a Structured_Text element consisting of one of Text_Title,
    Text, Code_Example_Language, or Code followed by another Block
    element. Structured_Text elements help define whitespace and
    text segments. This attribute identifies the nature of the
    content containedwithin the Block."""
    subclass = None
    superclass = None
    def __init__(self, Block_Nature=None, Structured_Text_Group=None, Block=None):
        self.Block_Nature = _cast(None, Block_Nature)
        self.Structured_Text_Group = Structured_Text_Group
        if Block is None:
            self.Block = []
        else:
            self.Block = Block
    def factory(*args_, **kwargs_):
        if Block.subclass:
            return Block.subclass(*args_, **kwargs_)
        else:
            return Block(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Structured_Text_Group(self): return self.Structured_Text_Group
    def set_Structured_Text_Group(self, Structured_Text_Group): self.Structured_Text_Group = Structured_Text_Group
    def get_Block(self): return self.Block
    def set_Block(self, Block): self.Block = Block
    def add_Block(self, value): self.Block.append(value)
    def insert_Block(self, index, value): self.Block[index] = value
    def get_Block_Nature(self): return self.Block_Nature
    def set_Block_Nature(self, Block_Nature): self.Block_Nature = Block_Nature
    def export(self, outfile, level, namespace_='capec:', name_='Block', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Block')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Block'):
        if self.Block_Nature is not None and 'Block_Nature' not in already_processed:
            already_processed.append('Block_Nature')
            outfile.write(' Block_Nature=%s' % (self.gds_format_string(quote_attrib(self.Block_Nature).encode(ExternalEncoding), input_name='Block_Nature'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Block', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Structured_Text_Group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructured_Text_Group>%s</%sStructured_Text_Group>%s' % (namespace_, self.gds_format_string(quote_xml(self.Structured_Text_Group).encode(ExternalEncoding), input_name='Structured_Text_Group'), namespace_, eol_))
        for Block_ in self.Block:
            Block_.export(outfile, level, namespace_, name_='Block', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Structured_Text_Group is not None or
            self.Block
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Block'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Block_Nature is not None and 'Block_Nature' not in already_processed:
            already_processed.append('Block_Nature')
            showIndent(outfile, level)
            outfile.write('Block_Nature = "%s",\n' % (self.Block_Nature,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Structured_Text_Group is not None:
            showIndent(outfile, level)
            outfile.write('Structured_Text_Group=%s,\n' % quote_python(self.Structured_Text_Group).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Block=[\n')
        level += 1
        for Block_ in self.Block:
            showIndent(outfile, level)
            outfile.write('model_.Block(\n')
            Block_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Block_Nature', node)
        if value is not None and 'Block_Nature' not in already_processed:
            already_processed.append('Block_Nature')
            self.Block_Nature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Structured_Text_Group':
            Structured_Text_Group_ = child_.text
            Structured_Text_Group_ = self.gds_validate_string(Structured_Text_Group_, node, 'Structured_Text_Group')
            self.Structured_Text_Group = Structured_Text_Group_
        elif nodeName_ == 'Block':
            obj_ = Block.factory()
            obj_.build(child_)
            self.Block.append(obj_)
# end class Block


class Reference_List_Type(GeneratedsSuper):
    """The References_List_Type contains one or more Reference elements,
    each of which provide further reading and insight into the item.
    This should be filled out as appropriate."""
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if Reference_List_Type.subclass:
            return Reference_List_Type.subclass(*args_, **kwargs_)
        else:
            return Reference_List_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Reference_List_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference_List_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Reference_List_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Reference_List_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Reference_List_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference_Type(\n')
            Reference_.exportLiteral(outfile, level, name_='Reference_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = Reference_Type.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class Reference_List_Type


class Reference_Type(GeneratedsSuper):
    """The id attribute is optional and is used as a mechanism forciting
    text in the entry. If an id is provided, it is placed between
    brackets and precedes this reference and the matching id should
    be used inside of the text for the attack pattern itself where
    this reference is applicable. All reference ids assigned within
    an entry must be unique."""
    subclass = None
    superclass = None
    def __init__(self, Reference_ID=None, Reference_Description=None, Reference_Author=None, Reference_Title=None, Reference_Section=None, Reference_Edition=None, Reference_Publication=None, Reference_Publisher=None, Reference_Date=None, Reference_PubDate=None, Reference_Link=None):
        self.Reference_ID = _cast(None, Reference_ID)
        self.Reference_Description = Reference_Description
        if Reference_Author is None:
            self.Reference_Author = []
        else:
            self.Reference_Author = Reference_Author
        self.Reference_Title = Reference_Title
        self.Reference_Section = Reference_Section
        self.Reference_Edition = Reference_Edition
        self.Reference_Publication = Reference_Publication
        self.Reference_Publisher = Reference_Publisher
        self.Reference_Date = Reference_Date
        self.Reference_PubDate = Reference_PubDate
        self.Reference_Link = Reference_Link
    def factory(*args_, **kwargs_):
        if Reference_Type.subclass:
            return Reference_Type.subclass(*args_, **kwargs_)
        else:
            return Reference_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference_Description(self): return self.Reference_Description
    def set_Reference_Description(self, Reference_Description): self.Reference_Description = Reference_Description
    def get_Reference_Author(self): return self.Reference_Author
    def set_Reference_Author(self, Reference_Author): self.Reference_Author = Reference_Author
    def add_Reference_Author(self, value): self.Reference_Author.append(value)
    def insert_Reference_Author(self, index, value): self.Reference_Author[index] = value
    def get_Reference_Title(self): return self.Reference_Title
    def set_Reference_Title(self, Reference_Title): self.Reference_Title = Reference_Title
    def get_Reference_Section(self): return self.Reference_Section
    def set_Reference_Section(self, Reference_Section): self.Reference_Section = Reference_Section
    def get_Reference_Edition(self): return self.Reference_Edition
    def set_Reference_Edition(self, Reference_Edition): self.Reference_Edition = Reference_Edition
    def get_Reference_Publication(self): return self.Reference_Publication
    def set_Reference_Publication(self, Reference_Publication): self.Reference_Publication = Reference_Publication
    def get_Reference_Publisher(self): return self.Reference_Publisher
    def set_Reference_Publisher(self, Reference_Publisher): self.Reference_Publisher = Reference_Publisher
    def get_Reference_Date(self): return self.Reference_Date
    def set_Reference_Date(self, Reference_Date): self.Reference_Date = Reference_Date
    def get_Reference_PubDate(self): return self.Reference_PubDate
    def set_Reference_PubDate(self, Reference_PubDate): self.Reference_PubDate = Reference_PubDate
    def get_Reference_Link(self): return self.Reference_Link
    def set_Reference_Link(self, Reference_Link): self.Reference_Link = Reference_Link
    def get_Reference_ID(self): return self.Reference_ID
    def set_Reference_ID(self, Reference_ID): self.Reference_ID = Reference_ID
    def export(self, outfile, level, namespace_='capec:', name_='Reference_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Reference_Type'):
        if self.Reference_ID is not None and 'Reference_ID' not in already_processed:
            already_processed.append('Reference_ID')
            outfile.write(' Reference_ID=%s' % (self.gds_format_string(quote_attrib(self.Reference_ID).encode(ExternalEncoding), input_name='Reference_ID'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Reference_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reference_Description is not None:
            self.Reference_Description.export(outfile, level, namespace_, name_='Reference_Description', pretty_print=pretty_print)
        for Reference_Author_ in self.Reference_Author:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Author>%s</%sReference_Author>%s' % (namespace_, self.gds_format_string(quote_xml(Reference_Author_).encode(ExternalEncoding), input_name='Reference_Author'), namespace_, eol_))
        if self.Reference_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Title>%s</%sReference_Title>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Title).encode(ExternalEncoding), input_name='Reference_Title'), namespace_, eol_))
        if self.Reference_Section is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Section>%s</%sReference_Section>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Section).encode(ExternalEncoding), input_name='Reference_Section'), namespace_, eol_))
        if self.Reference_Edition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Edition>%s</%sReference_Edition>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Edition).encode(ExternalEncoding), input_name='Reference_Edition'), namespace_, eol_))
        if self.Reference_Publication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Publication>%s</%sReference_Publication>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Publication).encode(ExternalEncoding), input_name='Reference_Publication'), namespace_, eol_))
        if self.Reference_Publisher is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Publisher>%s</%sReference_Publisher>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Publisher).encode(ExternalEncoding), input_name='Reference_Publisher'), namespace_, eol_))
        if self.Reference_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Date>%s</%sReference_Date>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Date).encode(ExternalEncoding), input_name='Reference_Date'), namespace_, eol_))
        if self.Reference_PubDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_PubDate>%s</%sReference_PubDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_PubDate).encode(ExternalEncoding), input_name='Reference_PubDate'), namespace_, eol_))
        if self.Reference_Link is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Link>%s</%sReference_Link>%s' % (namespace_, self.gds_format_string(quote_xml(self.Reference_Link).encode(ExternalEncoding), input_name='Reference_Link'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Reference_Description is not None or
            self.Reference_Author or
            self.Reference_Title is not None or
            self.Reference_Section is not None or
            self.Reference_Edition is not None or
            self.Reference_Publication is not None or
            self.Reference_Publisher is not None or
            self.Reference_Date is not None or
            self.Reference_PubDate is not None or
            self.Reference_Link is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Reference_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Reference_ID is not None and 'Reference_ID' not in already_processed:
            already_processed.append('Reference_ID')
            showIndent(outfile, level)
            outfile.write('Reference_ID = "%s",\n' % (self.Reference_ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Reference_Description is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Description=model_.Structured_Text_Type(\n')
            self.Reference_Description.exportLiteral(outfile, level, name_='Reference_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Reference_Author=[\n')
        level += 1
        for Reference_Author_ in self.Reference_Author:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reference_Author_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Reference_Title is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Title=%s,\n' % quote_python(self.Reference_Title).encode(ExternalEncoding))
        if self.Reference_Section is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Section=%s,\n' % quote_python(self.Reference_Section).encode(ExternalEncoding))
        if self.Reference_Edition is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Edition=%s,\n' % quote_python(self.Reference_Edition).encode(ExternalEncoding))
        if self.Reference_Publication is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Publication=%s,\n' % quote_python(self.Reference_Publication).encode(ExternalEncoding))
        if self.Reference_Publisher is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Publisher=%s,\n' % quote_python(self.Reference_Publisher).encode(ExternalEncoding))
        if self.Reference_Date is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Date=%s,\n' % quote_python(self.Reference_Date).encode(ExternalEncoding))
        if self.Reference_PubDate is not None:
            showIndent(outfile, level)
            outfile.write('Reference_PubDate=%s,\n' % quote_python(self.Reference_PubDate).encode(ExternalEncoding))
        if self.Reference_Link is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Link=%s,\n' % quote_python(self.Reference_Link).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Reference_ID', node)
        if value is not None and 'Reference_ID' not in already_processed:
            already_processed.append('Reference_ID')
            self.Reference_ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Reference_Description(obj_)
        elif nodeName_ == 'Reference_Author':
            Reference_Author_ = child_.text
            Reference_Author_ = self.gds_validate_string(Reference_Author_, node, 'Reference_Author')
            self.Reference_Author.append(Reference_Author_)
        elif nodeName_ == 'Reference_Title':
            Reference_Title_ = child_.text
            Reference_Title_ = self.gds_validate_string(Reference_Title_, node, 'Reference_Title')
            self.Reference_Title = Reference_Title_
        elif nodeName_ == 'Reference_Section':
            Reference_Section_ = child_.text
            Reference_Section_ = self.gds_validate_string(Reference_Section_, node, 'Reference_Section')
            self.Reference_Section = Reference_Section_
        elif nodeName_ == 'Reference_Edition':
            Reference_Edition_ = child_.text
            Reference_Edition_ = self.gds_validate_string(Reference_Edition_, node, 'Reference_Edition')
            self.Reference_Edition = Reference_Edition_
        elif nodeName_ == 'Reference_Publication':
            Reference_Publication_ = child_.text
            Reference_Publication_ = self.gds_validate_string(Reference_Publication_, node, 'Reference_Publication')
            self.Reference_Publication = Reference_Publication_
        elif nodeName_ == 'Reference_Publisher':
            Reference_Publisher_ = child_.text
            Reference_Publisher_ = self.gds_validate_string(Reference_Publisher_, node, 'Reference_Publisher')
            self.Reference_Publisher = Reference_Publisher_
        elif nodeName_ == 'Reference_Date':
            Reference_Date_ = child_.text
            Reference_Date_ = self.gds_validate_string(Reference_Date_, node, 'Reference_Date')
            self.Reference_Date = Reference_Date_
        elif nodeName_ == 'Reference_PubDate':
            Reference_PubDate_ = child_.text
            Reference_PubDate_ = self.gds_validate_string(Reference_PubDate_, node, 'Reference_PubDate')
            self.Reference_PubDate = Reference_PubDate_
        elif nodeName_ == 'Reference_Link':
            Reference_Link_ = child_.text
            Reference_Link_ = self.gds_validate_string(Reference_Link_, node, 'Reference_Link')
            self.Reference_Link = Reference_Link_
# end class Reference_Type


class Custom_Attack_StepType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Step_Title=None, Attack_Step_Description=None, Attack_Step_Techniques=None, Indicators=None, Outcomes=None, Security_Controls=None, Observables=None, extensiontype_=None):
        self.Attack_Step_Title = Attack_Step_Title
        self.Attack_Step_Description = Attack_Step_Description
        self.Attack_Step_Techniques = Attack_Step_Techniques
        self.Indicators = Indicators
        self.Outcomes = Outcomes
        self.Security_Controls = Security_Controls
        self.Observables = Observables
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Custom_Attack_StepType.subclass:
            return Custom_Attack_StepType.subclass(*args_, **kwargs_)
        else:
            return Custom_Attack_StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Step_Title(self): return self.Attack_Step_Title
    def set_Attack_Step_Title(self, Attack_Step_Title): self.Attack_Step_Title = Attack_Step_Title
    def get_Attack_Step_Description(self): return self.Attack_Step_Description
    def set_Attack_Step_Description(self, Attack_Step_Description): self.Attack_Step_Description = Attack_Step_Description
    def get_Attack_Step_Techniques(self): return self.Attack_Step_Techniques
    def set_Attack_Step_Techniques(self, Attack_Step_Techniques): self.Attack_Step_Techniques = Attack_Step_Techniques
    def get_Indicators(self): return self.Indicators
    def set_Indicators(self, Indicators): self.Indicators = Indicators
    def get_Outcomes(self): return self.Outcomes
    def set_Outcomes(self, Outcomes): self.Outcomes = Outcomes
    def get_Security_Controls(self): return self.Security_Controls
    def set_Security_Controls(self, Security_Controls): self.Security_Controls = Security_Controls
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='capec:', name_='Custom_Attack_StepType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Custom_Attack_StepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Custom_Attack_StepType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Custom_Attack_StepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attack_Step_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttack_Step_Title>%s</%sAttack_Step_Title>%s' % (namespace_, self.gds_format_string(quote_xml(self.Attack_Step_Title).encode(ExternalEncoding), input_name='Attack_Step_Title'), namespace_, eol_))
        if self.Attack_Step_Description is not None:
            self.Attack_Step_Description.export(outfile, level, namespace_, name_='Attack_Step_Description', pretty_print=pretty_print)
        if self.Attack_Step_Techniques is not None:
            self.Attack_Step_Techniques.export(outfile, level, namespace_, name_='Attack_Step_Techniques', pretty_print=pretty_print)
        if self.Indicators is not None:
            self.Indicators.export(outfile, level, namespace_, name_='Indicators', pretty_print=pretty_print)
        if self.Outcomes is not None:
            self.Outcomes.export(outfile, level, namespace_, name_='Outcomes', pretty_print=pretty_print)
        if self.Security_Controls is not None:
            self.Security_Controls.export(outfile, level, namespace_, name_='Security_Controls', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Step_Title is not None or
            self.Attack_Step_Description is not None or
            self.Attack_Step_Techniques is not None or
            self.Indicators is not None or
            self.Outcomes is not None or
            self.Security_Controls is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Custom_Attack_StepType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attack_Step_Title is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Step_Title=%s,\n' % quote_python(self.Attack_Step_Title).encode(ExternalEncoding))
        if self.Attack_Step_Description is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Step_Description=model_.Structured_Text_Type(\n')
            self.Attack_Step_Description.exportLiteral(outfile, level, name_='Attack_Step_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Step_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Step_Techniques=model_.Attack_Step_Techniques(\n')
            self.Attack_Step_Techniques.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Indicators is not None:
            showIndent(outfile, level)
            outfile.write('Indicators=model_.Indicators(\n')
            self.Indicators.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Outcomes is not None:
            showIndent(outfile, level)
            outfile.write('Outcomes=model_.Outcomes(\n')
            self.Outcomes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Security_Controls is not None:
            showIndent(outfile, level)
            outfile.write('Security_Controls=model_.Security_Controls(\n')
            self.Security_Controls.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Step_Title':
            Attack_Step_Title_ = child_.text
            Attack_Step_Title_ = self.gds_validate_string(Attack_Step_Title_, node, 'Attack_Step_Title')
            self.Attack_Step_Title = Attack_Step_Title_
        elif nodeName_ == 'Attack_Step_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Attack_Step_Description(obj_)
        elif nodeName_ == 'Attack_Step_Techniques':
            obj_ = Attack_Step_Techniques.factory()
            obj_.build(child_)
            self.set_Attack_Step_Techniques(obj_)
        elif nodeName_ == 'Indicators':
            obj_ = Indicators.factory()
            obj_.build(child_)
            self.set_Indicators(obj_)
        elif nodeName_ == 'Outcomes':
            obj_ = Outcomes.factory()
            obj_.build(child_)
            self.set_Outcomes(obj_)
        elif nodeName_ == 'Security_Controls':
            obj_ = Security_Controls.factory()
            obj_.build(child_)
            self.set_Security_Controls(obj_)
        elif nodeName_ == 'Observables':
            obj_ = ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Custom_Attack_StepType


class Attack_Step_Techniques(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Step_Technique=None):
        if Attack_Step_Technique is None:
            self.Attack_Step_Technique = []
        else:
            self.Attack_Step_Technique = Attack_Step_Technique
    def factory(*args_, **kwargs_):
        if Attack_Step_Techniques.subclass:
            return Attack_Step_Techniques.subclass(*args_, **kwargs_)
        else:
            return Attack_Step_Techniques(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Step_Technique(self): return self.Attack_Step_Technique
    def set_Attack_Step_Technique(self, Attack_Step_Technique): self.Attack_Step_Technique = Attack_Step_Technique
    def add_Attack_Step_Technique(self, value): self.Attack_Step_Technique.append(value)
    def insert_Attack_Step_Technique(self, index, value): self.Attack_Step_Technique[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Attack_Step_Techniques', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_Step_Techniques')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_Step_Techniques'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_Step_Techniques', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attack_Step_Technique_ in self.Attack_Step_Technique:
            Attack_Step_Technique_.export(outfile, level, namespace_, name_='Attack_Step_Technique', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attack_Step_Technique
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_Step_Techniques'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Attack_Step_Technique=[\n')
        level += 1
        for Attack_Step_Technique_ in self.Attack_Step_Technique:
            showIndent(outfile, level)
            outfile.write('model_.Attack_Step_Technique(\n')
            Attack_Step_Technique_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Step_Technique':
            obj_ = Attack_Step_Technique.factory()
            obj_.build(child_)
            self.Attack_Step_Technique.append(obj_)
# end class Attack_Step_Techniques


class Indicators(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Indicator=None):
        if Indicator is None:
            self.Indicator = []
        else:
            self.Indicator = Indicator
    def factory(*args_, **kwargs_):
        if Indicators.subclass:
            return Indicators.subclass(*args_, **kwargs_)
        else:
            return Indicators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator(self): return self.Indicator
    def set_Indicator(self, Indicator): self.Indicator = Indicator
    def add_Indicator(self, value): self.Indicator.append(value)
    def insert_Indicator(self, index, value): self.Indicator[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Indicators', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indicators')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Indicators'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Indicators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Indicator_ in self.Indicator:
            Indicator_.export(outfile, level, namespace_, name_='Indicator', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Indicator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Indicators'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Indicator=[\n')
        level += 1
        for Indicator_ in self.Indicator:
            showIndent(outfile, level)
            outfile.write('model_.Indicator(\n')
            Indicator_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator':
            obj_ = Indicator.factory()
            obj_.build(child_)
            self.Indicator.append(obj_)
# end class Indicators


class Indicator(GeneratedsSuper):
    """These are indicators that the application may or may not be
    susceptible to the given attack step (not necessarily the
    pattern as a whole). This field contains a unique integer
    identifier for the indicator.Each indicator has a mandatory type
    attribute that can be one of the values “Positive,”
    “Negative,” or “Inconclusive.” For example, a positive
    indicator of susceptibility to parameter tampering is the
    existence of parameters in the URL. Although it does not
    guarantee susceptibility, it indicates a cause for further
    examination. A negative indicator for the technique of privilege
    escalation is a lack of credentials and user identifiers in an
    application. Again, this is not a conclusive measure of
    resistance to attack, but an indicator that the attack step
    technique is unlikely to bear significant fruit. An inconclusive
    indicator of susceptibility to dynamic code injection is a page
    whose URL ends in .jsp, .asp, or .do but which has no visible
    explicit parameters. Such URLs typically indicate dynamic
    processing, but since no visible parameters are passed, it is
    inconclusive whether dynamic code could be injected into the
    application."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, ID=None, Indicator_Description=None, Relevant_Attack_Surface_Elements=None, Environments=None, Observables=None):
        self.type_ = _cast(None, type_)
        self.ID = _cast(int, ID)
        self.Indicator_Description = Indicator_Description
        self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
        self.Environments = Environments
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Indicator.subclass:
            return Indicator.subclass(*args_, **kwargs_)
        else:
            return Indicator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator_Description(self): return self.Indicator_Description
    def set_Indicator_Description(self, Indicator_Description): self.Indicator_Description = Indicator_Description
    def get_Relevant_Attack_Surface_Elements(self): return self.Relevant_Attack_Surface_Elements
    def set_Relevant_Attack_Surface_Elements(self, Relevant_Attack_Surface_Elements): self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
    def get_Environments(self): return self.Environments
    def set_Environments(self, Environments): self.Environments = Environments
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Indicator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indicator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Indicator'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Indicator', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Indicator_Description is not None:
            self.Indicator_Description.export(outfile, level, namespace_, name_='Indicator_Description', pretty_print=pretty_print)
        if self.Relevant_Attack_Surface_Elements is not None:
            self.Relevant_Attack_Surface_Elements.export(outfile, level, namespace_, name_='Relevant_Attack_Surface_Elements', pretty_print=pretty_print)
        if self.Environments is not None:
            self.Environments.export(outfile, level, namespace_, name_='Environments', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Indicator_Description is not None or
            self.Relevant_Attack_Surface_Elements is not None or
            self.Environments is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Indicator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Indicator_Description is not None:
            showIndent(outfile, level)
            outfile.write('Indicator_Description=model_.Structured_Text_Type(\n')
            self.Indicator_Description.exportLiteral(outfile, level, name_='Indicator_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Attack_Surface_Elements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Attack_Surface_Elements=model_.Relevant_Attack_Surface_ElementsType(\n')
            self.Relevant_Attack_Surface_Elements.exportLiteral(outfile, level, name_='Relevant_Attack_Surface_Elements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Environments is not None:
            showIndent(outfile, level)
            outfile.write('Environments=%s,\n' % quote_python(self.Environments).encode(ExternalEncoding))
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Indicator_Description(obj_)
        elif nodeName_ == 'Relevant_Attack_Surface_Elements':
            obj_ = Relevant_Attack_Surface_ElementsType.factory()
            obj_.build(child_)
            self.set_Relevant_Attack_Surface_Elements(obj_)
        elif nodeName_ == 'Environments':
            obj_ = Environments.factory()
            obj_.build(child_)
            self.set_Environments(obj_)
        elif nodeName_ == 'Observables':
            obj_ = ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Indicator


class Outcomes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Outcome=None):
        if Outcome is None:
            self.Outcome = []
        else:
            self.Outcome = Outcome
    def factory(*args_, **kwargs_):
        if Outcomes.subclass:
            return Outcomes.subclass(*args_, **kwargs_)
        else:
            return Outcomes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Outcome(self): return self.Outcome
    def set_Outcome(self, Outcome): self.Outcome = Outcome
    def add_Outcome(self, value): self.Outcome.append(value)
    def insert_Outcome(self, index, value): self.Outcome[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Outcomes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Outcomes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Outcomes'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Outcomes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Outcome_ in self.Outcome:
            Outcome_.export(outfile, level, namespace_, name_='Outcome', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Outcome
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Outcomes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Outcome=[\n')
        level += 1
        for Outcome_ in self.Outcome:
            showIndent(outfile, level)
            outfile.write('model_.Outcome(\n')
            Outcome_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Outcome':
            obj_ = Outcome.factory()
            obj_.build(child_)
            self.Outcome.append(obj_)
# end class Outcomes


class Outcome(GeneratedsSuper):
    """This field captures possible outcomes for this attack step. This
    field contains a unique integer identifier for the outcome.An
    outcome has a mandatory type attribute that can be one of the
    values “success,” “failure,” or “inconclusive.” It
    indicates what results of executing the attack step techniques
    should be considered successes, which should be considered
    failures, and which ones are inconclusive. Outcomes’ successes
    are determined relative to the attacker’s point of view. It is
    a success if the attack step got the attacker closer to his goal
    of attacking the application. It is a failure if the attacker
    got no closer to his goal."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, ID=None, Outcome_Description=None, Relevant_Attack_Surface_Elements=None, Observables=None):
        self.type_ = _cast(None, type_)
        self.ID = _cast(int, ID)
        self.Outcome_Description = Outcome_Description
        self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Outcome.subclass:
            return Outcome.subclass(*args_, **kwargs_)
        else:
            return Outcome(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Outcome_Description(self): return self.Outcome_Description
    def set_Outcome_Description(self, Outcome_Description): self.Outcome_Description = Outcome_Description
    def get_Relevant_Attack_Surface_Elements(self): return self.Relevant_Attack_Surface_Elements
    def set_Relevant_Attack_Surface_Elements(self, Relevant_Attack_Surface_Elements): self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Outcome', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Outcome')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Outcome'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Outcome', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Outcome_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutcome_Description>%s</%sOutcome_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.Outcome_Description).encode(ExternalEncoding), input_name='Outcome_Description'), namespace_, eol_))
        if self.Relevant_Attack_Surface_Elements is not None:
            self.Relevant_Attack_Surface_Elements.export(outfile, level, namespace_, name_='Relevant_Attack_Surface_Elements', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Outcome_Description is not None or
            self.Relevant_Attack_Surface_Elements is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Outcome'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Outcome_Description is not None:
            showIndent(outfile, level)
            outfile.write('Outcome_Description=%s,\n' % quote_python(self.Outcome_Description).encode(ExternalEncoding))
        if self.Relevant_Attack_Surface_Elements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Attack_Surface_Elements=model_.Relevant_Attack_Surface_ElementsType(\n')
            self.Relevant_Attack_Surface_Elements.exportLiteral(outfile, level, name_='Relevant_Attack_Surface_Elements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Outcome_Description':
            Outcome_Description_ = child_.text
            Outcome_Description_ = self.gds_validate_string(Outcome_Description_, node, 'Outcome_Description')
            self.Outcome_Description = Outcome_Description_
        elif nodeName_ == 'Relevant_Attack_Surface_Elements':
            obj_ = Relevant_Attack_Surface_ElementsType.factory()
            obj_.build(child_)
            self.set_Relevant_Attack_Surface_Elements(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Outcome


class Security_Controls(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Security_Control=None):
        if Security_Control is None:
            self.Security_Control = []
        else:
            self.Security_Control = Security_Control
    def factory(*args_, **kwargs_):
        if Security_Controls.subclass:
            return Security_Controls.subclass(*args_, **kwargs_)
        else:
            return Security_Controls(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Security_Control(self): return self.Security_Control
    def set_Security_Control(self, Security_Control): self.Security_Control = Security_Control
    def add_Security_Control(self, value): self.Security_Control.append(value)
    def insert_Security_Control(self, index, value): self.Security_Control[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Security_Controls', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Security_Controls')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Security_Controls'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Security_Controls', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Security_Control_ in self.Security_Control:
            Security_Control_.export(outfile, level, namespace_, name_='Security_Control', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Security_Control
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Security_Controls'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Security_Control=[\n')
        level += 1
        for Security_Control_ in self.Security_Control:
            showIndent(outfile, level)
            outfile.write('model_.Security_Control(\n')
            Security_Control_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Security_Control':
            obj_ = Security_Control.factory()
            obj_.build(child_)
            self.Security_Control.append(obj_)
# end class Security_Controls


class Security_Control(GeneratedsSuper):
    """This field captures security controls for this attack step that
    describe ways in which the attack step can be detected,
    corrected, or prevented. These are presented from a defender’s
    point of view, where the defender may be a developer, tester,
    operations administrator, or other resource resisting the
    attacker. This field contains a unique integer identifier for
    the security control.Each security control has a mandatory type
    attribute that can be one of the values “Detective,”
    “Corrective,” or “Preventative.” Detective controls
    detect an attacker’s activities in the attack step, whether
    the activities are successful or not. Corrective controls
    attempt to mitigate an attacker’s success by responding to a
    successful outcome. They are not related to or normalized
    against outcomes. Preventative controls are those that make the
    attack step unlikely or impossible to succeed."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, ID=None, Security_Control_Description=None, Relevant_Attack_Surface_Elements=None, Observable_Evidence=None):
        self.type_ = _cast(None, type_)
        self.ID = _cast(int, ID)
        self.Security_Control_Description = Security_Control_Description
        self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
        self.Observable_Evidence = Observable_Evidence
    def factory(*args_, **kwargs_):
        if Security_Control.subclass:
            return Security_Control.subclass(*args_, **kwargs_)
        else:
            return Security_Control(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Security_Control_Description(self): return self.Security_Control_Description
    def set_Security_Control_Description(self, Security_Control_Description): self.Security_Control_Description = Security_Control_Description
    def get_Relevant_Attack_Surface_Elements(self): return self.Relevant_Attack_Surface_Elements
    def set_Relevant_Attack_Surface_Elements(self, Relevant_Attack_Surface_Elements): self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
    def get_Observable_Evidence(self): return self.Observable_Evidence
    def set_Observable_Evidence(self, Observable_Evidence): self.Observable_Evidence = Observable_Evidence
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Security_Control', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Security_Control')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Security_Control'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Security_Control', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Security_Control_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSecurity_Control_Description>%s</%sSecurity_Control_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.Security_Control_Description).encode(ExternalEncoding), input_name='Security_Control_Description'), namespace_, eol_))
        if self.Relevant_Attack_Surface_Elements is not None:
            self.Relevant_Attack_Surface_Elements.export(outfile, level, namespace_, name_='Relevant_Attack_Surface_Elements', pretty_print=pretty_print)
        if self.Observable_Evidence is not None:
            self.Observable_Evidence.export(outfile, level, namespace_, name_='Observable_Evidence', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Security_Control_Description is not None or
            self.Relevant_Attack_Surface_Elements is not None or
            self.Observable_Evidence is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Security_Control'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Security_Control_Description is not None:
            showIndent(outfile, level)
            outfile.write('Security_Control_Description=%s,\n' % quote_python(self.Security_Control_Description).encode(ExternalEncoding))
        if self.Relevant_Attack_Surface_Elements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Attack_Surface_Elements=model_.Relevant_Attack_Surface_ElementsType(\n')
            self.Relevant_Attack_Surface_Elements.exportLiteral(outfile, level, name_='Relevant_Attack_Surface_Elements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observable_Evidence is not None:
            showIndent(outfile, level)
            outfile.write('Observable_Evidence=model_.Observable_Evidence(\n')
            self.Observable_Evidence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Security_Control_Description':
            Security_Control_Description_ = child_.text
            Security_Control_Description_ = self.gds_validate_string(Security_Control_Description_, node, 'Security_Control_Description')
            self.Security_Control_Description = Security_Control_Description_
        elif nodeName_ == 'Relevant_Attack_Surface_Elements':
            obj_ = Relevant_Attack_Surface_ElementsType.factory()
            obj_.build(child_)
            self.set_Relevant_Attack_Surface_Elements(obj_)
        elif nodeName_ == 'Observable_Evidence':
            obj_ = Observable_Evidence.factory()
            obj_.build(child_)
            self.set_Observable_Evidence(obj_)
# end class Security_Control


class Observable_Evidence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IfPresent_Observables=None, IfNotPresent_Observables=None):
        self.IfPresent_Observables = IfPresent_Observables
        self.IfNotPresent_Observables = IfNotPresent_Observables
    def factory(*args_, **kwargs_):
        if Observable_Evidence.subclass:
            return Observable_Evidence.subclass(*args_, **kwargs_)
        else:
            return Observable_Evidence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IfPresent_Observables(self): return self.IfPresent_Observables
    def set_IfPresent_Observables(self, IfPresent_Observables): self.IfPresent_Observables = IfPresent_Observables
    def get_IfNotPresent_Observables(self): return self.IfNotPresent_Observables
    def set_IfNotPresent_Observables(self, IfNotPresent_Observables): self.IfNotPresent_Observables = IfNotPresent_Observables
    def export(self, outfile, level, namespace_='capec:', name_='Observable_Evidence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Observable_Evidence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Observable_Evidence'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Observable_Evidence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IfPresent_Observables is not None:
            self.IfPresent_Observables.export(outfile, level, namespace_, name_='IfPresent_Observables', pretty_print=pretty_print)
        if self.IfNotPresent_Observables is not None:
            self.IfNotPresent_Observables.export(outfile, level, namespace_, name_='IfNotPresent_Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IfPresent_Observables is not None or
            self.IfNotPresent_Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Observable_Evidence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IfPresent_Observables is not None:
            showIndent(outfile, level)
            outfile.write('IfPresent_Observables=model_.ObservablesType(\n')
            self.IfPresent_Observables.exportLiteral(outfile, level, name_='IfPresent_Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IfNotPresent_Observables is not None:
            showIndent(outfile, level)
            outfile.write('IfNotPresent_Observables=model_.ObservablesType(\n')
            self.IfNotPresent_Observables.exportLiteral(outfile, level, name_='IfNotPresent_Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IfPresent_Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_IfPresent_Observables(obj_)
        elif nodeName_ == 'IfNotPresent_Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_IfNotPresent_Observables(obj_)
# end class Observable_Evidence


class Target_Attack_SurfaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Common_Attack_Surface_Description=None, Target_Attack_Surface_Description=None):
        self.Common_Attack_Surface_Description = Common_Attack_Surface_Description
        self.Target_Attack_Surface_Description = Target_Attack_Surface_Description
    def factory(*args_, **kwargs_):
        if Target_Attack_SurfaceType.subclass:
            return Target_Attack_SurfaceType.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_SurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Common_Attack_Surface_Description(self): return self.Common_Attack_Surface_Description
    def set_Common_Attack_Surface_Description(self, Common_Attack_Surface_Description): self.Common_Attack_Surface_Description = Common_Attack_Surface_Description
    def get_Target_Attack_Surface_Description(self): return self.Target_Attack_Surface_Description
    def set_Target_Attack_Surface_Description(self, Target_Attack_Surface_Description): self.Target_Attack_Surface_Description = Target_Attack_Surface_Description
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_SurfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_SurfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_SurfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_SurfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Common_Attack_Surface_Description is not None:
            self.Common_Attack_Surface_Description.export(outfile, level, namespace_, name_='Common_Attack_Surface_Description', pretty_print=pretty_print)
        if self.Target_Attack_Surface_Description is not None:
            self.Target_Attack_Surface_Description.export(outfile, level, namespace_, name_='Target_Attack_Surface_Description', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Common_Attack_Surface_Description is not None or
            self.Target_Attack_Surface_Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Attack_SurfaceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Common_Attack_Surface_Description is not None:
            showIndent(outfile, level)
            outfile.write('Common_Attack_Surface_Description=model_.Common_Attack_Surface_Description(\n')
            self.Common_Attack_Surface_Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface_Description is not None:
            showIndent(outfile, level)
            outfile.write('Target_Attack_Surface_Description=model_.Target_Attack_Surface_DescriptionType(\n')
            self.Target_Attack_Surface_Description.exportLiteral(outfile, level, name_='Target_Attack_Surface_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Common_Attack_Surface_Description':
            obj_ = Common_Attack_Surface_Description.factory()
            obj_.build(child_)
            self.set_Common_Attack_Surface_Description(obj_)
        elif nodeName_ == 'Target_Attack_Surface_Description':
            class_obj_ = self.get_class_obj_(child_, Target_Attack_Surface_DescriptionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface_Description(obj_)
# end class Target_Attack_SurfaceType


class Common_Attack_Surface_Description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Common_Attack_Surface_ID=None, Relevant_Attack_Surface_Elements=None, Pattern_Specific_Overrides=None):
        self.Common_Attack_Surface_ID = _cast(None, Common_Attack_Surface_ID)
        self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
        self.Pattern_Specific_Overrides = Pattern_Specific_Overrides
    def factory(*args_, **kwargs_):
        if Common_Attack_Surface_Description.subclass:
            return Common_Attack_Surface_Description.subclass(*args_, **kwargs_)
        else:
            return Common_Attack_Surface_Description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Attack_Surface_Elements(self): return self.Relevant_Attack_Surface_Elements
    def set_Relevant_Attack_Surface_Elements(self, Relevant_Attack_Surface_Elements): self.Relevant_Attack_Surface_Elements = Relevant_Attack_Surface_Elements
    def get_Pattern_Specific_Overrides(self): return self.Pattern_Specific_Overrides
    def set_Pattern_Specific_Overrides(self, Pattern_Specific_Overrides): self.Pattern_Specific_Overrides = Pattern_Specific_Overrides
    def get_Common_Attack_Surface_ID(self): return self.Common_Attack_Surface_ID
    def set_Common_Attack_Surface_ID(self, Common_Attack_Surface_ID): self.Common_Attack_Surface_ID = Common_Attack_Surface_ID
    def export(self, outfile, level, namespace_='capec:', name_='Common_Attack_Surface_Description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_Attack_Surface_Description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_Attack_Surface_Description'):
        if self.Common_Attack_Surface_ID is not None and 'Common_Attack_Surface_ID' not in already_processed:
            already_processed.append('Common_Attack_Surface_ID')
            outfile.write(' Common_Attack_Surface_ID=%s' % (self.gds_format_string(quote_attrib(self.Common_Attack_Surface_ID).encode(ExternalEncoding), input_name='Common_Attack_Surface_ID'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_Attack_Surface_Description', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Relevant_Attack_Surface_Elements is not None:
            self.Relevant_Attack_Surface_Elements.export(outfile, level, namespace_, name_='Relevant_Attack_Surface_Elements', pretty_print=pretty_print)
        if self.Pattern_Specific_Overrides is not None:
            self.Pattern_Specific_Overrides.export(outfile, level, namespace_, name_='Pattern_Specific_Overrides', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relevant_Attack_Surface_Elements is not None or
            self.Pattern_Specific_Overrides is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Common_Attack_Surface_Description'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Common_Attack_Surface_ID is not None and 'Common_Attack_Surface_ID' not in already_processed:
            already_processed.append('Common_Attack_Surface_ID')
            showIndent(outfile, level)
            outfile.write('Common_Attack_Surface_ID = "%s",\n' % (self.Common_Attack_Surface_ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Relevant_Attack_Surface_Elements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Attack_Surface_Elements=model_.Relevant_Attack_Surface_ElementsType(\n')
            self.Relevant_Attack_Surface_Elements.exportLiteral(outfile, level, name_='Relevant_Attack_Surface_Elements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Pattern_Specific_Overrides is not None:
            showIndent(outfile, level)
            outfile.write('Pattern_Specific_Overrides=model_.Target_Attack_Surface_DescriptionType(\n')
            self.Pattern_Specific_Overrides.exportLiteral(outfile, level, name_='Pattern_Specific_Overrides')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Common_Attack_Surface_ID', node)
        if value is not None and 'Common_Attack_Surface_ID' not in already_processed:
            already_processed.append('Common_Attack_Surface_ID')
            self.Common_Attack_Surface_ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Attack_Surface_Elements':
            obj_ = Relevant_Attack_Surface_ElementsType.factory()
            obj_.build(child_)
            self.set_Relevant_Attack_Surface_Elements(obj_)
        elif nodeName_ == 'Pattern_Specific_Overrides':
            class_obj_ = self.get_class_obj_(child_, Target_Attack_Surface_DescriptionType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Pattern_Specific_Overrides(obj_)
# end class Common_Attack_Surface_Description


class Target_Attack_Surface_DescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Targeted_OSI_Layers=None, Target_Attack_Surface_Localities=None, Target_Attack_Surface_Types=None, Target_Functional_Services=None, extensiontype_=None):
        self.Targeted_OSI_Layers = Targeted_OSI_Layers
        self.Target_Attack_Surface_Localities = Target_Attack_Surface_Localities
        self.Target_Attack_Surface_Types = Target_Attack_Surface_Types
        self.Target_Functional_Services = Target_Functional_Services
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Target_Attack_Surface_DescriptionType.subclass:
            return Target_Attack_Surface_DescriptionType.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_Surface_DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Targeted_OSI_Layers(self): return self.Targeted_OSI_Layers
    def set_Targeted_OSI_Layers(self, Targeted_OSI_Layers): self.Targeted_OSI_Layers = Targeted_OSI_Layers
    def get_Target_Attack_Surface_Localities(self): return self.Target_Attack_Surface_Localities
    def set_Target_Attack_Surface_Localities(self, Target_Attack_Surface_Localities): self.Target_Attack_Surface_Localities = Target_Attack_Surface_Localities
    def get_Target_Attack_Surface_Types(self): return self.Target_Attack_Surface_Types
    def set_Target_Attack_Surface_Types(self, Target_Attack_Surface_Types): self.Target_Attack_Surface_Types = Target_Attack_Surface_Types
    def get_Target_Functional_Services(self): return self.Target_Functional_Services
    def set_Target_Functional_Services(self, Target_Functional_Services): self.Target_Functional_Services = Target_Functional_Services
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_DescriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_Surface_DescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_Surface_DescriptionType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_DescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Targeted_OSI_Layers is not None:
            self.Targeted_OSI_Layers.export(outfile, level, namespace_, name_='Targeted_OSI_Layers', pretty_print=pretty_print)
        if self.Target_Attack_Surface_Localities is not None:
            self.Target_Attack_Surface_Localities.export(outfile, level, namespace_, name_='Target_Attack_Surface_Localities', pretty_print=pretty_print)
        if self.Target_Attack_Surface_Types is not None:
            self.Target_Attack_Surface_Types.export(outfile, level, namespace_, name_='Target_Attack_Surface_Types', pretty_print=pretty_print)
        if self.Target_Functional_Services is not None:
            self.Target_Functional_Services.export(outfile, level, namespace_, name_='Target_Functional_Services', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Targeted_OSI_Layers is not None or
            self.Target_Attack_Surface_Localities is not None or
            self.Target_Attack_Surface_Types is not None or
            self.Target_Functional_Services is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Attack_Surface_DescriptionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Targeted_OSI_Layers is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_OSI_Layers=model_.Targeted_OSI_Layers(\n')
            self.Targeted_OSI_Layers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface_Localities is not None:
            showIndent(outfile, level)
            outfile.write('Target_Attack_Surface_Localities=model_.Target_Attack_Surface_Localities(\n')
            self.Target_Attack_Surface_Localities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface_Types is not None:
            showIndent(outfile, level)
            outfile.write('Target_Attack_Surface_Types=model_.Target_Attack_Surface_Types(\n')
            self.Target_Attack_Surface_Types.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Functional_Services is not None:
            showIndent(outfile, level)
            outfile.write('Target_Functional_Services=model_.Target_Functional_Services(\n')
            self.Target_Functional_Services.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Targeted_OSI_Layers':
            obj_ = Targeted_OSI_Layers.factory()
            obj_.build(child_)
            self.set_Targeted_OSI_Layers(obj_)
        elif nodeName_ == 'Target_Attack_Surface_Localities':
            obj_ = Target_Attack_Surface_Localities.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface_Localities(obj_)
        elif nodeName_ == 'Target_Attack_Surface_Types':
            obj_ = Target_Attack_Surface_Types.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface_Types(obj_)
        elif nodeName_ == 'Target_Functional_Services':
            obj_ = Target_Functional_Services.factory()
            obj_.build(child_)
            self.set_Target_Functional_Services(obj_)
# end class Target_Attack_Surface_DescriptionType


class Targeted_OSI_Layers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Targeted_OSI_Layer=None):
        if Targeted_OSI_Layer is None:
            self.Targeted_OSI_Layer = []
        else:
            self.Targeted_OSI_Layer = Targeted_OSI_Layer
    def factory(*args_, **kwargs_):
        if Targeted_OSI_Layers.subclass:
            return Targeted_OSI_Layers.subclass(*args_, **kwargs_)
        else:
            return Targeted_OSI_Layers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Targeted_OSI_Layer(self): return self.Targeted_OSI_Layer
    def set_Targeted_OSI_Layer(self, Targeted_OSI_Layer): self.Targeted_OSI_Layer = Targeted_OSI_Layer
    def add_Targeted_OSI_Layer(self, value): self.Targeted_OSI_Layer.append(value)
    def insert_Targeted_OSI_Layer(self, index, value): self.Targeted_OSI_Layer[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Targeted_OSI_Layers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Targeted_OSI_Layers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Targeted_OSI_Layers'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Targeted_OSI_Layers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Targeted_OSI_Layer_ in self.Targeted_OSI_Layer:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTargeted_OSI_Layer>%s</%sTargeted_OSI_Layer>%s' % (namespace_, self.gds_format_string(quote_xml(Targeted_OSI_Layer_).encode(ExternalEncoding), input_name='Targeted_OSI_Layer'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Targeted_OSI_Layer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Targeted_OSI_Layers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Targeted_OSI_Layer=[\n')
        level += 1
        for Targeted_OSI_Layer_ in self.Targeted_OSI_Layer:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Targeted_OSI_Layer_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Targeted_OSI_Layer':
            Targeted_OSI_Layer_ = child_.text
            Targeted_OSI_Layer_ = self.gds_validate_string(Targeted_OSI_Layer_, node, 'Targeted_OSI_Layer')
            self.Targeted_OSI_Layer.append(Targeted_OSI_Layer_)
# end class Targeted_OSI_Layers


class Targeted_OSI_Layer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Targeted_OSI_Layer.subclass:
            return Targeted_OSI_Layer.subclass(*args_, **kwargs_)
        else:
            return Targeted_OSI_Layer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Targeted_OSI_Layer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Targeted_OSI_Layer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Targeted_OSI_Layer'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Targeted_OSI_Layer', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Targeted_OSI_Layer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Targeted_OSI_Layer


class Target_Attack_Surface_Localities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Target_Attack_Surface_Locality=None):
        if Target_Attack_Surface_Locality is None:
            self.Target_Attack_Surface_Locality = []
        else:
            self.Target_Attack_Surface_Locality = Target_Attack_Surface_Locality
    def factory(*args_, **kwargs_):
        if Target_Attack_Surface_Localities.subclass:
            return Target_Attack_Surface_Localities.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_Surface_Localities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Target_Attack_Surface_Locality(self): return self.Target_Attack_Surface_Locality
    def set_Target_Attack_Surface_Locality(self, Target_Attack_Surface_Locality): self.Target_Attack_Surface_Locality = Target_Attack_Surface_Locality
    def add_Target_Attack_Surface_Locality(self, value): self.Target_Attack_Surface_Locality.append(value)
    def insert_Target_Attack_Surface_Locality(self, index, value): self.Target_Attack_Surface_Locality[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Localities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_Surface_Localities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_Surface_Localities'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Localities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Target_Attack_Surface_Locality_ in self.Target_Attack_Surface_Locality:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTarget_Attack_Surface_Locality>%s</%sTarget_Attack_Surface_Locality>%s' % (namespace_, self.gds_format_string(quote_xml(Target_Attack_Surface_Locality_).encode(ExternalEncoding), input_name='Target_Attack_Surface_Locality'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Target_Attack_Surface_Locality
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Attack_Surface_Localities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Target_Attack_Surface_Locality=[\n')
        level += 1
        for Target_Attack_Surface_Locality_ in self.Target_Attack_Surface_Locality:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Target_Attack_Surface_Locality_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Target_Attack_Surface_Locality':
            Target_Attack_Surface_Locality_ = child_.text
            Target_Attack_Surface_Locality_ = self.gds_validate_string(Target_Attack_Surface_Locality_, node, 'Target_Attack_Surface_Locality')
            self.Target_Attack_Surface_Locality.append(Target_Attack_Surface_Locality_)
# end class Target_Attack_Surface_Localities


class Target_Attack_Surface_Locality(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Target_Attack_Surface_Locality.subclass:
            return Target_Attack_Surface_Locality.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_Surface_Locality(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Locality', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_Surface_Locality')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_Surface_Locality'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Locality', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Attack_Surface_Locality'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Target_Attack_Surface_Locality


class Target_Attack_Surface_Types(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Target_Attack_Surface_Type=None):
        if Target_Attack_Surface_Type is None:
            self.Target_Attack_Surface_Type = []
        else:
            self.Target_Attack_Surface_Type = Target_Attack_Surface_Type
    def factory(*args_, **kwargs_):
        if Target_Attack_Surface_Types.subclass:
            return Target_Attack_Surface_Types.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_Surface_Types(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Target_Attack_Surface_Type(self): return self.Target_Attack_Surface_Type
    def set_Target_Attack_Surface_Type(self, Target_Attack_Surface_Type): self.Target_Attack_Surface_Type = Target_Attack_Surface_Type
    def add_Target_Attack_Surface_Type(self, value): self.Target_Attack_Surface_Type.append(value)
    def insert_Target_Attack_Surface_Type(self, index, value): self.Target_Attack_Surface_Type[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Types', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_Surface_Types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_Surface_Types'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Target_Attack_Surface_Type_ in self.Target_Attack_Surface_Type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTarget_Attack_Surface_Type>%s</%sTarget_Attack_Surface_Type>%s' % (namespace_, self.gds_format_string(quote_xml(Target_Attack_Surface_Type_).encode(ExternalEncoding), input_name='Target_Attack_Surface_Type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Target_Attack_Surface_Type
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Attack_Surface_Types'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Target_Attack_Surface_Type=[\n')
        level += 1
        for Target_Attack_Surface_Type_ in self.Target_Attack_Surface_Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Target_Attack_Surface_Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Target_Attack_Surface_Type':
            Target_Attack_Surface_Type_ = child_.text
            Target_Attack_Surface_Type_ = self.gds_validate_string(Target_Attack_Surface_Type_, node, 'Target_Attack_Surface_Type')
            self.Target_Attack_Surface_Type.append(Target_Attack_Surface_Type_)
# end class Target_Attack_Surface_Types


class Target_Attack_Surface_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Target_Attack_Surface_Type.subclass:
            return Target_Attack_Surface_Type.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_Surface_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_Surface_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_Surface_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_Type', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Attack_Surface_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Target_Attack_Surface_Type


class Target_Functional_Services(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Target_Functional_Service=None):
        if Target_Functional_Service is None:
            self.Target_Functional_Service = []
        else:
            self.Target_Functional_Service = Target_Functional_Service
    def factory(*args_, **kwargs_):
        if Target_Functional_Services.subclass:
            return Target_Functional_Services.subclass(*args_, **kwargs_)
        else:
            return Target_Functional_Services(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Target_Functional_Service(self): return self.Target_Functional_Service
    def set_Target_Functional_Service(self, Target_Functional_Service): self.Target_Functional_Service = Target_Functional_Service
    def add_Target_Functional_Service(self, value): self.Target_Functional_Service.append(value)
    def insert_Target_Functional_Service(self, index, value): self.Target_Functional_Service[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Target_Functional_Services', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Functional_Services')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Functional_Services'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Functional_Services', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Target_Functional_Service_ in self.Target_Functional_Service:
            Target_Functional_Service_.export(outfile, level, namespace_, name_='Target_Functional_Service', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Target_Functional_Service
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Functional_Services'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Target_Functional_Service=[\n')
        level += 1
        for Target_Functional_Service_ in self.Target_Functional_Service:
            showIndent(outfile, level)
            outfile.write('model_.Target_Functional_Service(\n')
            Target_Functional_Service_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Target_Functional_Service':
            obj_ = Target_Functional_Service.factory()
            obj_.build(child_)
            self.Target_Functional_Service.append(obj_)
# end class Target_Functional_Services


class Target_Functional_Service(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Name=None, Protocol=None):
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        if Protocol is None:
            self.Protocol = []
        else:
            self.Protocol = Protocol
    def factory(*args_, **kwargs_):
        if Target_Functional_Service.subclass:
            return Target_Functional_Service.subclass(*args_, **kwargs_)
        else:
            return Target_Functional_Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def add_Protocol(self, value): self.Protocol.append(value)
    def insert_Protocol(self, index, value): self.Protocol[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Target_Functional_Service', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Functional_Service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Functional_Service'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Functional_Service', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Protocol_ in self.Protocol:
            Protocol_.export(outfile, level, namespace_, name_='Protocol', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Protocol
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Target_Functional_Service'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Protocol=[\n')
        level += 1
        for Protocol_ in self.Protocol:
            showIndent(outfile, level)
            outfile.write('model_.Protocol(\n')
            Protocol_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Protocol':
            obj_ = Protocol.factory()
            obj_.build(child_)
            self.Protocol.append(obj_)
# end class Target_Functional_Service


class Protocol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RFC=None, Encryption=None, ID=None, Encryption_Type=None, Name=None, Protocol_Structure=None, Command_Structures=None, Related_Protocols=None):
        self.RFC = _cast(None, RFC)
        self.Encryption = _cast(bool, Encryption)
        self.ID = _cast(int, ID)
        self.Encryption_Type = _cast(None, Encryption_Type)
        self.Name = _cast(None, Name)
        self.Protocol_Structure = Protocol_Structure
        self.Command_Structures = Command_Structures
        self.Related_Protocols = Related_Protocols
    def factory(*args_, **kwargs_):
        if Protocol.subclass:
            return Protocol.subclass(*args_, **kwargs_)
        else:
            return Protocol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Protocol_Structure(self): return self.Protocol_Structure
    def set_Protocol_Structure(self, Protocol_Structure): self.Protocol_Structure = Protocol_Structure
    def get_Command_Structures(self): return self.Command_Structures
    def set_Command_Structures(self, Command_Structures): self.Command_Structures = Command_Structures
    def get_Related_Protocols(self): return self.Related_Protocols
    def set_Related_Protocols(self, Related_Protocols): self.Related_Protocols = Related_Protocols
    def get_RFC(self): return self.RFC
    def set_RFC(self, RFC): self.RFC = RFC
    def get_Encryption(self): return self.Encryption
    def set_Encryption(self, Encryption): self.Encryption = Encryption
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Encryption_Type(self): return self.Encryption_Type
    def set_Encryption_Type(self, Encryption_Type): self.Encryption_Type = Encryption_Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Protocol', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Protocol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Protocol'):
        if self.RFC is not None and 'RFC' not in already_processed:
            already_processed.append('RFC')
            outfile.write(' RFC=%s' % (self.gds_format_string(quote_attrib(self.RFC).encode(ExternalEncoding), input_name='RFC'), ))
        if self.Encryption is not None and 'Encryption' not in already_processed:
            already_processed.append('Encryption')
            outfile.write(' Encryption="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Encryption)), input_name='Encryption'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Encryption_Type is not None and 'Encryption_Type' not in already_processed:
            already_processed.append('Encryption_Type')
            outfile.write(' Encryption_Type=%s' % (self.gds_format_string(quote_attrib(self.Encryption_Type).encode(ExternalEncoding), input_name='Encryption_Type'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Protocol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Protocol_Structure is not None:
            self.Protocol_Structure.export(outfile, level, namespace_, name_='Protocol_Structure', pretty_print=pretty_print)
        if self.Command_Structures is not None:
            self.Command_Structures.export(outfile, level, namespace_, name_='Command_Structures', pretty_print=pretty_print)
        if self.Related_Protocols is not None:
            self.Related_Protocols.export(outfile, level, namespace_, name_='Related_Protocols', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Protocol_Structure is not None or
            self.Command_Structures is not None or
            self.Related_Protocols is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Protocol'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.RFC is not None and 'RFC' not in already_processed:
            already_processed.append('RFC')
            showIndent(outfile, level)
            outfile.write('RFC = "%s",\n' % (self.RFC,))
        if self.Encryption is not None and 'Encryption' not in already_processed:
            already_processed.append('Encryption')
            showIndent(outfile, level)
            outfile.write('Encryption = %s,\n' % (self.Encryption,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Encryption_Type is not None and 'Encryption_Type' not in already_processed:
            already_processed.append('Encryption_Type')
            showIndent(outfile, level)
            outfile.write('Encryption_Type = "%s",\n' % (self.Encryption_Type,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Protocol_Structure is not None:
            showIndent(outfile, level)
            outfile.write('Protocol_Structure=model_.Protocol_Structure(\n')
            self.Protocol_Structure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Command_Structures is not None:
            showIndent(outfile, level)
            outfile.write('Command_Structures=model_.Command_Structures(\n')
            self.Command_Structures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Protocols is not None:
            showIndent(outfile, level)
            outfile.write('Related_Protocols=model_.Related_Protocols(\n')
            self.Related_Protocols.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RFC', node)
        if value is not None and 'RFC' not in already_processed:
            already_processed.append('RFC')
            self.RFC = value
        value = find_attr_value_('Encryption', node)
        if value is not None and 'Encryption' not in already_processed:
            already_processed.append('Encryption')
            if value in ('true', '1'):
                self.Encryption = True
            elif value in ('false', '0'):
                self.Encryption = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Encryption_Type', node)
        if value is not None and 'Encryption_Type' not in already_processed:
            already_processed.append('Encryption_Type')
            self.Encryption_Type = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Protocol_Structure':
            obj_ = Protocol_Structure.factory()
            obj_.build(child_)
            self.set_Protocol_Structure(obj_)
        elif nodeName_ == 'Command_Structures':
            obj_ = Command_Structures.factory()
            obj_.build(child_)
            self.set_Command_Structures(obj_)
        elif nodeName_ == 'Related_Protocols':
            obj_ = Related_Protocols.factory()
            obj_.build(child_)
            self.set_Related_Protocols(obj_)
# end class Protocol


class Protocol_Structure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Protocol_Header=None):
        if Protocol_Header is None:
            self.Protocol_Header = []
        else:
            self.Protocol_Header = Protocol_Header
    def factory(*args_, **kwargs_):
        if Protocol_Structure.subclass:
            return Protocol_Structure.subclass(*args_, **kwargs_)
        else:
            return Protocol_Structure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Protocol_Header(self): return self.Protocol_Header
    def set_Protocol_Header(self, Protocol_Header): self.Protocol_Header = Protocol_Header
    def add_Protocol_Header(self, value): self.Protocol_Header.append(value)
    def insert_Protocol_Header(self, index, value): self.Protocol_Header[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Protocol_Structure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Protocol_Structure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Protocol_Structure'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Protocol_Structure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Protocol_Header_ in self.Protocol_Header:
            Protocol_Header_.export(outfile, level, namespace_, name_='Protocol_Header', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Protocol_Header
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Protocol_Structure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Protocol_Header=[\n')
        level += 1
        for Protocol_Header_ in self.Protocol_Header:
            showIndent(outfile, level)
            outfile.write('model_.Protocol_Header(\n')
            Protocol_Header_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Protocol_Header':
            obj_ = Protocol_Header.factory()
            obj_.build(child_)
            self.Protocol_Header.append(obj_)
# end class Protocol_Structure


class Protocol_Header(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Name=None, Protocol_RFC=None, Protocol_Field_Name=None, Protocol_Field_Description=None, Protocol_Flag_Description=None, Protocol_Flag_Value=None, Protocol_Operation_Code=None, Protocol_Data=None):
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        if Protocol_RFC is None:
            self.Protocol_RFC = []
        else:
            self.Protocol_RFC = Protocol_RFC
        if Protocol_Field_Name is None:
            self.Protocol_Field_Name = []
        else:
            self.Protocol_Field_Name = Protocol_Field_Name
        if Protocol_Field_Description is None:
            self.Protocol_Field_Description = []
        else:
            self.Protocol_Field_Description = Protocol_Field_Description
        if Protocol_Flag_Description is None:
            self.Protocol_Flag_Description = []
        else:
            self.Protocol_Flag_Description = Protocol_Flag_Description
        if Protocol_Flag_Value is None:
            self.Protocol_Flag_Value = []
        else:
            self.Protocol_Flag_Value = Protocol_Flag_Value
        if Protocol_Operation_Code is None:
            self.Protocol_Operation_Code = []
        else:
            self.Protocol_Operation_Code = Protocol_Operation_Code
        if Protocol_Data is None:
            self.Protocol_Data = []
        else:
            self.Protocol_Data = Protocol_Data
    def factory(*args_, **kwargs_):
        if Protocol_Header.subclass:
            return Protocol_Header.subclass(*args_, **kwargs_)
        else:
            return Protocol_Header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Protocol_RFC(self): return self.Protocol_RFC
    def set_Protocol_RFC(self, Protocol_RFC): self.Protocol_RFC = Protocol_RFC
    def add_Protocol_RFC(self, value): self.Protocol_RFC.append(value)
    def insert_Protocol_RFC(self, index, value): self.Protocol_RFC[index] = value
    def get_Protocol_Field_Name(self): return self.Protocol_Field_Name
    def set_Protocol_Field_Name(self, Protocol_Field_Name): self.Protocol_Field_Name = Protocol_Field_Name
    def add_Protocol_Field_Name(self, value): self.Protocol_Field_Name.append(value)
    def insert_Protocol_Field_Name(self, index, value): self.Protocol_Field_Name[index] = value
    def get_Protocol_Field_Description(self): return self.Protocol_Field_Description
    def set_Protocol_Field_Description(self, Protocol_Field_Description): self.Protocol_Field_Description = Protocol_Field_Description
    def add_Protocol_Field_Description(self, value): self.Protocol_Field_Description.append(value)
    def insert_Protocol_Field_Description(self, index, value): self.Protocol_Field_Description[index] = value
    def get_Protocol_Flag_Description(self): return self.Protocol_Flag_Description
    def set_Protocol_Flag_Description(self, Protocol_Flag_Description): self.Protocol_Flag_Description = Protocol_Flag_Description
    def add_Protocol_Flag_Description(self, value): self.Protocol_Flag_Description.append(value)
    def insert_Protocol_Flag_Description(self, index, value): self.Protocol_Flag_Description[index] = value
    def get_Protocol_Flag_Value(self): return self.Protocol_Flag_Value
    def set_Protocol_Flag_Value(self, Protocol_Flag_Value): self.Protocol_Flag_Value = Protocol_Flag_Value
    def add_Protocol_Flag_Value(self, value): self.Protocol_Flag_Value.append(value)
    def insert_Protocol_Flag_Value(self, index, value): self.Protocol_Flag_Value[index] = value
    def get_Protocol_Operation_Code(self): return self.Protocol_Operation_Code
    def set_Protocol_Operation_Code(self, Protocol_Operation_Code): self.Protocol_Operation_Code = Protocol_Operation_Code
    def add_Protocol_Operation_Code(self, value): self.Protocol_Operation_Code.append(value)
    def insert_Protocol_Operation_Code(self, index, value): self.Protocol_Operation_Code[index] = value
    def get_Protocol_Data(self): return self.Protocol_Data
    def set_Protocol_Data(self, Protocol_Data): self.Protocol_Data = Protocol_Data
    def add_Protocol_Data(self, value): self.Protocol_Data.append(value)
    def insert_Protocol_Data(self, index, value): self.Protocol_Data[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Protocol_Header', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Protocol_Header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Protocol_Header'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Protocol_Header', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Protocol_RFC_ in self.Protocol_RFC:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_RFC>%s</%sProtocol_RFC>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_RFC_).encode(ExternalEncoding), input_name='Protocol_RFC'), namespace_, eol_))
        for Protocol_Field_Name_ in self.Protocol_Field_Name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_Field_Name>%s</%sProtocol_Field_Name>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_Field_Name_).encode(ExternalEncoding), input_name='Protocol_Field_Name'), namespace_, eol_))
        for Protocol_Field_Description_ in self.Protocol_Field_Description:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_Field_Description>%s</%sProtocol_Field_Description>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_Field_Description_).encode(ExternalEncoding), input_name='Protocol_Field_Description'), namespace_, eol_))
        for Protocol_Flag_Description_ in self.Protocol_Flag_Description:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_Flag_Description>%s</%sProtocol_Flag_Description>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_Flag_Description_).encode(ExternalEncoding), input_name='Protocol_Flag_Description'), namespace_, eol_))
        for Protocol_Flag_Value_ in self.Protocol_Flag_Value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_Flag_Value>%s</%sProtocol_Flag_Value>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_Flag_Value_).encode(ExternalEncoding), input_name='Protocol_Flag_Value'), namespace_, eol_))
        for Protocol_Operation_Code_ in self.Protocol_Operation_Code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_Operation_Code>%s</%sProtocol_Operation_Code>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_Operation_Code_).encode(ExternalEncoding), input_name='Protocol_Operation_Code'), namespace_, eol_))
        for Protocol_Data_ in self.Protocol_Data:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol_Data>%s</%sProtocol_Data>%s' % (namespace_, self.gds_format_string(quote_xml(Protocol_Data_).encode(ExternalEncoding), input_name='Protocol_Data'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Protocol_RFC or
            self.Protocol_Field_Name or
            self.Protocol_Field_Description or
            self.Protocol_Flag_Description or
            self.Protocol_Flag_Value or
            self.Protocol_Operation_Code or
            self.Protocol_Data
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Protocol_Header'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Protocol_RFC=[\n')
        level += 1
        for Protocol_RFC_ in self.Protocol_RFC:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_RFC_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Protocol_Field_Name=[\n')
        level += 1
        for Protocol_Field_Name_ in self.Protocol_Field_Name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_Field_Name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Protocol_Field_Description=[\n')
        level += 1
        for Protocol_Field_Description_ in self.Protocol_Field_Description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_Field_Description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Protocol_Flag_Description=[\n')
        level += 1
        for Protocol_Flag_Description_ in self.Protocol_Flag_Description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_Flag_Description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Protocol_Flag_Value=[\n')
        level += 1
        for Protocol_Flag_Value_ in self.Protocol_Flag_Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_Flag_Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Protocol_Operation_Code=[\n')
        level += 1
        for Protocol_Operation_Code_ in self.Protocol_Operation_Code:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_Operation_Code_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Protocol_Data=[\n')
        level += 1
        for Protocol_Data_ in self.Protocol_Data:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Protocol_Data_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Protocol_RFC':
            Protocol_RFC_ = child_.text
            Protocol_RFC_ = self.gds_validate_string(Protocol_RFC_, node, 'Protocol_RFC')
            self.Protocol_RFC.append(Protocol_RFC_)
        elif nodeName_ == 'Protocol_Field_Name':
            Protocol_Field_Name_ = child_.text
            Protocol_Field_Name_ = self.gds_validate_string(Protocol_Field_Name_, node, 'Protocol_Field_Name')
            self.Protocol_Field_Name.append(Protocol_Field_Name_)
        elif nodeName_ == 'Protocol_Field_Description':
            Protocol_Field_Description_ = child_.text
            Protocol_Field_Description_ = self.gds_validate_string(Protocol_Field_Description_, node, 'Protocol_Field_Description')
            self.Protocol_Field_Description.append(Protocol_Field_Description_)
        elif nodeName_ == 'Protocol_Flag_Description':
            Protocol_Flag_Description_ = child_.text
            Protocol_Flag_Description_ = self.gds_validate_string(Protocol_Flag_Description_, node, 'Protocol_Flag_Description')
            self.Protocol_Flag_Description.append(Protocol_Flag_Description_)
        elif nodeName_ == 'Protocol_Flag_Value':
            Protocol_Flag_Value_ = child_.text
            Protocol_Flag_Value_ = self.gds_validate_string(Protocol_Flag_Value_, node, 'Protocol_Flag_Value')
            self.Protocol_Flag_Value.append(Protocol_Flag_Value_)
        elif nodeName_ == 'Protocol_Operation_Code':
            Protocol_Operation_Code_ = child_.text
            Protocol_Operation_Code_ = self.gds_validate_string(Protocol_Operation_Code_, node, 'Protocol_Operation_Code')
            self.Protocol_Operation_Code.append(Protocol_Operation_Code_)
        elif nodeName_ == 'Protocol_Data':
            Protocol_Data_ = child_.text
            Protocol_Data_ = self.gds_validate_string(Protocol_Data_, node, 'Protocol_Data')
            self.Protocol_Data.append(Protocol_Data_)
# end class Protocol_Header


class Command_Structures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Command_Structure=None):
        if Command_Structure is None:
            self.Command_Structure = []
        else:
            self.Command_Structure = Command_Structure
    def factory(*args_, **kwargs_):
        if Command_Structures.subclass:
            return Command_Structures.subclass(*args_, **kwargs_)
        else:
            return Command_Structures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Command_Structure(self): return self.Command_Structure
    def set_Command_Structure(self, Command_Structure): self.Command_Structure = Command_Structure
    def add_Command_Structure(self, value): self.Command_Structure.append(value)
    def insert_Command_Structure(self, index, value): self.Command_Structure[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Command_Structures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Command_Structures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Command_Structures'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Command_Structures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Command_Structure_ in self.Command_Structure:
            Command_Structure_.export(outfile, level, namespace_, name_='Command_Structure', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Command_Structure
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Command_Structures'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Command_Structure=[\n')
        level += 1
        for Command_Structure_ in self.Command_Structure:
            showIndent(outfile, level)
            outfile.write('model_.Command_Structure(\n')
            Command_Structure_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Command_Structure':
            obj_ = Command_Structure.factory()
            obj_.build(child_)
            self.Command_Structure.append(obj_)
# end class Command_Structures


class Command_Structure(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Name=None, Command_Description=None, Command_Type=None, Command_Group_Label=None):
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        self.Command_Description = Command_Description
        self.Command_Type = Command_Type
        self.Command_Group_Label = Command_Group_Label
    def factory(*args_, **kwargs_):
        if Command_Structure.subclass:
            return Command_Structure.subclass(*args_, **kwargs_)
        else:
            return Command_Structure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Command_Description(self): return self.Command_Description
    def set_Command_Description(self, Command_Description): self.Command_Description = Command_Description
    def get_Command_Type(self): return self.Command_Type
    def set_Command_Type(self, Command_Type): self.Command_Type = Command_Type
    def get_Command_Group_Label(self): return self.Command_Group_Label
    def set_Command_Group_Label(self, Command_Group_Label): self.Command_Group_Label = Command_Group_Label
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Command_Structure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Command_Structure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Command_Structure'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Command_Structure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Command_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommand_Description>%s</%sCommand_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.Command_Description).encode(ExternalEncoding), input_name='Command_Description'), namespace_, eol_))
        if self.Command_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommand_Type>%s</%sCommand_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.Command_Type).encode(ExternalEncoding), input_name='Command_Type'), namespace_, eol_))
        if self.Command_Group_Label is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCommand_Group_Label>%s</%sCommand_Group_Label>%s' % (namespace_, self.gds_format_string(quote_xml(self.Command_Group_Label).encode(ExternalEncoding), input_name='Command_Group_Label'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Command_Description is not None or
            self.Command_Type is not None or
            self.Command_Group_Label is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Command_Structure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Command_Description is not None:
            showIndent(outfile, level)
            outfile.write('Command_Description=%s,\n' % quote_python(self.Command_Description).encode(ExternalEncoding))
        if self.Command_Type is not None:
            showIndent(outfile, level)
            outfile.write('Command_Type=%s,\n' % quote_python(self.Command_Type).encode(ExternalEncoding))
        if self.Command_Group_Label is not None:
            showIndent(outfile, level)
            outfile.write('Command_Group_Label=%s,\n' % quote_python(self.Command_Group_Label).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Command_Description':
            Command_Description_ = child_.text
            Command_Description_ = self.gds_validate_string(Command_Description_, node, 'Command_Description')
            self.Command_Description = Command_Description_
        elif nodeName_ == 'Command_Type':
            Command_Type_ = child_.text
            Command_Type_ = self.gds_validate_string(Command_Type_, node, 'Command_Type')
            self.Command_Type = Command_Type_
        elif nodeName_ == 'Command_Group_Label':
            Command_Group_Label_ = child_.text
            Command_Group_Label_ = self.gds_validate_string(Command_Group_Label_, node, 'Command_Group_Label')
            self.Command_Group_Label = Command_Group_Label_
# end class Command_Structure


class Related_Protocols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Related_Protocol=None):
        if Related_Protocol is None:
            self.Related_Protocol = []
        else:
            self.Related_Protocol = Related_Protocol
    def factory(*args_, **kwargs_):
        if Related_Protocols.subclass:
            return Related_Protocols.subclass(*args_, **kwargs_)
        else:
            return Related_Protocols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Protocol(self): return self.Related_Protocol
    def set_Related_Protocol(self, Related_Protocol): self.Related_Protocol = Related_Protocol
    def add_Related_Protocol(self, value): self.Related_Protocol.append(value)
    def insert_Related_Protocol(self, index, value): self.Related_Protocol[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Related_Protocols', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Protocols')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Protocols'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Protocols', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Protocol_ in self.Related_Protocol:
            Related_Protocol_.export(outfile, level, namespace_, name_='Related_Protocol', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Related_Protocol
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Protocols'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Protocol=[\n')
        level += 1
        for Related_Protocol_ in self.Related_Protocol:
            showIndent(outfile, level)
            outfile.write('model_.Related_Protocol(\n')
            Related_Protocol_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Protocol':
            obj_ = Related_Protocol.factory()
            obj_.build(child_)
            self.Related_Protocol.append(obj_)
# end class Related_Protocols


class Related_Protocol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RFC=None, Name=None, Relationship_Type=None):
        self.RFC = _cast(None, RFC)
        self.Name = _cast(None, Name)
        if Relationship_Type is None:
            self.Relationship_Type = []
        else:
            self.Relationship_Type = Relationship_Type
    def factory(*args_, **kwargs_):
        if Related_Protocol.subclass:
            return Related_Protocol.subclass(*args_, **kwargs_)
        else:
            return Related_Protocol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship_Type(self): return self.Relationship_Type
    def set_Relationship_Type(self, Relationship_Type): self.Relationship_Type = Relationship_Type
    def add_Relationship_Type(self, value): self.Relationship_Type.append(value)
    def insert_Relationship_Type(self, index, value): self.Relationship_Type[index] = value
    def get_RFC(self): return self.RFC
    def set_RFC(self, RFC): self.RFC = RFC
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Related_Protocol', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Protocol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Protocol'):
        if self.RFC is not None and 'RFC' not in already_processed:
            already_processed.append('RFC')
            outfile.write(' RFC=%s' % (self.gds_format_string(quote_attrib(self.RFC).encode(ExternalEncoding), input_name='RFC'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Protocol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relationship_Type_ in self.Relationship_Type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Type>%s</%sRelationship_Type>%s' % (namespace_, self.gds_format_string(quote_xml(Relationship_Type_).encode(ExternalEncoding), input_name='Relationship_Type'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Relationship_Type
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Protocol'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.RFC is not None and 'RFC' not in already_processed:
            already_processed.append('RFC')
            showIndent(outfile, level)
            outfile.write('RFC = "%s",\n' % (self.RFC,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relationship_Type=[\n')
        level += 1
        for Relationship_Type_ in self.Relationship_Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relationship_Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RFC', node)
        if value is not None and 'RFC' not in already_processed:
            already_processed.append('RFC')
            self.RFC = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship_Type':
            Relationship_Type_ = child_.text
            Relationship_Type_ = self.gds_validate_string(Relationship_Type_, node, 'Relationship_Type')
            self.Relationship_Type.append(Relationship_Type_)
# end class Related_Protocol


class Relationship_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relationship_Type.subclass:
            return Relationship_Type.subclass(*args_, **kwargs_)
        else:
            return Relationship_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relationship_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relationship_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relationship_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relationship_Type', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relationship_Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relationship_Type


class Relevant_Attack_Surface_ElementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relevant_Functional_Services=None, Relevant_Protocols=None, Relevant_Protocol_Headers=None, Relevant_Command_Structures=None):
        self.Relevant_Functional_Services = Relevant_Functional_Services
        self.Relevant_Protocols = Relevant_Protocols
        self.Relevant_Protocol_Headers = Relevant_Protocol_Headers
        self.Relevant_Command_Structures = Relevant_Command_Structures
    def factory(*args_, **kwargs_):
        if Relevant_Attack_Surface_ElementsType.subclass:
            return Relevant_Attack_Surface_ElementsType.subclass(*args_, **kwargs_)
        else:
            return Relevant_Attack_Surface_ElementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Functional_Services(self): return self.Relevant_Functional_Services
    def set_Relevant_Functional_Services(self, Relevant_Functional_Services): self.Relevant_Functional_Services = Relevant_Functional_Services
    def get_Relevant_Protocols(self): return self.Relevant_Protocols
    def set_Relevant_Protocols(self, Relevant_Protocols): self.Relevant_Protocols = Relevant_Protocols
    def get_Relevant_Protocol_Headers(self): return self.Relevant_Protocol_Headers
    def set_Relevant_Protocol_Headers(self, Relevant_Protocol_Headers): self.Relevant_Protocol_Headers = Relevant_Protocol_Headers
    def get_Relevant_Command_Structures(self): return self.Relevant_Command_Structures
    def set_Relevant_Command_Structures(self, Relevant_Command_Structures): self.Relevant_Command_Structures = Relevant_Command_Structures
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Attack_Surface_ElementsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Attack_Surface_ElementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Attack_Surface_ElementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Attack_Surface_ElementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Relevant_Functional_Services is not None:
            self.Relevant_Functional_Services.export(outfile, level, namespace_, name_='Relevant_Functional_Services', pretty_print=pretty_print)
        if self.Relevant_Protocols is not None:
            self.Relevant_Protocols.export(outfile, level, namespace_, name_='Relevant_Protocols', pretty_print=pretty_print)
        if self.Relevant_Protocol_Headers is not None:
            self.Relevant_Protocol_Headers.export(outfile, level, namespace_, name_='Relevant_Protocol_Headers', pretty_print=pretty_print)
        if self.Relevant_Command_Structures is not None:
            self.Relevant_Command_Structures.export(outfile, level, namespace_, name_='Relevant_Command_Structures', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relevant_Functional_Services is not None or
            self.Relevant_Protocols is not None or
            self.Relevant_Protocol_Headers is not None or
            self.Relevant_Command_Structures is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Attack_Surface_ElementsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Relevant_Functional_Services is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Functional_Services=model_.Relevant_Functional_Services(\n')
            self.Relevant_Functional_Services.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Protocols is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Protocols=model_.Relevant_Protocols(\n')
            self.Relevant_Protocols.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Protocol_Headers is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Protocol_Headers=model_.Relevant_Protocol_Headers(\n')
            self.Relevant_Protocol_Headers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Command_Structures is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Command_Structures=model_.Relevant_Command_Structures(\n')
            self.Relevant_Command_Structures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Functional_Services':
            obj_ = Relevant_Functional_Services.factory()
            obj_.build(child_)
            self.set_Relevant_Functional_Services(obj_)
        elif nodeName_ == 'Relevant_Protocols':
            obj_ = Relevant_Protocols.factory()
            obj_.build(child_)
            self.set_Relevant_Protocols(obj_)
        elif nodeName_ == 'Relevant_Protocol_Headers':
            obj_ = Relevant_Protocol_Headers.factory()
            obj_.build(child_)
            self.set_Relevant_Protocol_Headers(obj_)
        elif nodeName_ == 'Relevant_Command_Structures':
            obj_ = Relevant_Command_Structures.factory()
            obj_.build(child_)
            self.set_Relevant_Command_Structures(obj_)
# end class Relevant_Attack_Surface_ElementsType


class Relevant_Functional_Services(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relevant_Functional_Service_ID=None):
        if Relevant_Functional_Service_ID is None:
            self.Relevant_Functional_Service_ID = []
        else:
            self.Relevant_Functional_Service_ID = Relevant_Functional_Service_ID
    def factory(*args_, **kwargs_):
        if Relevant_Functional_Services.subclass:
            return Relevant_Functional_Services.subclass(*args_, **kwargs_)
        else:
            return Relevant_Functional_Services(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Functional_Service_ID(self): return self.Relevant_Functional_Service_ID
    def set_Relevant_Functional_Service_ID(self, Relevant_Functional_Service_ID): self.Relevant_Functional_Service_ID = Relevant_Functional_Service_ID
    def add_Relevant_Functional_Service_ID(self, value): self.Relevant_Functional_Service_ID.append(value)
    def insert_Relevant_Functional_Service_ID(self, index, value): self.Relevant_Functional_Service_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Functional_Services', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Functional_Services')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Functional_Services'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Functional_Services', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relevant_Functional_Service_ID_ in self.Relevant_Functional_Service_ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelevant_Functional_Service_ID>%s</%sRelevant_Functional_Service_ID>%s' % (namespace_, self.gds_format_string(quote_xml(Relevant_Functional_Service_ID_).encode(ExternalEncoding), input_name='Relevant_Functional_Service_ID'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Relevant_Functional_Service_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Functional_Services'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relevant_Functional_Service_ID=[\n')
        level += 1
        for Relevant_Functional_Service_ID_ in self.Relevant_Functional_Service_ID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relevant_Functional_Service_ID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Functional_Service_ID':
            Relevant_Functional_Service_ID_ = child_.text
            Relevant_Functional_Service_ID_ = self.gds_validate_string(Relevant_Functional_Service_ID_, node, 'Relevant_Functional_Service_ID')
            self.Relevant_Functional_Service_ID.append(Relevant_Functional_Service_ID_)
# end class Relevant_Functional_Services


class Relevant_Functional_Service_ID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relevant_Functional_Service_ID.subclass:
            return Relevant_Functional_Service_ID.subclass(*args_, **kwargs_)
        else:
            return Relevant_Functional_Service_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Functional_Service_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Functional_Service_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Functional_Service_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Functional_Service_ID', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Functional_Service_ID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relevant_Functional_Service_ID


class Relevant_Protocols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relevant_Protocol_ID=None):
        if Relevant_Protocol_ID is None:
            self.Relevant_Protocol_ID = []
        else:
            self.Relevant_Protocol_ID = Relevant_Protocol_ID
    def factory(*args_, **kwargs_):
        if Relevant_Protocols.subclass:
            return Relevant_Protocols.subclass(*args_, **kwargs_)
        else:
            return Relevant_Protocols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Protocol_ID(self): return self.Relevant_Protocol_ID
    def set_Relevant_Protocol_ID(self, Relevant_Protocol_ID): self.Relevant_Protocol_ID = Relevant_Protocol_ID
    def add_Relevant_Protocol_ID(self, value): self.Relevant_Protocol_ID.append(value)
    def insert_Relevant_Protocol_ID(self, index, value): self.Relevant_Protocol_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Protocols', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Protocols')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Protocols'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Protocols', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relevant_Protocol_ID_ in self.Relevant_Protocol_ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelevant_Protocol_ID>%s</%sRelevant_Protocol_ID>%s' % (namespace_, self.gds_format_string(quote_xml(Relevant_Protocol_ID_).encode(ExternalEncoding), input_name='Relevant_Protocol_ID'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Relevant_Protocol_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Protocols'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relevant_Protocol_ID=[\n')
        level += 1
        for Relevant_Protocol_ID_ in self.Relevant_Protocol_ID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relevant_Protocol_ID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Protocol_ID':
            Relevant_Protocol_ID_ = child_.text
            Relevant_Protocol_ID_ = self.gds_validate_string(Relevant_Protocol_ID_, node, 'Relevant_Protocol_ID')
            self.Relevant_Protocol_ID.append(Relevant_Protocol_ID_)
# end class Relevant_Protocols


class Relevant_Protocol_ID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relevant_Protocol_ID.subclass:
            return Relevant_Protocol_ID.subclass(*args_, **kwargs_)
        else:
            return Relevant_Protocol_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Protocol_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Protocol_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Protocol_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Protocol_ID', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Protocol_ID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relevant_Protocol_ID


class Relevant_Protocol_Headers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relevant_Protocol_Header_ID=None):
        if Relevant_Protocol_Header_ID is None:
            self.Relevant_Protocol_Header_ID = []
        else:
            self.Relevant_Protocol_Header_ID = Relevant_Protocol_Header_ID
    def factory(*args_, **kwargs_):
        if Relevant_Protocol_Headers.subclass:
            return Relevant_Protocol_Headers.subclass(*args_, **kwargs_)
        else:
            return Relevant_Protocol_Headers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Protocol_Header_ID(self): return self.Relevant_Protocol_Header_ID
    def set_Relevant_Protocol_Header_ID(self, Relevant_Protocol_Header_ID): self.Relevant_Protocol_Header_ID = Relevant_Protocol_Header_ID
    def add_Relevant_Protocol_Header_ID(self, value): self.Relevant_Protocol_Header_ID.append(value)
    def insert_Relevant_Protocol_Header_ID(self, index, value): self.Relevant_Protocol_Header_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Protocol_Headers', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Protocol_Headers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Protocol_Headers'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Protocol_Headers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relevant_Protocol_Header_ID_ in self.Relevant_Protocol_Header_ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelevant_Protocol_Header_ID>%s</%sRelevant_Protocol_Header_ID>%s' % (namespace_, self.gds_format_string(quote_xml(Relevant_Protocol_Header_ID_).encode(ExternalEncoding), input_name='Relevant_Protocol_Header_ID'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Relevant_Protocol_Header_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Protocol_Headers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relevant_Protocol_Header_ID=[\n')
        level += 1
        for Relevant_Protocol_Header_ID_ in self.Relevant_Protocol_Header_ID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relevant_Protocol_Header_ID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Protocol_Header_ID':
            Relevant_Protocol_Header_ID_ = child_.text
            Relevant_Protocol_Header_ID_ = self.gds_validate_string(Relevant_Protocol_Header_ID_, node, 'Relevant_Protocol_Header_ID')
            self.Relevant_Protocol_Header_ID.append(Relevant_Protocol_Header_ID_)
# end class Relevant_Protocol_Headers


class Relevant_Protocol_Header_ID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relevant_Protocol_Header_ID.subclass:
            return Relevant_Protocol_Header_ID.subclass(*args_, **kwargs_)
        else:
            return Relevant_Protocol_Header_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Protocol_Header_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Protocol_Header_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Protocol_Header_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Protocol_Header_ID', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Protocol_Header_ID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relevant_Protocol_Header_ID


class Relevant_Command_Structures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relevant_Command_Structure_ID=None):
        if Relevant_Command_Structure_ID is None:
            self.Relevant_Command_Structure_ID = []
        else:
            self.Relevant_Command_Structure_ID = Relevant_Command_Structure_ID
    def factory(*args_, **kwargs_):
        if Relevant_Command_Structures.subclass:
            return Relevant_Command_Structures.subclass(*args_, **kwargs_)
        else:
            return Relevant_Command_Structures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Command_Structure_ID(self): return self.Relevant_Command_Structure_ID
    def set_Relevant_Command_Structure_ID(self, Relevant_Command_Structure_ID): self.Relevant_Command_Structure_ID = Relevant_Command_Structure_ID
    def add_Relevant_Command_Structure_ID(self, value): self.Relevant_Command_Structure_ID.append(value)
    def insert_Relevant_Command_Structure_ID(self, index, value): self.Relevant_Command_Structure_ID[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Command_Structures', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Command_Structures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Command_Structures'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Command_Structures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relevant_Command_Structure_ID_ in self.Relevant_Command_Structure_ID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelevant_Command_Structure_ID>%s</%sRelevant_Command_Structure_ID>%s' % (namespace_, self.gds_format_string(quote_xml(Relevant_Command_Structure_ID_).encode(ExternalEncoding), input_name='Relevant_Command_Structure_ID'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Relevant_Command_Structure_ID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Command_Structures'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relevant_Command_Structure_ID=[\n')
        level += 1
        for Relevant_Command_Structure_ID_ in self.Relevant_Command_Structure_ID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relevant_Command_Structure_ID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Command_Structure_ID':
            Relevant_Command_Structure_ID_ = child_.text
            Relevant_Command_Structure_ID_ = self.gds_validate_string(Relevant_Command_Structure_ID_, node, 'Relevant_Command_Structure_ID')
            self.Relevant_Command_Structure_ID.append(Relevant_Command_Structure_ID_)
# end class Relevant_Command_Structures


class Relevant_Command_Structure_ID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Relevant_Command_Structure_ID.subclass:
            return Relevant_Command_Structure_ID.subclass(*args_, **kwargs_)
        else:
            return Relevant_Command_Structure_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Command_Structure_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Command_Structure_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Command_Structure_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Command_Structure_ID', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Command_Structure_ID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Relevant_Command_Structure_ID


class Common_ConsequenceType(GeneratedsSuper):
    """The Common_Consequence_ID stores the value for the related
    Common_Consequence entry identifier as a string. Only one
    Common_Consequence_ID element can exist for each
    Common_Consequence element (ex: CC-1). However,
    Common_Consequences across CAPEC with the same ID should only
    vary in small details."""
    subclass = None
    superclass = None
    def __init__(self, Common_Consequence_ID=None, Consequence_Scope=None, Consequence_Technical_Impact=None, Consequence_Note=None):
        self.Common_Consequence_ID = _cast(None, Common_Consequence_ID)
        if Consequence_Scope is None:
            self.Consequence_Scope = []
        else:
            self.Consequence_Scope = Consequence_Scope
        if Consequence_Technical_Impact is None:
            self.Consequence_Technical_Impact = []
        else:
            self.Consequence_Technical_Impact = Consequence_Technical_Impact
        self.Consequence_Note = Consequence_Note
    def factory(*args_, **kwargs_):
        if Common_ConsequenceType.subclass:
            return Common_ConsequenceType.subclass(*args_, **kwargs_)
        else:
            return Common_ConsequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Consequence_Scope(self): return self.Consequence_Scope
    def set_Consequence_Scope(self, Consequence_Scope): self.Consequence_Scope = Consequence_Scope
    def add_Consequence_Scope(self, value): self.Consequence_Scope.append(value)
    def insert_Consequence_Scope(self, index, value): self.Consequence_Scope[index] = value
    def get_Consequence_Technical_Impact(self): return self.Consequence_Technical_Impact
    def set_Consequence_Technical_Impact(self, Consequence_Technical_Impact): self.Consequence_Technical_Impact = Consequence_Technical_Impact
    def add_Consequence_Technical_Impact(self, value): self.Consequence_Technical_Impact.append(value)
    def insert_Consequence_Technical_Impact(self, index, value): self.Consequence_Technical_Impact[index] = value
    def get_Consequence_Note(self): return self.Consequence_Note
    def set_Consequence_Note(self, Consequence_Note): self.Consequence_Note = Consequence_Note
    def get_Common_Consequence_ID(self): return self.Common_Consequence_ID
    def set_Common_Consequence_ID(self, Common_Consequence_ID): self.Common_Consequence_ID = Common_Consequence_ID
    def export(self, outfile, level, namespace_='capec:', name_='Common_ConsequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_ConsequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_ConsequenceType'):
        if self.Common_Consequence_ID is not None and 'Common_Consequence_ID' not in already_processed:
            already_processed.append('Common_Consequence_ID')
            outfile.write(' Common_Consequence_ID=%s' % (self.gds_format_string(quote_attrib(self.Common_Consequence_ID).encode(ExternalEncoding), input_name='Common_Consequence_ID'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_ConsequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Consequence_Scope_ in self.Consequence_Scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConsequence_Scope>%s</%sConsequence_Scope>%s' % (namespace_, self.gds_format_string(quote_xml(Consequence_Scope_).encode(ExternalEncoding), input_name='Consequence_Scope'), namespace_, eol_))
        for Consequence_Technical_Impact_ in self.Consequence_Technical_Impact:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConsequence_Technical_Impact>%s</%sConsequence_Technical_Impact>%s' % (namespace_, self.gds_format_string(quote_xml(Consequence_Technical_Impact_).encode(ExternalEncoding), input_name='Consequence_Technical_Impact'), namespace_, eol_))
        if self.Consequence_Note is not None:
            self.Consequence_Note.export(outfile, level, namespace_, name_='Consequence_Note', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Consequence_Scope or
            self.Consequence_Technical_Impact or
            self.Consequence_Note is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Common_ConsequenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Common_Consequence_ID is not None and 'Common_Consequence_ID' not in already_processed:
            already_processed.append('Common_Consequence_ID')
            showIndent(outfile, level)
            outfile.write('Common_Consequence_ID = "%s",\n' % (self.Common_Consequence_ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Consequence_Scope=[\n')
        level += 1
        for Consequence_Scope_ in self.Consequence_Scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Consequence_Scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Consequence_Technical_Impact=[\n')
        level += 1
        for Consequence_Technical_Impact_ in self.Consequence_Technical_Impact:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Consequence_Technical_Impact_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Consequence_Note is not None:
            showIndent(outfile, level)
            outfile.write('Consequence_Note=model_.Structured_Text_Type(\n')
            self.Consequence_Note.exportLiteral(outfile, level, name_='Consequence_Note')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Common_Consequence_ID', node)
        if value is not None and 'Common_Consequence_ID' not in already_processed:
            already_processed.append('Common_Consequence_ID')
            self.Common_Consequence_ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Consequence_Scope':
            Consequence_Scope_ = child_.text
            Consequence_Scope_ = self.gds_validate_string(Consequence_Scope_, node, 'Consequence_Scope')
            self.Consequence_Scope.append(Consequence_Scope_)
        elif nodeName_ == 'Consequence_Technical_Impact':
            Consequence_Technical_Impact_ = child_.text
            Consequence_Technical_Impact_ = self.gds_validate_string(Consequence_Technical_Impact_, node, 'Consequence_Technical_Impact')
            self.Consequence_Technical_Impact.append(Consequence_Technical_Impact_)
        elif nodeName_ == 'Consequence_Note':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Consequence_Note(obj_)
# end class Common_ConsequenceType


class Consequence_Scope(GeneratedsSuper):
    """This subelement identifies an individual consequence that may result
    from this attack pattern."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Consequence_Scope.subclass:
            return Consequence_Scope.subclass(*args_, **kwargs_)
        else:
            return Consequence_Scope(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Consequence_Scope', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Consequence_Scope')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Consequence_Scope'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Consequence_Scope', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Consequence_Scope'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Consequence_Scope


class Consequence_Technical_Impact(GeneratedsSuper):
    """This subelement describes the technical impacts that can result from
    successful execution of this attack pattern."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Consequence_Technical_Impact.subclass:
            return Consequence_Technical_Impact.subclass(*args_, **kwargs_)
        else:
            return Consequence_Technical_Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Consequence_Technical_Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Consequence_Technical_Impact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Consequence_Technical_Impact'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Consequence_Technical_Impact', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Consequence_Technical_Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Consequence_Technical_Impact


class Attack_PatternType(GeneratedsSuper):
    """The Status attribute defines the status level for this view."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, Pattern_Completeness=None, Pattern_Abstraction=None, ID=0, Name=None, Description=None, Alternate_Terms=None, Target_Attack_Surface=None, Attack_Prerequisites=None, Typical_Severity=None, Typical_Likelihood_of_Exploit=None, Methods_of_Attack=None, Examples_Instances=None, Attacker_Skills_or_Knowledge_Required=None, Resources_Required=None, Probing_Techniques=None, Indicators_Warnings_of_Attack=None, Obfuscation_Techniques=None, Solutions_and_Mitigations=None, Attack_Motivation_Consequences=None, Injection_Vector=None, Payload=None, Activation_Zone=None, Payload_Activation_Impact=None, Related_Weaknesses=None, Related_Vulnerabilities=None, Related_Attack_Patterns=None, Relevant_Security_Requirements=None, Relevant_Design_Patterns=None, Relevant_Security_Patterns=None, Related_Security_Principles=None, Related_Guidelines=None, Purposes=None, CIA_Impact=None, Technical_Context=None, Keywords=None, References=None, Other_Notes=None, Maintenance_Notes=None, Content_History=None):
        self.Status = _cast(None, Status)
        self.Pattern_Completeness = _cast(None, Pattern_Completeness)
        self.Pattern_Abstraction = _cast(None, Pattern_Abstraction)
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        self.Description = Description
        self.Alternate_Terms = Alternate_Terms
        self.Target_Attack_Surface = Target_Attack_Surface
        self.Attack_Prerequisites = Attack_Prerequisites
        self.Typical_Severity = Typical_Severity
        self.Typical_Likelihood_of_Exploit = Typical_Likelihood_of_Exploit
        self.Methods_of_Attack = Methods_of_Attack
        self.Examples_Instances = Examples_Instances
        self.Attacker_Skills_or_Knowledge_Required = Attacker_Skills_or_Knowledge_Required
        self.Resources_Required = Resources_Required
        self.Probing_Techniques = Probing_Techniques
        self.Indicators_Warnings_of_Attack = Indicators_Warnings_of_Attack
        self.Obfuscation_Techniques = Obfuscation_Techniques
        self.Solutions_and_Mitigations = Solutions_and_Mitigations
        self.Attack_Motivation_Consequences = Attack_Motivation_Consequences
        self.Injection_Vector = Injection_Vector
        self.Payload = Payload
        self.Activation_Zone = Activation_Zone
        self.Payload_Activation_Impact = Payload_Activation_Impact
        self.Related_Weaknesses = Related_Weaknesses
        self.Related_Vulnerabilities = Related_Vulnerabilities
        self.Related_Attack_Patterns = Related_Attack_Patterns
        self.Relevant_Security_Requirements = Relevant_Security_Requirements
        self.Relevant_Design_Patterns = Relevant_Design_Patterns
        self.Relevant_Security_Patterns = Relevant_Security_Patterns
        self.Related_Security_Principles = Related_Security_Principles
        self.Related_Guidelines = Related_Guidelines
        self.Purposes = Purposes
        self.CIA_Impact = CIA_Impact
        self.Technical_Context = Technical_Context
        self.Keywords = Keywords
        self.References = References
        self.Other_Notes = Other_Notes
        self.Maintenance_Notes = Maintenance_Notes
        self.Content_History = Content_History
    def factory(*args_, **kwargs_):
        if Attack_PatternType.subclass:
            return Attack_PatternType.subclass(*args_, **kwargs_)
        else:
            return Attack_PatternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Alternate_Terms(self): return self.Alternate_Terms
    def set_Alternate_Terms(self, Alternate_Terms): self.Alternate_Terms = Alternate_Terms
    def get_Target_Attack_Surface(self): return self.Target_Attack_Surface
    def set_Target_Attack_Surface(self, Target_Attack_Surface): self.Target_Attack_Surface = Target_Attack_Surface
    def get_Attack_Prerequisites(self): return self.Attack_Prerequisites
    def set_Attack_Prerequisites(self, Attack_Prerequisites): self.Attack_Prerequisites = Attack_Prerequisites
    def get_Typical_Severity(self): return self.Typical_Severity
    def set_Typical_Severity(self, Typical_Severity): self.Typical_Severity = Typical_Severity
    def get_Typical_Likelihood_of_Exploit(self): return self.Typical_Likelihood_of_Exploit
    def set_Typical_Likelihood_of_Exploit(self, Typical_Likelihood_of_Exploit): self.Typical_Likelihood_of_Exploit = Typical_Likelihood_of_Exploit
    def get_Methods_of_Attack(self): return self.Methods_of_Attack
    def set_Methods_of_Attack(self, Methods_of_Attack): self.Methods_of_Attack = Methods_of_Attack
    def get_Examples_Instances(self): return self.Examples_Instances
    def set_Examples_Instances(self, Examples_Instances): self.Examples_Instances = Examples_Instances
    def get_Attacker_Skills_or_Knowledge_Required(self): return self.Attacker_Skills_or_Knowledge_Required
    def set_Attacker_Skills_or_Knowledge_Required(self, Attacker_Skills_or_Knowledge_Required): self.Attacker_Skills_or_Knowledge_Required = Attacker_Skills_or_Knowledge_Required
    def get_Resources_Required(self): return self.Resources_Required
    def set_Resources_Required(self, Resources_Required): self.Resources_Required = Resources_Required
    def get_Probing_Techniques(self): return self.Probing_Techniques
    def set_Probing_Techniques(self, Probing_Techniques): self.Probing_Techniques = Probing_Techniques
    def get_Indicators_Warnings_of_Attack(self): return self.Indicators_Warnings_of_Attack
    def set_Indicators_Warnings_of_Attack(self, Indicators_Warnings_of_Attack): self.Indicators_Warnings_of_Attack = Indicators_Warnings_of_Attack
    def get_Obfuscation_Techniques(self): return self.Obfuscation_Techniques
    def set_Obfuscation_Techniques(self, Obfuscation_Techniques): self.Obfuscation_Techniques = Obfuscation_Techniques
    def get_Solutions_and_Mitigations(self): return self.Solutions_and_Mitigations
    def set_Solutions_and_Mitigations(self, Solutions_and_Mitigations): self.Solutions_and_Mitigations = Solutions_and_Mitigations
    def get_Attack_Motivation_Consequences(self): return self.Attack_Motivation_Consequences
    def set_Attack_Motivation_Consequences(self, Attack_Motivation_Consequences): self.Attack_Motivation_Consequences = Attack_Motivation_Consequences
    def get_Injection_Vector(self): return self.Injection_Vector
    def set_Injection_Vector(self, Injection_Vector): self.Injection_Vector = Injection_Vector
    def get_Payload(self): return self.Payload
    def set_Payload(self, Payload): self.Payload = Payload
    def get_Activation_Zone(self): return self.Activation_Zone
    def set_Activation_Zone(self, Activation_Zone): self.Activation_Zone = Activation_Zone
    def get_Payload_Activation_Impact(self): return self.Payload_Activation_Impact
    def set_Payload_Activation_Impact(self, Payload_Activation_Impact): self.Payload_Activation_Impact = Payload_Activation_Impact
    def get_Related_Weaknesses(self): return self.Related_Weaknesses
    def set_Related_Weaknesses(self, Related_Weaknesses): self.Related_Weaknesses = Related_Weaknesses
    def get_Related_Vulnerabilities(self): return self.Related_Vulnerabilities
    def set_Related_Vulnerabilities(self, Related_Vulnerabilities): self.Related_Vulnerabilities = Related_Vulnerabilities
    def get_Related_Attack_Patterns(self): return self.Related_Attack_Patterns
    def set_Related_Attack_Patterns(self, Related_Attack_Patterns): self.Related_Attack_Patterns = Related_Attack_Patterns
    def get_Relevant_Security_Requirements(self): return self.Relevant_Security_Requirements
    def set_Relevant_Security_Requirements(self, Relevant_Security_Requirements): self.Relevant_Security_Requirements = Relevant_Security_Requirements
    def get_Relevant_Design_Patterns(self): return self.Relevant_Design_Patterns
    def set_Relevant_Design_Patterns(self, Relevant_Design_Patterns): self.Relevant_Design_Patterns = Relevant_Design_Patterns
    def get_Relevant_Security_Patterns(self): return self.Relevant_Security_Patterns
    def set_Relevant_Security_Patterns(self, Relevant_Security_Patterns): self.Relevant_Security_Patterns = Relevant_Security_Patterns
    def get_Related_Security_Principles(self): return self.Related_Security_Principles
    def set_Related_Security_Principles(self, Related_Security_Principles): self.Related_Security_Principles = Related_Security_Principles
    def get_Related_Guidelines(self): return self.Related_Guidelines
    def set_Related_Guidelines(self, Related_Guidelines): self.Related_Guidelines = Related_Guidelines
    def get_Purposes(self): return self.Purposes
    def set_Purposes(self, Purposes): self.Purposes = Purposes
    def get_CIA_Impact(self): return self.CIA_Impact
    def set_CIA_Impact(self, CIA_Impact): self.CIA_Impact = CIA_Impact
    def get_Technical_Context(self): return self.Technical_Context
    def set_Technical_Context(self, Technical_Context): self.Technical_Context = Technical_Context
    def get_Keywords(self): return self.Keywords
    def set_Keywords(self, Keywords): self.Keywords = Keywords
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Other_Notes(self): return self.Other_Notes
    def set_Other_Notes(self, Other_Notes): self.Other_Notes = Other_Notes
    def get_Maintenance_Notes(self): return self.Maintenance_Notes
    def set_Maintenance_Notes(self, Maintenance_Notes): self.Maintenance_Notes = Maintenance_Notes
    def get_Content_History(self): return self.Content_History
    def set_Content_History(self, Content_History): self.Content_History = Content_History
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Pattern_Completeness(self): return self.Pattern_Completeness
    def set_Pattern_Completeness(self, Pattern_Completeness): self.Pattern_Completeness = Pattern_Completeness
    def get_Pattern_Abstraction(self): return self.Pattern_Abstraction
    def set_Pattern_Abstraction(self, Pattern_Abstraction): self.Pattern_Abstraction = Pattern_Abstraction
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='capec:', name_='Attack_PatternType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_PatternType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_PatternType'):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.Pattern_Completeness is not None and 'Pattern_Completeness' not in already_processed:
            already_processed.append('Pattern_Completeness')
            outfile.write(' Pattern_Completeness=%s' % (self.gds_format_string(quote_attrib(self.Pattern_Completeness).encode(ExternalEncoding), input_name='Pattern_Completeness'), ))
        if self.Pattern_Abstraction is not None and 'Pattern_Abstraction' not in already_processed:
            already_processed.append('Pattern_Abstraction')
            outfile.write(' Pattern_Abstraction=%s' % (self.gds_format_string(quote_attrib(self.Pattern_Abstraction).encode(ExternalEncoding), input_name='Pattern_Abstraction'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_PatternType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Alternate_Terms is not None:
            self.Alternate_Terms.export(outfile, level, namespace_, name_='Alternate_Terms', pretty_print=pretty_print)
        if self.Target_Attack_Surface is not None:
            self.Target_Attack_Surface.export(outfile, level, namespace_, name_='Target_Attack_Surface', pretty_print=pretty_print)
        if self.Attack_Prerequisites is not None:
            self.Attack_Prerequisites.export(outfile, level, namespace_, name_='Attack_Prerequisites', pretty_print=pretty_print)
        if self.Typical_Severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypical_Severity>%s</%sTypical_Severity>%s' % (namespace_, self.gds_format_string(quote_xml(self.Typical_Severity).encode(ExternalEncoding), input_name='Typical_Severity'), namespace_, eol_))
        if self.Typical_Likelihood_of_Exploit is not None:
            self.Typical_Likelihood_of_Exploit.export(outfile, level, namespace_, name_='Typical_Likelihood_of_Exploit', pretty_print=pretty_print)
        if self.Methods_of_Attack is not None:
            self.Methods_of_Attack.export(outfile, level, namespace_, name_='Methods_of_Attack', pretty_print=pretty_print)
        if self.Examples_Instances is not None:
            self.Examples_Instances.export(outfile, level, namespace_, name_='Examples-Instances', pretty_print=pretty_print)
        if self.Attacker_Skills_or_Knowledge_Required is not None:
            self.Attacker_Skills_or_Knowledge_Required.export(outfile, level, namespace_, name_='Attacker_Skills_or_Knowledge_Required', pretty_print=pretty_print)
        if self.Resources_Required is not None:
            self.Resources_Required.export(outfile, level, namespace_, name_='Resources_Required', pretty_print=pretty_print)
        if self.Probing_Techniques is not None:
            self.Probing_Techniques.export(outfile, level, namespace_, name_='Probing_Techniques', pretty_print=pretty_print)
        if self.Indicators_Warnings_of_Attack is not None:
            self.Indicators_Warnings_of_Attack.export(outfile, level, namespace_, name_='Indicators-Warnings_of_Attack', pretty_print=pretty_print)
        if self.Obfuscation_Techniques is not None:
            self.Obfuscation_Techniques.export(outfile, level, namespace_, name_='Obfuscation_Techniques', pretty_print=pretty_print)
        if self.Solutions_and_Mitigations is not None:
            self.Solutions_and_Mitigations.export(outfile, level, namespace_, name_='Solutions_and_Mitigations', pretty_print=pretty_print)
        if self.Attack_Motivation_Consequences is not None:
            self.Attack_Motivation_Consequences.export(outfile, level, namespace_, name_='Attack_Motivation-Consequences', pretty_print=pretty_print)
        if self.Injection_Vector is not None:
            self.Injection_Vector.export(outfile, level, namespace_, name_='Injection_Vector', pretty_print=pretty_print)
        if self.Payload is not None:
            self.Payload.export(outfile, level, namespace_, name_='Payload', pretty_print=pretty_print)
        if self.Activation_Zone is not None:
            self.Activation_Zone.export(outfile, level, namespace_, name_='Activation_Zone', pretty_print=pretty_print)
        if self.Payload_Activation_Impact is not None:
            self.Payload_Activation_Impact.export(outfile, level, namespace_, name_='Payload_Activation_Impact', pretty_print=pretty_print)
        if self.Related_Weaknesses is not None:
            self.Related_Weaknesses.export(outfile, level, namespace_, name_='Related_Weaknesses', pretty_print=pretty_print)
        if self.Related_Vulnerabilities is not None:
            self.Related_Vulnerabilities.export(outfile, level, namespace_, name_='Related_Vulnerabilities', pretty_print=pretty_print)
        if self.Related_Attack_Patterns is not None:
            self.Related_Attack_Patterns.export(outfile, level, namespace_, name_='Related_Attack_Patterns', pretty_print=pretty_print)
        if self.Relevant_Security_Requirements is not None:
            self.Relevant_Security_Requirements.export(outfile, level, namespace_, name_='Relevant_Security_Requirements', pretty_print=pretty_print)
        if self.Relevant_Design_Patterns is not None:
            self.Relevant_Design_Patterns.export(outfile, level, namespace_, name_='Relevant_Design_Patterns', pretty_print=pretty_print)
        if self.Relevant_Security_Patterns is not None:
            self.Relevant_Security_Patterns.export(outfile, level, namespace_, name_='Relevant_Security_Patterns', pretty_print=pretty_print)
        if self.Related_Security_Principles is not None:
            self.Related_Security_Principles.export(outfile, level, namespace_, name_='Related_Security_Principles', pretty_print=pretty_print)
        if self.Related_Guidelines is not None:
            self.Related_Guidelines.export(outfile, level, namespace_, name_='Related_Guidelines', pretty_print=pretty_print)
        if self.Purposes is not None:
            self.Purposes.export(outfile, level, namespace_, name_='Purposes', pretty_print=pretty_print)
        if self.CIA_Impact is not None:
            self.CIA_Impact.export(outfile, level, namespace_, name_='CIA_Impact', pretty_print=pretty_print)
        if self.Technical_Context is not None:
            self.Technical_Context.export(outfile, level, namespace_, name_='Technical_Context', pretty_print=pretty_print)
        if self.Keywords is not None:
            self.Keywords.export(outfile, level, namespace_, name_='Keywords', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        if self.Other_Notes is not None:
            self.Other_Notes.export(outfile, level, namespace_, name_='Other_Notes', pretty_print=pretty_print)
        if self.Maintenance_Notes is not None:
            self.Maintenance_Notes.export(outfile, level, namespace_, name_='Maintenance_Notes', pretty_print=pretty_print)
        if self.Content_History is not None:
            self.Content_History.export(outfile, level, namespace_, name_='Content_History', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Alternate_Terms is not None or
            self.Target_Attack_Surface is not None or
            self.Attack_Prerequisites is not None or
            self.Typical_Severity is not None or
            self.Typical_Likelihood_of_Exploit is not None or
            self.Methods_of_Attack is not None or
            self.Examples_Instances is not None or
            self.Attacker_Skills_or_Knowledge_Required is not None or
            self.Resources_Required is not None or
            self.Probing_Techniques is not None or
            self.Indicators_Warnings_of_Attack is not None or
            self.Obfuscation_Techniques is not None or
            self.Solutions_and_Mitigations is not None or
            self.Attack_Motivation_Consequences is not None or
            self.Injection_Vector is not None or
            self.Payload is not None or
            self.Activation_Zone is not None or
            self.Payload_Activation_Impact is not None or
            self.Related_Weaknesses is not None or
            self.Related_Vulnerabilities is not None or
            self.Related_Attack_Patterns is not None or
            self.Relevant_Security_Requirements is not None or
            self.Relevant_Design_Patterns is not None or
            self.Relevant_Security_Patterns is not None or
            self.Related_Security_Principles is not None or
            self.Related_Guidelines is not None or
            self.Purposes is not None or
            self.CIA_Impact is not None or
            self.Technical_Context is not None or
            self.Keywords is not None or
            self.References is not None or
            self.Other_Notes is not None or
            self.Maintenance_Notes is not None or
            self.Content_History is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attack_PatternType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.Pattern_Completeness is not None and 'Pattern_Completeness' not in already_processed:
            already_processed.append('Pattern_Completeness')
            showIndent(outfile, level)
            outfile.write('Pattern_Completeness = "%s",\n' % (self.Pattern_Completeness,))
        if self.Pattern_Abstraction is not None and 'Pattern_Abstraction' not in already_processed:
            already_processed.append('Pattern_Abstraction')
            showIndent(outfile, level)
            outfile.write('Pattern_Abstraction = "%s",\n' % (self.Pattern_Abstraction,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Alternate_Terms is not None:
            showIndent(outfile, level)
            outfile.write('Alternate_Terms=model_.Alternate_Terms(\n')
            self.Alternate_Terms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface is not None:
            showIndent(outfile, level)
            outfile.write('Target_Attack_Surface=model_.Target_Attack_SurfaceType(\n')
            self.Target_Attack_Surface.exportLiteral(outfile, level, name_='Target_Attack_Surface')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Prerequisites is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Prerequisites=model_.Attack_Prerequisites(\n')
            self.Attack_Prerequisites.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Typical_Severity is not None:
            showIndent(outfile, level)
            outfile.write('Typical_Severity=%s,\n' % quote_python(self.Typical_Severity).encode(ExternalEncoding))
        if self.Typical_Likelihood_of_Exploit is not None:
            showIndent(outfile, level)
            outfile.write('Typical_Likelihood_of_Exploit=model_.Typical_Likelihood_of_Exploit(\n')
            self.Typical_Likelihood_of_Exploit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Methods_of_Attack is not None:
            showIndent(outfile, level)
            outfile.write('Methods_of_Attack=model_.Methods_of_Attack(\n')
            self.Methods_of_Attack.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Examples_Instances is not None:
            showIndent(outfile, level)
            outfile.write('Examples_Instances=model_.Examples_Instances(\n')
            self.Examples_Instances.exportLiteral(outfile, level, name_='Examples_Instances')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attacker_Skills_or_Knowledge_Required is not None:
            showIndent(outfile, level)
            outfile.write('Attacker_Skills_or_Knowledge_Required=model_.Attacker_Skills_or_Knowledge_Required(\n')
            self.Attacker_Skills_or_Knowledge_Required.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Resources_Required is not None:
            showIndent(outfile, level)
            outfile.write('Resources_Required=model_.Structured_Text_Type(\n')
            self.Resources_Required.exportLiteral(outfile, level, name_='Resources_Required')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Probing_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Probing_Techniques=model_.Probing_Techniques(\n')
            self.Probing_Techniques.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Indicators_Warnings_of_Attack is not None:
            showIndent(outfile, level)
            outfile.write('Indicators_Warnings_of_Attack=model_.Indicators_Warnings_of_Attack(\n')
            self.Indicators_Warnings_of_Attack.exportLiteral(outfile, level, name_='Indicators_Warnings_of_Attack')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Obfuscation_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Obfuscation_Techniques=model_.Obfuscation_Techniques(\n')
            self.Obfuscation_Techniques.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Solutions_and_Mitigations is not None:
            showIndent(outfile, level)
            outfile.write('Solutions_and_Mitigations=model_.Solutions_and_Mitigations(\n')
            self.Solutions_and_Mitigations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Motivation_Consequences is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Motivation_Consequences=model_.Attack_Motivation_Consequences(\n')
            self.Attack_Motivation_Consequences.exportLiteral(outfile, level, name_='Attack_Motivation_Consequences')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Injection_Vector is not None:
            showIndent(outfile, level)
            outfile.write('Injection_Vector=model_.Structured_Text_Type(\n')
            self.Injection_Vector.exportLiteral(outfile, level, name_='Injection_Vector')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Payload is not None:
            showIndent(outfile, level)
            outfile.write('Payload=model_.Structured_Text_Type(\n')
            self.Payload.exportLiteral(outfile, level, name_='Payload')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Activation_Zone is not None:
            showIndent(outfile, level)
            outfile.write('Activation_Zone=model_.Structured_Text_Type(\n')
            self.Activation_Zone.exportLiteral(outfile, level, name_='Activation_Zone')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Payload_Activation_Impact is not None:
            showIndent(outfile, level)
            outfile.write('Payload_Activation_Impact=model_.Payload_Activation_Impact(\n')
            self.Payload_Activation_Impact.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Weaknesses is not None:
            showIndent(outfile, level)
            outfile.write('Related_Weaknesses=model_.Related_Weaknesses(\n')
            self.Related_Weaknesses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Vulnerabilities is not None:
            showIndent(outfile, level)
            outfile.write('Related_Vulnerabilities=model_.Related_Vulnerabilities(\n')
            self.Related_Vulnerabilities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Attack_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Related_Attack_Patterns=model_.Related_Attack_Patterns(\n')
            self.Related_Attack_Patterns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Security_Requirements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Security_Requirements=model_.Relevant_Security_Requirements(\n')
            self.Relevant_Security_Requirements.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Design_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Design_Patterns=model_.Relevant_Design_Patterns(\n')
            self.Relevant_Design_Patterns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Security_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Security_Patterns=model_.Relevant_Security_Patterns(\n')
            self.Relevant_Security_Patterns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Security_Principles is not None:
            showIndent(outfile, level)
            outfile.write('Related_Security_Principles=model_.Related_Security_Principles(\n')
            self.Related_Security_Principles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Guidelines is not None:
            showIndent(outfile, level)
            outfile.write('Related_Guidelines=model_.Related_Guidelines(\n')
            self.Related_Guidelines.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Purposes is not None:
            showIndent(outfile, level)
            outfile.write('Purposes=model_.Purposes(\n')
            self.Purposes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CIA_Impact is not None:
            showIndent(outfile, level)
            outfile.write('CIA_Impact=model_.CIA_Impact(\n')
            self.CIA_Impact.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Technical_Context is not None:
            showIndent(outfile, level)
            outfile.write('Technical_Context=model_.Technical_Context(\n')
            self.Technical_Context.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Keywords is not None:
            showIndent(outfile, level)
            outfile.write('Keywords=model_.Keywords(\n')
            self.Keywords.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.References(\n')
            self.References.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Other_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Other_Notes=model_.Other_Notes(\n')
            self.Other_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Maintenance_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Maintenance_Notes=model_.Maintenance_Notes(\n')
            self.Maintenance_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_History is not None:
            showIndent(outfile, level)
            outfile.write('Content_History=model_.Content_History(\n')
            self.Content_History.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.append('Status')
            self.Status = value
        value = find_attr_value_('Pattern_Completeness', node)
        if value is not None and 'Pattern_Completeness' not in already_processed:
            already_processed.append('Pattern_Completeness')
            self.Pattern_Completeness = value
        value = find_attr_value_('Pattern_Abstraction', node)
        if value is not None and 'Pattern_Abstraction' not in already_processed:
            already_processed.append('Pattern_Abstraction')
            self.Pattern_Abstraction = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Description.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Alternate_Terms':
            obj_ = Alternate_Terms.factory()
            obj_.build(child_)
            self.set_Alternate_Terms(obj_)
        elif nodeName_ == 'Target_Attack_Surface':
            obj_ = Target_Attack_SurfaceType.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface(obj_)
        elif nodeName_ == 'Attack_Prerequisites':
            obj_ = Attack_Prerequisites.factory()
            obj_.build(child_)
            self.set_Attack_Prerequisites(obj_)
        elif nodeName_ == 'Typical_Severity':
            Typical_Severity_ = child_.text
            Typical_Severity_ = self.gds_validate_string(Typical_Severity_, node, 'Typical_Severity')
            self.Typical_Severity = Typical_Severity_
        elif nodeName_ == 'Typical_Likelihood_of_Exploit':
            obj_ = Typical_Likelihood_of_Exploit.factory()
            obj_.build(child_)
            self.set_Typical_Likelihood_of_Exploit(obj_)
        elif nodeName_ == 'Methods_of_Attack':
            obj_ = Methods_of_Attack.factory()
            obj_.build(child_)
            self.set_Methods_of_Attack(obj_)
        elif nodeName_ == 'Examples-Instances':
            obj_ = Examples_Instances.factory()
            obj_.build(child_)
            self.set_Examples_Instances(obj_)
        elif nodeName_ == 'Attacker_Skills_or_Knowledge_Required':
            obj_ = Attacker_Skills_or_Knowledge_Required.factory()
            obj_.build(child_)
            self.set_Attacker_Skills_or_Knowledge_Required(obj_)
        elif nodeName_ == 'Resources_Required':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Resources_Required(obj_)
        elif nodeName_ == 'Probing_Techniques':
            obj_ = Probing_Techniques.factory()
            obj_.build(child_)
            self.set_Probing_Techniques(obj_)
        elif nodeName_ == 'Indicators-Warnings_of_Attack':
            obj_ = Indicators_Warnings_of_Attack.factory()
            obj_.build(child_)
            self.set_Indicators_Warnings_of_Attack(obj_)
        elif nodeName_ == 'Obfuscation_Techniques':
            obj_ = Obfuscation_Techniques.factory()
            obj_.build(child_)
            self.set_Obfuscation_Techniques(obj_)
        elif nodeName_ == 'Solutions_and_Mitigations':
            obj_ = Solutions_and_Mitigations.factory()
            obj_.build(child_)
            self.set_Solutions_and_Mitigations(obj_)
        elif nodeName_ == 'Attack_Motivation-Consequences':
            obj_ = Attack_Motivation_Consequences.factory()
            obj_.build(child_)
            self.set_Attack_Motivation_Consequences(obj_)
        elif nodeName_ == 'Injection_Vector':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Injection_Vector(obj_)
        elif nodeName_ == 'Payload':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Payload(obj_)
        elif nodeName_ == 'Activation_Zone':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Activation_Zone(obj_)
        elif nodeName_ == 'Payload_Activation_Impact':
            obj_ = Payload_Activation_Impact.factory()
            obj_.build(child_)
            self.set_Payload_Activation_Impact(obj_)
        elif nodeName_ == 'Related_Weaknesses':
            obj_ = Related_Weaknesses.factory()
            obj_.build(child_)
            self.set_Related_Weaknesses(obj_)
        elif nodeName_ == 'Related_Vulnerabilities':
            obj_ = Related_Vulnerabilities.factory()
            obj_.build(child_)
            self.set_Related_Vulnerabilities(obj_)
        elif nodeName_ == 'Related_Attack_Patterns':
            obj_ = Related_Attack_Patterns.factory()
            obj_.build(child_)
            self.set_Related_Attack_Patterns(obj_)
        elif nodeName_ == 'Relevant_Security_Requirements':
            obj_ = Relevant_Security_Requirements.factory()
            obj_.build(child_)
            self.set_Relevant_Security_Requirements(obj_)
        elif nodeName_ == 'Relevant_Design_Patterns':
            obj_ = Relevant_Design_Patterns.factory()
            obj_.build(child_)
            self.set_Relevant_Design_Patterns(obj_)
        elif nodeName_ == 'Relevant_Security_Patterns':
            obj_ = Relevant_Security_Patterns.factory()
            obj_.build(child_)
            self.set_Relevant_Security_Patterns(obj_)
        elif nodeName_ == 'Related_Security_Principles':
            obj_ = Related_Security_Principles.factory()
            obj_.build(child_)
            self.set_Related_Security_Principles(obj_)
        elif nodeName_ == 'Related_Guidelines':
            obj_ = Related_Guidelines.factory()
            obj_.build(child_)
            self.set_Related_Guidelines(obj_)
        elif nodeName_ == 'Purposes':
            obj_ = Purposes.factory()
            obj_.build(child_)
            self.set_Purposes(obj_)
        elif nodeName_ == 'CIA_Impact':
            obj_ = CIA_Impact.factory()
            obj_.build(child_)
            self.set_CIA_Impact(obj_)
        elif nodeName_ == 'Technical_Context':
            obj_ = Technical_Context.factory()
            obj_.build(child_)
            self.set_Technical_Context(obj_)
        elif nodeName_ == 'Keywords':
            obj_ = Keywords.factory()
            obj_.build(child_)
            self.set_Keywords(obj_)
        elif nodeName_ == 'References':
            obj_ = References.factory()
            obj_.build(child_)
            self.set_References(obj_)
        elif nodeName_ == 'Other_Notes':
            obj_ = Other_Notes.factory()
            obj_.build(child_)
            self.set_Other_Notes(obj_)
        elif nodeName_ == 'Maintenance_Notes':
            obj_ = Maintenance_Notes.factory()
            obj_.build(child_)
            self.set_Maintenance_Notes(obj_)
        elif nodeName_ == 'Content_History':
            obj_ = Content_History.factory()
            obj_.build(child_)
            self.set_Content_History(obj_)
# end class Attack_PatternType


class Typical_Severity(GeneratedsSuper):
    """On a rough scale (Very Low, Low, Medium, High, Very high), what is
    the typical severity of impact to the targeted software if this
    attack occurs? The severity of a specific attack instance can
    vary greatly depending on the specific context of the target
    software under attack. This field is intended to capture an
    overall typical average value for this type of attack with the
    understanding that it will not be completely accurate for all
    attacks."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Typical_Severity.subclass:
            return Typical_Severity.subclass(*args_, **kwargs_)
        else:
            return Typical_Severity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Typical_Severity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Typical_Severity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Typical_Severity'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Typical_Severity', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Typical_Severity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Typical_Severity


class Typical_Likelihood_of_Exploit(GeneratedsSuper):
    """On a rough scale (Very Low, Low Medium, High, Very High), what is
    the overall likelihood of this type of attack typically
    succeeding considering the attack prerequisites, targeted
    weakness attack surface, skill required and resources required
    as well as available and likely implemented blocking solutions?
    The likelihood of exploit of a specific attack instance can vary
    greatly depending on the specific context of the target software
    under attack. This field is intended to capture an overall
    typical average value for this type of attack with the
    understanding that it will not be completely accurate for all
    attacks."""
    subclass = None
    superclass = None
    def __init__(self, Likelihood=None, Explanation=None):
        self.Likelihood = Likelihood
        self.Explanation = Explanation
    def factory(*args_, **kwargs_):
        if Typical_Likelihood_of_Exploit.subclass:
            return Typical_Likelihood_of_Exploit.subclass(*args_, **kwargs_)
        else:
            return Typical_Likelihood_of_Exploit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Likelihood(self): return self.Likelihood
    def set_Likelihood(self, Likelihood): self.Likelihood = Likelihood
    def get_Explanation(self): return self.Explanation
    def set_Explanation(self, Explanation): self.Explanation = Explanation
    def export(self, outfile, level, namespace_='capec:', name_='Typical_Likelihood_of_Exploit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Typical_Likelihood_of_Exploit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Typical_Likelihood_of_Exploit'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Typical_Likelihood_of_Exploit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Likelihood is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLikelihood>%s</%sLikelihood>%s' % (namespace_, self.gds_format_string(quote_xml(self.Likelihood).encode(ExternalEncoding), input_name='Likelihood'), namespace_, eol_))
        if self.Explanation is not None:
            self.Explanation.export(outfile, level, namespace_, name_='Explanation', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Likelihood is not None or
            self.Explanation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Typical_Likelihood_of_Exploit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Likelihood is not None:
            showIndent(outfile, level)
            outfile.write('Likelihood=%s,\n' % quote_python(self.Likelihood).encode(ExternalEncoding))
        if self.Explanation is not None:
            showIndent(outfile, level)
            outfile.write('Explanation=model_.Structured_Text_Type(\n')
            self.Explanation.exportLiteral(outfile, level, name_='Explanation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Likelihood':
            Likelihood_ = child_.text
            Likelihood_ = self.gds_validate_string(Likelihood_, node, 'Likelihood')
            self.Likelihood = Likelihood_
        elif nodeName_ == 'Explanation':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Explanation(obj_)
# end class Typical_Likelihood_of_Exploit


class Examples_Instances(GeneratedsSuper):
    """This field contains explanatory examples or demonstrative exploit
    instances of this attack, which are intended to help the reader
    understand the nature, context and variability of the attack in
    more practical and concrete terms."""
    subclass = None
    superclass = None
    def __init__(self, Example_Instance=None):
        if Example_Instance is None:
            self.Example_Instance = []
        else:
            self.Example_Instance = Example_Instance
    def factory(*args_, **kwargs_):
        if Examples_Instances.subclass:
            return Examples_Instances.subclass(*args_, **kwargs_)
        else:
            return Examples_Instances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Example_Instance(self): return self.Example_Instance
    def set_Example_Instance(self, Example_Instance): self.Example_Instance = Example_Instance
    def add_Example_Instance(self, value): self.Example_Instance.append(value)
    def insert_Example_Instance(self, index, value): self.Example_Instance[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Examples-Instances', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Examples-Instances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Examples-Instances'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Examples-Instances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Example_Instance_ in self.Example_Instance:
            Example_Instance_.export(outfile, level, namespace_, name_='Example-Instance', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Example_Instance
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Examples-Instances'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Example_Instance=[\n')
        level += 1
        for Example_Instance_ in self.Example_Instance:
            showIndent(outfile, level)
            outfile.write('model_.Example_Instance(\n')
            Example_Instance_.exportLiteral(outfile, level, name_='Example-Instance')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Example-Instance':
            obj_ = Example_Instance.factory()
            obj_.build(child_)
            self.Example_Instance.append(obj_)
# end class Examples_Instances


class Example_Instance(GeneratedsSuper):
    """This field describes an individual example or exploit instance."""
    subclass = None
    superclass = None
    def __init__(self, Example_Instance_Description=None, References=None, Example_Instance_Related_Vulnerabilities=None):
        self.Example_Instance_Description = Example_Instance_Description
        self.References = References
        self.Example_Instance_Related_Vulnerabilities = Example_Instance_Related_Vulnerabilities
    def factory(*args_, **kwargs_):
        if Example_Instance.subclass:
            return Example_Instance.subclass(*args_, **kwargs_)
        else:
            return Example_Instance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Example_Instance_Description(self): return self.Example_Instance_Description
    def set_Example_Instance_Description(self, Example_Instance_Description): self.Example_Instance_Description = Example_Instance_Description
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Example_Instance_Related_Vulnerabilities(self): return self.Example_Instance_Related_Vulnerabilities
    def set_Example_Instance_Related_Vulnerabilities(self, Example_Instance_Related_Vulnerabilities): self.Example_Instance_Related_Vulnerabilities = Example_Instance_Related_Vulnerabilities
    def export(self, outfile, level, namespace_='capec:', name_='Example-Instance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Example-Instance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Example-Instance'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Example-Instance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Example_Instance_Description is not None:
            self.Example_Instance_Description.export(outfile, level, namespace_, name_='Example-Instance_Description', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        if self.Example_Instance_Related_Vulnerabilities is not None:
            self.Example_Instance_Related_Vulnerabilities.export(outfile, level, namespace_, name_='Example-Instance_Related_Vulnerabilities', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Example_Instance_Description is not None or
            self.References is not None or
            self.Example_Instance_Related_Vulnerabilities is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Example-Instance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Example_Instance_Description is not None:
            showIndent(outfile, level)
            outfile.write('Example_Instance_Description=model_.Structured_Text_Type(\n')
            self.Example_Instance_Description.exportLiteral(outfile, level, name_='Example_Instance_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.References(\n')
            self.References.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Example_Instance_Related_Vulnerabilities is not None:
            showIndent(outfile, level)
            outfile.write('Example_Instance_Related_Vulnerabilities=model_.Example_Instance_Related_Vulnerabilities(\n')
            self.Example_Instance_Related_Vulnerabilities.exportLiteral(outfile, level, name_='Example_Instance_Related_Vulnerabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Example-Instance_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Example_Instance_Description(obj_)
        elif nodeName_ == 'References':
            obj_ = References.factory()
            obj_.build(child_)
            self.set_References(obj_)
        elif nodeName_ == 'Example-Instance_Related_Vulnerabilities':
            obj_ = Example_Instance_Related_Vulnerabilities.factory()
            obj_.build(child_)
            self.set_Example_Instance_Related_Vulnerabilities(obj_)
# end class Example_Instance


class References(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if References.subclass:
            return References.subclass(*args_, **kwargs_)
        else:
            return References(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='References', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='References')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='References'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='References', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='References'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference_Type(\n')
            Reference_.exportLiteral(outfile, level, name_='Reference_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = Reference_Type.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class References


class Example_Instance_Related_Vulnerabilities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Example_Instance_Related_Vulnerability=None):
        if Example_Instance_Related_Vulnerability is None:
            self.Example_Instance_Related_Vulnerability = []
        else:
            self.Example_Instance_Related_Vulnerability = Example_Instance_Related_Vulnerability
    def factory(*args_, **kwargs_):
        if Example_Instance_Related_Vulnerabilities.subclass:
            return Example_Instance_Related_Vulnerabilities.subclass(*args_, **kwargs_)
        else:
            return Example_Instance_Related_Vulnerabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Example_Instance_Related_Vulnerability(self): return self.Example_Instance_Related_Vulnerability
    def set_Example_Instance_Related_Vulnerability(self, Example_Instance_Related_Vulnerability): self.Example_Instance_Related_Vulnerability = Example_Instance_Related_Vulnerability
    def add_Example_Instance_Related_Vulnerability(self, value): self.Example_Instance_Related_Vulnerability.append(value)
    def insert_Example_Instance_Related_Vulnerability(self, index, value): self.Example_Instance_Related_Vulnerability[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Example-Instance_Related_Vulnerabilities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Example-Instance_Related_Vulnerabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Example-Instance_Related_Vulnerabilities'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Example-Instance_Related_Vulnerabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Example_Instance_Related_Vulnerability_ in self.Example_Instance_Related_Vulnerability:
            Example_Instance_Related_Vulnerability_.export(outfile, level, namespace_, name_='Example-Instance_Related_Vulnerability', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Example_Instance_Related_Vulnerability
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Example-Instance_Related_Vulnerabilities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Example_Instance_Related_Vulnerability=[\n')
        level += 1
        for Example_Instance_Related_Vulnerability_ in self.Example_Instance_Related_Vulnerability:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Example_Instance_Related_Vulnerability_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Example-Instance_Related_Vulnerability':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Example_Instance_Related_Vulnerability.append(obj_)
# end class Example_Instance_Related_Vulnerabilities


class Probing_Techniques(GeneratedsSuper):
    """This field describes techniques typically used to probe and
    reconnoiter a potential target to determine vulnerability and/or
    to prepare for this type of attack."""
    subclass = None
    superclass = None
    def __init__(self, Probing_Technique=None):
        if Probing_Technique is None:
            self.Probing_Technique = []
        else:
            self.Probing_Technique = Probing_Technique
    def factory(*args_, **kwargs_):
        if Probing_Techniques.subclass:
            return Probing_Techniques.subclass(*args_, **kwargs_)
        else:
            return Probing_Techniques(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Probing_Technique(self): return self.Probing_Technique
    def set_Probing_Technique(self, Probing_Technique): self.Probing_Technique = Probing_Technique
    def add_Probing_Technique(self, value): self.Probing_Technique.append(value)
    def insert_Probing_Technique(self, index, value): self.Probing_Technique[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Probing_Techniques', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Probing_Techniques')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Probing_Techniques'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Probing_Techniques', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Probing_Technique_ in self.Probing_Technique:
            Probing_Technique_.export(outfile, level, namespace_, name_='Probing_Technique', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Probing_Technique
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Probing_Techniques'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Probing_Technique=[\n')
        level += 1
        for Probing_Technique_ in self.Probing_Technique:
            showIndent(outfile, level)
            outfile.write('model_.Probing_Technique(\n')
            Probing_Technique_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Probing_Technique':
            obj_ = Probing_Technique.factory()
            obj_.build(child_)
            self.Probing_Technique.append(obj_)
# end class Probing_Techniques


class Probing_Technique(GeneratedsSuper):
    """This field describes an individual probing technique."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Observables=None):
        self.Description = Description
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Probing_Technique.subclass:
            return Probing_Technique.subclass(*args_, **kwargs_)
        else:
            return Probing_Technique(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def export(self, outfile, level, namespace_='capec:', name_='Probing_Technique', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Probing_Technique')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Probing_Technique'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Probing_Technique', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Probing_Technique'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Structured_Text_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Probing_Technique


class Indicators_Warnings_of_Attack(GeneratedsSuper):
    """This field describes activities, events, conditions or behaviors
    that could serve as indicators that an attack of this type is
    imminent, in progress or has occurred."""
    subclass = None
    superclass = None
    def __init__(self, Indicator_Warning_of_Attack=None):
        if Indicator_Warning_of_Attack is None:
            self.Indicator_Warning_of_Attack = []
        else:
            self.Indicator_Warning_of_Attack = Indicator_Warning_of_Attack
    def factory(*args_, **kwargs_):
        if Indicators_Warnings_of_Attack.subclass:
            return Indicators_Warnings_of_Attack.subclass(*args_, **kwargs_)
        else:
            return Indicators_Warnings_of_Attack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Indicator_Warning_of_Attack(self): return self.Indicator_Warning_of_Attack
    def set_Indicator_Warning_of_Attack(self, Indicator_Warning_of_Attack): self.Indicator_Warning_of_Attack = Indicator_Warning_of_Attack
    def add_Indicator_Warning_of_Attack(self, value): self.Indicator_Warning_of_Attack.append(value)
    def insert_Indicator_Warning_of_Attack(self, index, value): self.Indicator_Warning_of_Attack[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Indicators-Warnings_of_Attack', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indicators-Warnings_of_Attack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Indicators-Warnings_of_Attack'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Indicators-Warnings_of_Attack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Indicator_Warning_of_Attack_ in self.Indicator_Warning_of_Attack:
            Indicator_Warning_of_Attack_.export(outfile, level, namespace_, name_='Indicator-Warning_of_Attack', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Indicator_Warning_of_Attack
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Indicators-Warnings_of_Attack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Indicator_Warning_of_Attack=[\n')
        level += 1
        for Indicator_Warning_of_Attack_ in self.Indicator_Warning_of_Attack:
            showIndent(outfile, level)
            outfile.write('model_.Indicator_Warning_of_Attack(\n')
            Indicator_Warning_of_Attack_.exportLiteral(outfile, level, name_='Indicator-Warning_of_Attack')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Indicator-Warning_of_Attack':
            obj_ = Indicator_Warning_of_Attack.factory()
            obj_.build(child_)
            self.Indicator_Warning_of_Attack.append(obj_)
# end class Indicators_Warnings_of_Attack


class Indicator_Warning_of_Attack(GeneratedsSuper):
    """This field describes an individual indicator/warning."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Observables=None):
        self.Description = Description
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Indicator_Warning_of_Attack.subclass:
            return Indicator_Warning_of_Attack.subclass(*args_, **kwargs_)
        else:
            return Indicator_Warning_of_Attack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def export(self, outfile, level, namespace_='capec:', name_='Indicator-Warning_of_Attack', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Indicator-Warning_of_Attack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Indicator-Warning_of_Attack'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Indicator-Warning_of_Attack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Indicator-Warning_of_Attack'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Structured_Text_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Indicator_Warning_of_Attack


class Solutions_and_Mitigations(GeneratedsSuper):
    """This field describes actions or approaches that can potentially
    prevent or mitigate the risk of this attack. These solutions and
    mitigations are targeted to improve the resistance of the target
    software and thereby reduce the likelihood of the attack’s
    success or to improve the resilience of the target software and
    thereby reduce the impact of the attack if it is successful."""
    subclass = None
    superclass = None
    def __init__(self, Solution_or_Mitigation=None):
        if Solution_or_Mitigation is None:
            self.Solution_or_Mitigation = []
        else:
            self.Solution_or_Mitigation = Solution_or_Mitigation
    def factory(*args_, **kwargs_):
        if Solutions_and_Mitigations.subclass:
            return Solutions_and_Mitigations.subclass(*args_, **kwargs_)
        else:
            return Solutions_and_Mitigations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Solution_or_Mitigation(self): return self.Solution_or_Mitigation
    def set_Solution_or_Mitigation(self, Solution_or_Mitigation): self.Solution_or_Mitigation = Solution_or_Mitigation
    def add_Solution_or_Mitigation(self, value): self.Solution_or_Mitigation.append(value)
    def insert_Solution_or_Mitigation(self, index, value): self.Solution_or_Mitigation[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Solutions_and_Mitigations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Solutions_and_Mitigations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Solutions_and_Mitigations'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Solutions_and_Mitigations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Solution_or_Mitigation_ in self.Solution_or_Mitigation:
            Solution_or_Mitigation_.export(outfile, level, namespace_, name_='Solution_or_Mitigation', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Solution_or_Mitigation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Solutions_and_Mitigations'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Solution_or_Mitigation=[\n')
        level += 1
        for Solution_or_Mitigation_ in self.Solution_or_Mitigation:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Solution_or_Mitigation_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Solution_or_Mitigation':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Solution_or_Mitigation.append(obj_)
# end class Solutions_and_Mitigations


class Payload_Activation_Impact(GeneratedsSuper):
    """This field is a description of the impact that the activation of the
    attack payload for an injection-based attack of this type would
    typically have on the confidentiality, integrity or availability
    of the target software."""
    subclass = None
    superclass = None
    def __init__(self, Description=None, Observables=None):
        self.Description = Description
        self.Observables = Observables
    def factory(*args_, **kwargs_):
        if Payload_Activation_Impact.subclass:
            return Payload_Activation_Impact.subclass(*args_, **kwargs_)
        else:
            return Payload_Activation_Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def export(self, outfile, level, namespace_='capec:', name_='Payload_Activation_Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Payload_Activation_Impact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Payload_Activation_Impact'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Payload_Activation_Impact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, namespace_, name_='Observables', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Payload_Activation_Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Structured_Text_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            showIndent(outfile, level)
            outfile.write('Observables=model_.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox_core_binding.ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Payload_Activation_Impact


class Related_Vulnerabilities(GeneratedsSuper):
    """What specific vulnerabilities does this attack target and leverage?
    Specific vulnerabilities should reference industry-standard
    identifiers such as Common Vulnerabilities and Exposures (CVE )
    numbers and/or US-CERT numbers. As vulnerabilities are much more
    specific and localized than weaknesses, it is typically rare
    that an attack pattern will target specific vulnerabilities.
    This would most likely occur if they are targeting
    vulnerabilities in underlying platforms, frameworks, libraries,
    etc."""
    subclass = None
    superclass = None
    def __init__(self, Related_Vulnerability=None):
        if Related_Vulnerability is None:
            self.Related_Vulnerability = []
        else:
            self.Related_Vulnerability = Related_Vulnerability
    def factory(*args_, **kwargs_):
        if Related_Vulnerabilities.subclass:
            return Related_Vulnerabilities.subclass(*args_, **kwargs_)
        else:
            return Related_Vulnerabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Vulnerability(self): return self.Related_Vulnerability
    def set_Related_Vulnerability(self, Related_Vulnerability): self.Related_Vulnerability = Related_Vulnerability
    def add_Related_Vulnerability(self, value): self.Related_Vulnerability.append(value)
    def insert_Related_Vulnerability(self, index, value): self.Related_Vulnerability[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Related_Vulnerabilities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Vulnerabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Vulnerabilities'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Vulnerabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Vulnerability_ in self.Related_Vulnerability:
            Related_Vulnerability_.export(outfile, level, namespace_, name_='Related_Vulnerability', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Related_Vulnerability
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Vulnerabilities'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Vulnerability=[\n')
        level += 1
        for Related_Vulnerability_ in self.Related_Vulnerability:
            showIndent(outfile, level)
            outfile.write('model_.Related_Vulnerability(\n')
            Related_Vulnerability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Vulnerability':
            obj_ = Related_Vulnerability.factory()
            obj_.build(child_)
            self.Related_Vulnerability.append(obj_)
# end class Related_Vulnerabilities


class Related_Vulnerability(GeneratedsSuper):
    """This field describes an individual related vulnerability."""
    subclass = None
    superclass = None
    def __init__(self, Vulnerability_ID=None, Vulnerability_Description=None):
        self.Vulnerability_ID = Vulnerability_ID
        self.Vulnerability_Description = Vulnerability_Description
    def factory(*args_, **kwargs_):
        if Related_Vulnerability.subclass:
            return Related_Vulnerability.subclass(*args_, **kwargs_)
        else:
            return Related_Vulnerability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vulnerability_ID(self): return self.Vulnerability_ID
    def set_Vulnerability_ID(self, Vulnerability_ID): self.Vulnerability_ID = Vulnerability_ID
    def get_Vulnerability_Description(self): return self.Vulnerability_Description
    def set_Vulnerability_Description(self, Vulnerability_Description): self.Vulnerability_Description = Vulnerability_Description
    def export(self, outfile, level, namespace_='capec:', name_='Related_Vulnerability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Vulnerability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Vulnerability'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Vulnerability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Vulnerability_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVulnerability_ID>%s</%sVulnerability_ID>%s' % (namespace_, self.gds_format_string(quote_xml(self.Vulnerability_ID).encode(ExternalEncoding), input_name='Vulnerability_ID'), namespace_, eol_))
        if self.Vulnerability_Description is not None:
            self.Vulnerability_Description.export(outfile, level, namespace_, name_='Vulnerability_Description', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Vulnerability_ID is not None or
            self.Vulnerability_Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Vulnerability'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Vulnerability_ID is not None:
            showIndent(outfile, level)
            outfile.write('Vulnerability_ID=%s,\n' % quote_python(self.Vulnerability_ID).encode(ExternalEncoding))
        if self.Vulnerability_Description is not None:
            showIndent(outfile, level)
            outfile.write('Vulnerability_Description=model_.Structured_Text_Type(\n')
            self.Vulnerability_Description.exportLiteral(outfile, level, name_='Vulnerability_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vulnerability_ID':
            Vulnerability_ID_ = child_.text
            Vulnerability_ID_ = self.gds_validate_string(Vulnerability_ID_, node, 'Vulnerability_ID')
            self.Vulnerability_ID = Vulnerability_ID_
        elif nodeName_ == 'Vulnerability_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Vulnerability_Description(obj_)
# end class Related_Vulnerability


class Related_Attack_Patterns(GeneratedsSuper):
    """This field identifies other attack patterns that are somehow related
    to, dependent on, typically chained together, etc. with this
    pattern."""
    subclass = None
    superclass = None
    def __init__(self, Related_Attack_Pattern=None):
        if Related_Attack_Pattern is None:
            self.Related_Attack_Pattern = []
        else:
            self.Related_Attack_Pattern = Related_Attack_Pattern
    def factory(*args_, **kwargs_):
        if Related_Attack_Patterns.subclass:
            return Related_Attack_Patterns.subclass(*args_, **kwargs_)
        else:
            return Related_Attack_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Attack_Pattern(self): return self.Related_Attack_Pattern
    def set_Related_Attack_Pattern(self, Related_Attack_Pattern): self.Related_Attack_Pattern = Related_Attack_Pattern
    def add_Related_Attack_Pattern(self, value): self.Related_Attack_Pattern.append(value)
    def insert_Related_Attack_Pattern(self, index, value): self.Related_Attack_Pattern[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Related_Attack_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Attack_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Attack_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Attack_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Attack_Pattern_ in self.Related_Attack_Pattern:
            Related_Attack_Pattern_.export(outfile, level, namespace_, name_='Related_Attack_Pattern', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Related_Attack_Pattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Attack_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Attack_Pattern=[\n')
        level += 1
        for Related_Attack_Pattern_ in self.Related_Attack_Pattern:
            showIndent(outfile, level)
            outfile.write('model_.RelationshipType(\n')
            Related_Attack_Pattern_.exportLiteral(outfile, level, name_='RelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Attack_Pattern':
            obj_ = RelationshipType.factory()
            obj_.build(child_)
            self.Related_Attack_Pattern.append(obj_)
# end class Related_Attack_Patterns


class Relevant_Security_Requirements(GeneratedsSuper):
    """This field identifies specific security requirements that are
    relevant to this type of attack and are general enough to offer
    opportunities for reuse."""
    subclass = None
    superclass = None
    def __init__(self, Relevant_Security_Requirement=None):
        if Relevant_Security_Requirement is None:
            self.Relevant_Security_Requirement = []
        else:
            self.Relevant_Security_Requirement = Relevant_Security_Requirement
    def factory(*args_, **kwargs_):
        if Relevant_Security_Requirements.subclass:
            return Relevant_Security_Requirements.subclass(*args_, **kwargs_)
        else:
            return Relevant_Security_Requirements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Security_Requirement(self): return self.Relevant_Security_Requirement
    def set_Relevant_Security_Requirement(self, Relevant_Security_Requirement): self.Relevant_Security_Requirement = Relevant_Security_Requirement
    def add_Relevant_Security_Requirement(self, value): self.Relevant_Security_Requirement.append(value)
    def insert_Relevant_Security_Requirement(self, index, value): self.Relevant_Security_Requirement[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Security_Requirements', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Security_Requirements')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Security_Requirements'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Security_Requirements', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relevant_Security_Requirement_ in self.Relevant_Security_Requirement:
            Relevant_Security_Requirement_.export(outfile, level, namespace_, name_='Relevant_Security_Requirement', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relevant_Security_Requirement
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Security_Requirements'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relevant_Security_Requirement=[\n')
        level += 1
        for Relevant_Security_Requirement_ in self.Relevant_Security_Requirement:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Relevant_Security_Requirement_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Security_Requirement':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Relevant_Security_Requirement.append(obj_)
# end class Relevant_Security_Requirements


class Relevant_Design_Patterns(GeneratedsSuper):
    """This field identifies specific relevant design patterns that are
    recommended as providing resistance or resilience to this
    attack, or which are not recommended as they are particularly
    susceptible to this type of attack."""
    subclass = None
    superclass = None
    def __init__(self, Recommended_Design_Patterns=None, Non_Recommended_Design_Patterns=None):
        self.Recommended_Design_Patterns = Recommended_Design_Patterns
        self.Non_Recommended_Design_Patterns = Non_Recommended_Design_Patterns
    def factory(*args_, **kwargs_):
        if Relevant_Design_Patterns.subclass:
            return Relevant_Design_Patterns.subclass(*args_, **kwargs_)
        else:
            return Relevant_Design_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Recommended_Design_Patterns(self): return self.Recommended_Design_Patterns
    def set_Recommended_Design_Patterns(self, Recommended_Design_Patterns): self.Recommended_Design_Patterns = Recommended_Design_Patterns
    def get_Non_Recommended_Design_Patterns(self): return self.Non_Recommended_Design_Patterns
    def set_Non_Recommended_Design_Patterns(self, Non_Recommended_Design_Patterns): self.Non_Recommended_Design_Patterns = Non_Recommended_Design_Patterns
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Design_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Design_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Design_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Design_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Recommended_Design_Patterns is not None:
            self.Recommended_Design_Patterns.export(outfile, level, namespace_, name_='Recommended_Design_Patterns', pretty_print=pretty_print)
        if self.Non_Recommended_Design_Patterns is not None:
            self.Non_Recommended_Design_Patterns.export(outfile, level, namespace_, name_='Non-Recommended_Design_Patterns', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Recommended_Design_Patterns is not None or
            self.Non_Recommended_Design_Patterns is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Design_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Recommended_Design_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Recommended_Design_Patterns=model_.Recommended_Design_Patterns(\n')
            self.Recommended_Design_Patterns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Non_Recommended_Design_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Non_Recommended_Design_Patterns=model_.Non_Recommended_Design_Patterns(\n')
            self.Non_Recommended_Design_Patterns.exportLiteral(outfile, level, name_='Non_Recommended_Design_Patterns')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Recommended_Design_Patterns':
            obj_ = Recommended_Design_Patterns.factory()
            obj_.build(child_)
            self.set_Recommended_Design_Patterns(obj_)
        elif nodeName_ == 'Non-Recommended_Design_Patterns':
            obj_ = Non_Recommended_Design_Patterns.factory()
            obj_.build(child_)
            self.set_Non_Recommended_Design_Patterns(obj_)
# end class Relevant_Design_Patterns


class Recommended_Design_Patterns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Recommended_Design_Pattern=None):
        if Recommended_Design_Pattern is None:
            self.Recommended_Design_Pattern = []
        else:
            self.Recommended_Design_Pattern = Recommended_Design_Pattern
    def factory(*args_, **kwargs_):
        if Recommended_Design_Patterns.subclass:
            return Recommended_Design_Patterns.subclass(*args_, **kwargs_)
        else:
            return Recommended_Design_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Recommended_Design_Pattern(self): return self.Recommended_Design_Pattern
    def set_Recommended_Design_Pattern(self, Recommended_Design_Pattern): self.Recommended_Design_Pattern = Recommended_Design_Pattern
    def add_Recommended_Design_Pattern(self, value): self.Recommended_Design_Pattern.append(value)
    def insert_Recommended_Design_Pattern(self, index, value): self.Recommended_Design_Pattern[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Recommended_Design_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Recommended_Design_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Recommended_Design_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Recommended_Design_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Recommended_Design_Pattern_ in self.Recommended_Design_Pattern:
            Recommended_Design_Pattern_.export(outfile, level, namespace_, name_='Recommended_Design_Pattern', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Recommended_Design_Pattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Recommended_Design_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Recommended_Design_Pattern=[\n')
        level += 1
        for Recommended_Design_Pattern_ in self.Recommended_Design_Pattern:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Recommended_Design_Pattern_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Recommended_Design_Pattern':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Recommended_Design_Pattern.append(obj_)
# end class Recommended_Design_Patterns


class Non_Recommended_Design_Patterns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Non_Recommended_Design_Pattern=None):
        if Non_Recommended_Design_Pattern is None:
            self.Non_Recommended_Design_Pattern = []
        else:
            self.Non_Recommended_Design_Pattern = Non_Recommended_Design_Pattern
    def factory(*args_, **kwargs_):
        if Non_Recommended_Design_Patterns.subclass:
            return Non_Recommended_Design_Patterns.subclass(*args_, **kwargs_)
        else:
            return Non_Recommended_Design_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Non_Recommended_Design_Pattern(self): return self.Non_Recommended_Design_Pattern
    def set_Non_Recommended_Design_Pattern(self, Non_Recommended_Design_Pattern): self.Non_Recommended_Design_Pattern = Non_Recommended_Design_Pattern
    def add_Non_Recommended_Design_Pattern(self, value): self.Non_Recommended_Design_Pattern.append(value)
    def insert_Non_Recommended_Design_Pattern(self, index, value): self.Non_Recommended_Design_Pattern[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Non-Recommended_Design_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Non-Recommended_Design_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Non-Recommended_Design_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Non-Recommended_Design_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Non_Recommended_Design_Pattern_ in self.Non_Recommended_Design_Pattern:
            Non_Recommended_Design_Pattern_.export(outfile, level, namespace_, name_='Non-Recommended_Design_Pattern', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Non_Recommended_Design_Pattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Non-Recommended_Design_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Non_Recommended_Design_Pattern=[\n')
        level += 1
        for Non_Recommended_Design_Pattern_ in self.Non_Recommended_Design_Pattern:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Non_Recommended_Design_Pattern_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Non-Recommended_Design_Pattern':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Non_Recommended_Design_Pattern.append(obj_)
# end class Non_Recommended_Design_Patterns


class Relevant_Security_Patterns(GeneratedsSuper):
    """This field identifies specific security patterns that are
    recommended as providing resistance or resilience to this type
    of attack."""
    subclass = None
    superclass = None
    def __init__(self, Relevant_Security_Pattern=None):
        if Relevant_Security_Pattern is None:
            self.Relevant_Security_Pattern = []
        else:
            self.Relevant_Security_Pattern = Relevant_Security_Pattern
    def factory(*args_, **kwargs_):
        if Relevant_Security_Patterns.subclass:
            return Relevant_Security_Patterns.subclass(*args_, **kwargs_)
        else:
            return Relevant_Security_Patterns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Security_Pattern(self): return self.Relevant_Security_Pattern
    def set_Relevant_Security_Pattern(self, Relevant_Security_Pattern): self.Relevant_Security_Pattern = Relevant_Security_Pattern
    def add_Relevant_Security_Pattern(self, value): self.Relevant_Security_Pattern.append(value)
    def insert_Relevant_Security_Pattern(self, index, value): self.Relevant_Security_Pattern[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Security_Patterns', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Security_Patterns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Security_Patterns'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Security_Patterns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Relevant_Security_Pattern_ in self.Relevant_Security_Pattern:
            Relevant_Security_Pattern_.export(outfile, level, namespace_, name_='Relevant_Security_Pattern', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Relevant_Security_Pattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Relevant_Security_Patterns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Relevant_Security_Pattern=[\n')
        level += 1
        for Relevant_Security_Pattern_ in self.Relevant_Security_Pattern:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Relevant_Security_Pattern_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Security_Pattern':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Relevant_Security_Pattern.append(obj_)
# end class Relevant_Security_Patterns


class Related_Security_Principles(GeneratedsSuper):
    """This field identifies specific security principles relevant to this
    attack pattern. The security principles that this field
    references come from the set available on the Build Security In
    website."""
    subclass = None
    superclass = None
    def __init__(self, Related_Security_Principle=None):
        if Related_Security_Principle is None:
            self.Related_Security_Principle = []
        else:
            self.Related_Security_Principle = Related_Security_Principle
    def factory(*args_, **kwargs_):
        if Related_Security_Principles.subclass:
            return Related_Security_Principles.subclass(*args_, **kwargs_)
        else:
            return Related_Security_Principles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Security_Principle(self): return self.Related_Security_Principle
    def set_Related_Security_Principle(self, Related_Security_Principle): self.Related_Security_Principle = Related_Security_Principle
    def add_Related_Security_Principle(self, value): self.Related_Security_Principle.append(value)
    def insert_Related_Security_Principle(self, index, value): self.Related_Security_Principle[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Related_Security_Principles', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Security_Principles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Security_Principles'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Security_Principles', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Security_Principle_ in self.Related_Security_Principle:
            Related_Security_Principle_.export(outfile, level, namespace_, name_='Related_Security_Principle', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Related_Security_Principle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Security_Principles'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Security_Principle=[\n')
        level += 1
        for Related_Security_Principle_ in self.Related_Security_Principle:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Related_Security_Principle_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Security_Principle':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Related_Security_Principle.append(obj_)
# end class Related_Security_Principles


class Related_Guidelines(GeneratedsSuper):
    """This field identifies existing security guidelines that are relevant
    to identifying or mitigating this type of attack."""
    subclass = None
    superclass = None
    def __init__(self, Related_Guideline=None):
        if Related_Guideline is None:
            self.Related_Guideline = []
        else:
            self.Related_Guideline = Related_Guideline
    def factory(*args_, **kwargs_):
        if Related_Guidelines.subclass:
            return Related_Guidelines.subclass(*args_, **kwargs_)
        else:
            return Related_Guidelines(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Guideline(self): return self.Related_Guideline
    def set_Related_Guideline(self, Related_Guideline): self.Related_Guideline = Related_Guideline
    def add_Related_Guideline(self, value): self.Related_Guideline.append(value)
    def insert_Related_Guideline(self, index, value): self.Related_Guideline[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Related_Guidelines', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Related_Guidelines')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Related_Guidelines'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Related_Guidelines', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Guideline_ in self.Related_Guideline:
            Related_Guideline_.export(outfile, level, namespace_, name_='Related_Guideline', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Related_Guideline
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Related_Guidelines'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Related_Guideline=[\n')
        level += 1
        for Related_Guideline_ in self.Related_Guideline:
            showIndent(outfile, level)
            outfile.write('model_.Structured_Text_Type(\n')
            Related_Guideline_.exportLiteral(outfile, level, name_='Structured_Text_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Guideline':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.Related_Guideline.append(obj_)
# end class Related_Guidelines


class Purposes(GeneratedsSuper):
    """This field describes the generalized purposes of the pattern in
    order to enable the capture of pattern composibility. In order
    to assist in normalization and classification, this field
    involves a selection from an enumerated list of defined purposes
    which may be currently incomplete and may grow as new relevant
    possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self, Purpose=None):
        if Purpose is None:
            self.Purpose = []
        else:
            self.Purpose = Purpose
    def factory(*args_, **kwargs_):
        if Purposes.subclass:
            return Purposes.subclass(*args_, **kwargs_)
        else:
            return Purposes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Purpose(self): return self.Purpose
    def set_Purpose(self, Purpose): self.Purpose = Purpose
    def add_Purpose(self, value): self.Purpose.append(value)
    def insert_Purpose(self, index, value): self.Purpose[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Purposes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Purposes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Purposes'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Purposes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Purpose_ in self.Purpose:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPurpose>%s</%sPurpose>%s' % (namespace_, self.gds_format_string(quote_xml(Purpose_).encode(ExternalEncoding), input_name='Purpose'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Purpose
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Purposes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Purpose=[\n')
        level += 1
        for Purpose_ in self.Purpose:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Purpose_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Purpose':
            Purpose_ = child_.text
            Purpose_ = self.gds_validate_string(Purpose_, node, 'Purpose')
            self.Purpose.append(Purpose_)
# end class Purposes


class Purpose(GeneratedsSuper):
    """This field describes the generalized purpose of the pattern in order
    to enable the capture of pattern composibility. In order to
    assist in normalization and classification, this field involves
    a selection from an enumerated list of defined purposes which
    may be currently incomplete and may grow as new relevant
    possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Purpose.subclass:
            return Purpose.subclass(*args_, **kwargs_)
        else:
            return Purpose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Purpose', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Purpose')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Purpose'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Purpose', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Purpose'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Purpose


class CIA_Impact(GeneratedsSuper):
    """This field characterizes the typical relative impact of this pattern
    on the confidentiality, integrity and availability of the
    targeted software."""
    subclass = None
    superclass = None
    def __init__(self, Confidentiality_Impact=None, Integrity_Impact=None, Availability_Impact=None):
        self.Confidentiality_Impact = Confidentiality_Impact
        self.Integrity_Impact = Integrity_Impact
        self.Availability_Impact = Availability_Impact
    def factory(*args_, **kwargs_):
        if CIA_Impact.subclass:
            return CIA_Impact.subclass(*args_, **kwargs_)
        else:
            return CIA_Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Confidentiality_Impact(self): return self.Confidentiality_Impact
    def set_Confidentiality_Impact(self, Confidentiality_Impact): self.Confidentiality_Impact = Confidentiality_Impact
    def get_Integrity_Impact(self): return self.Integrity_Impact
    def set_Integrity_Impact(self, Integrity_Impact): self.Integrity_Impact = Integrity_Impact
    def get_Availability_Impact(self): return self.Availability_Impact
    def set_Availability_Impact(self, Availability_Impact): self.Availability_Impact = Availability_Impact
    def export(self, outfile, level, namespace_='capec:', name_='CIA_Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIA_Impact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='CIA_Impact'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='CIA_Impact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Confidentiality_Impact is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConfidentiality_Impact>%s</%sConfidentiality_Impact>%s' % (namespace_, self.gds_format_string(quote_xml(self.Confidentiality_Impact).encode(ExternalEncoding), input_name='Confidentiality_Impact'), namespace_, eol_))
        if self.Integrity_Impact is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIntegrity_Impact>%s</%sIntegrity_Impact>%s' % (namespace_, self.gds_format_string(quote_xml(self.Integrity_Impact).encode(ExternalEncoding), input_name='Integrity_Impact'), namespace_, eol_))
        if self.Availability_Impact is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAvailability_Impact>%s</%sAvailability_Impact>%s' % (namespace_, self.gds_format_string(quote_xml(self.Availability_Impact).encode(ExternalEncoding), input_name='Availability_Impact'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Confidentiality_Impact is not None or
            self.Integrity_Impact is not None or
            self.Availability_Impact is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CIA_Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Confidentiality_Impact is not None:
            showIndent(outfile, level)
            outfile.write('Confidentiality_Impact=%s,\n' % quote_python(self.Confidentiality_Impact).encode(ExternalEncoding))
        if self.Integrity_Impact is not None:
            showIndent(outfile, level)
            outfile.write('Integrity_Impact=%s,\n' % quote_python(self.Integrity_Impact).encode(ExternalEncoding))
        if self.Availability_Impact is not None:
            showIndent(outfile, level)
            outfile.write('Availability_Impact=%s,\n' % quote_python(self.Availability_Impact).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Confidentiality_Impact':
            Confidentiality_Impact_ = child_.text
            Confidentiality_Impact_ = self.gds_validate_string(Confidentiality_Impact_, node, 'Confidentiality_Impact')
            self.Confidentiality_Impact = Confidentiality_Impact_
        elif nodeName_ == 'Integrity_Impact':
            Integrity_Impact_ = child_.text
            Integrity_Impact_ = self.gds_validate_string(Integrity_Impact_, node, 'Integrity_Impact')
            self.Integrity_Impact = Integrity_Impact_
        elif nodeName_ == 'Availability_Impact':
            Availability_Impact_ = child_.text
            Availability_Impact_ = self.gds_validate_string(Availability_Impact_, node, 'Availability_Impact')
            self.Availability_Impact = Availability_Impact_
# end class CIA_Impact


class Confidentiality_Impact(GeneratedsSuper):
    """This field describes the typical impact of this pattern on the
    confidentiality characteristics of the targeted software and
    related data."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Confidentiality_Impact.subclass:
            return Confidentiality_Impact.subclass(*args_, **kwargs_)
        else:
            return Confidentiality_Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Confidentiality_Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Confidentiality_Impact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Confidentiality_Impact'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Confidentiality_Impact', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Confidentiality_Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Confidentiality_Impact


class Integrity_Impact(GeneratedsSuper):
    """This field describes the typical impact of this pattern on the
    integrity characteristics of the targeted software and related
    data."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Integrity_Impact.subclass:
            return Integrity_Impact.subclass(*args_, **kwargs_)
        else:
            return Integrity_Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Integrity_Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Integrity_Impact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Integrity_Impact'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Integrity_Impact', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Integrity_Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Integrity_Impact


class Availability_Impact(GeneratedsSuper):
    """This field describes the typical impact of this pattern on the
    availability characteristics of the targeted software and
    related data."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Availability_Impact.subclass:
            return Availability_Impact.subclass(*args_, **kwargs_)
        else:
            return Availability_Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Availability_Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Availability_Impact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Availability_Impact'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Availability_Impact', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Availability_Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Availability_Impact


class Technical_Context(GeneratedsSuper):
    """This field characterizes the technical context where this pattern is
    applicable."""
    subclass = None
    superclass = None
    def __init__(self, Architectural_Paradigms=None, Frameworks=None, Platforms=None, Languages=None):
        self.Architectural_Paradigms = Architectural_Paradigms
        self.Frameworks = Frameworks
        self.Platforms = Platforms
        self.Languages = Languages
    def factory(*args_, **kwargs_):
        if Technical_Context.subclass:
            return Technical_Context.subclass(*args_, **kwargs_)
        else:
            return Technical_Context(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Architectural_Paradigms(self): return self.Architectural_Paradigms
    def set_Architectural_Paradigms(self, Architectural_Paradigms): self.Architectural_Paradigms = Architectural_Paradigms
    def get_Frameworks(self): return self.Frameworks
    def set_Frameworks(self, Frameworks): self.Frameworks = Frameworks
    def get_Platforms(self): return self.Platforms
    def set_Platforms(self, Platforms): self.Platforms = Platforms
    def get_Languages(self): return self.Languages
    def set_Languages(self, Languages): self.Languages = Languages
    def export(self, outfile, level, namespace_='capec:', name_='Technical_Context', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Technical_Context')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Technical_Context'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Technical_Context', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Architectural_Paradigms is not None:
            self.Architectural_Paradigms.export(outfile, level, namespace_, name_='Architectural_Paradigms', pretty_print=pretty_print)
        if self.Frameworks is not None:
            self.Frameworks.export(outfile, level, namespace_, name_='Frameworks', pretty_print=pretty_print)
        if self.Platforms is not None:
            self.Platforms.export(outfile, level, namespace_, name_='Platforms', pretty_print=pretty_print)
        if self.Languages is not None:
            self.Languages.export(outfile, level, namespace_, name_='Languages', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Architectural_Paradigms is not None or
            self.Frameworks is not None or
            self.Platforms is not None or
            self.Languages is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Technical_Context'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Architectural_Paradigms is not None:
            showIndent(outfile, level)
            outfile.write('Architectural_Paradigms=model_.Architectural_Paradigms(\n')
            self.Architectural_Paradigms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Frameworks is not None:
            showIndent(outfile, level)
            outfile.write('Frameworks=model_.Frameworks(\n')
            self.Frameworks.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Platforms is not None:
            showIndent(outfile, level)
            outfile.write('Platforms=model_.Platforms(\n')
            self.Platforms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Languages is not None:
            showIndent(outfile, level)
            outfile.write('Languages=model_.Languages(\n')
            self.Languages.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Architectural_Paradigms':
            obj_ = Architectural_Paradigms.factory()
            obj_.build(child_)
            self.set_Architectural_Paradigms(obj_)
        elif nodeName_ == 'Frameworks':
            obj_ = Frameworks.factory()
            obj_.build(child_)
            self.set_Frameworks(obj_)
        elif nodeName_ == 'Platforms':
            obj_ = Platforms.factory()
            obj_.build(child_)
            self.set_Platforms(obj_)
        elif nodeName_ == 'Languages':
            obj_ = Languages.factory()
            obj_.build(child_)
            self.set_Languages(obj_)
# end class Technical_Context


class Architectural_Paradigms(GeneratedsSuper):
    """This field outlines the architectural paradigms of target software
    where the pattern is possible and relevant. In order to assist
    in normalization and classification, this field involves a
    selection from an enumerated list of defined paradigms which may
    be currently incomplete and may grow or change as new relevant
    possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self, Architectural_Paradigm=None):
        if Architectural_Paradigm is None:
            self.Architectural_Paradigm = []
        else:
            self.Architectural_Paradigm = Architectural_Paradigm
    def factory(*args_, **kwargs_):
        if Architectural_Paradigms.subclass:
            return Architectural_Paradigms.subclass(*args_, **kwargs_)
        else:
            return Architectural_Paradigms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Architectural_Paradigm(self): return self.Architectural_Paradigm
    def set_Architectural_Paradigm(self, Architectural_Paradigm): self.Architectural_Paradigm = Architectural_Paradigm
    def add_Architectural_Paradigm(self, value): self.Architectural_Paradigm.append(value)
    def insert_Architectural_Paradigm(self, index, value): self.Architectural_Paradigm[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Architectural_Paradigms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Architectural_Paradigms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Architectural_Paradigms'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Architectural_Paradigms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Architectural_Paradigm_ in self.Architectural_Paradigm:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sArchitectural_Paradigm>%s</%sArchitectural_Paradigm>%s' % (namespace_, self.gds_format_string(quote_xml(Architectural_Paradigm_).encode(ExternalEncoding), input_name='Architectural_Paradigm'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Architectural_Paradigm
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Architectural_Paradigms'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Architectural_Paradigm=[\n')
        level += 1
        for Architectural_Paradigm_ in self.Architectural_Paradigm:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Architectural_Paradigm_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Architectural_Paradigm':
            Architectural_Paradigm_ = child_.text
            Architectural_Paradigm_ = self.gds_validate_string(Architectural_Paradigm_, node, 'Architectural_Paradigm')
            self.Architectural_Paradigm.append(Architectural_Paradigm_)
# end class Architectural_Paradigms


class Architectural_Paradigm(GeneratedsSuper):
    """This field outlines the architectural paradigms of target software
    where the pattern is possible and relevant. In order to assist
    in normalization and classification, this field involves a
    selection from an enumerated list of defined paradigms which may
    be currently incomplete and may grow or change as new relevant
    possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Architectural_Paradigm.subclass:
            return Architectural_Paradigm.subclass(*args_, **kwargs_)
        else:
            return Architectural_Paradigm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Architectural_Paradigm', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Architectural_Paradigm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Architectural_Paradigm'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Architectural_Paradigm', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Architectural_Paradigm'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Architectural_Paradigm


class Frameworks(GeneratedsSuper):
    """This field outlines the frameworks used as part of the target
    software where the pattern is possible and relevant. In order to
    assist in normalization and classification, this field involves
    a selection from an enumerated list of defined frameworks which
    may be currently incomplete and may grow or change as new
    relevant possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self, Framework=None):
        if Framework is None:
            self.Framework = []
        else:
            self.Framework = Framework
    def factory(*args_, **kwargs_):
        if Frameworks.subclass:
            return Frameworks.subclass(*args_, **kwargs_)
        else:
            return Frameworks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Framework(self): return self.Framework
    def set_Framework(self, Framework): self.Framework = Framework
    def add_Framework(self, value): self.Framework.append(value)
    def insert_Framework(self, index, value): self.Framework[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Frameworks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frameworks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Frameworks'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Frameworks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Framework_ in self.Framework:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFramework>%s</%sFramework>%s' % (namespace_, self.gds_format_string(quote_xml(Framework_).encode(ExternalEncoding), input_name='Framework'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Framework
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Frameworks'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Framework=[\n')
        level += 1
        for Framework_ in self.Framework:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Framework_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Framework':
            Framework_ = child_.text
            Framework_ = self.gds_validate_string(Framework_, node, 'Framework')
            self.Framework.append(Framework_)
# end class Frameworks


class Framework(GeneratedsSuper):
    """This field outlines the frameworks used as part of the target
    software where the pattern is possible and relevant. In order to
    assist in normalization and classification, this field involves
    a selection from an enumerated list of defined frameworks which
    may be currently incomplete and may grow or change as new
    relevant possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Framework.subclass:
            return Framework.subclass(*args_, **kwargs_)
        else:
            return Framework(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Framework', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Framework')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Framework'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Framework', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Framework'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Framework


class Platforms(GeneratedsSuper):
    """This field outlines the platforms (OS) of the target software where
    the pattern is possible and relevant. In order to assist in
    normalization and classification, this field involves a
    selection from an enumerated list of defined platforms which may
    be currently incomplete and may grow or change as new relevant
    possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self, Platform=None):
        if Platform is None:
            self.Platform = []
        else:
            self.Platform = Platform
    def factory(*args_, **kwargs_):
        if Platforms.subclass:
            return Platforms.subclass(*args_, **kwargs_)
        else:
            return Platforms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Platform(self): return self.Platform
    def set_Platform(self, Platform): self.Platform = Platform
    def add_Platform(self, value): self.Platform.append(value)
    def insert_Platform(self, index, value): self.Platform[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Platforms', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Platforms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Platforms'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Platforms', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Platform_ in self.Platform:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlatform>%s</%sPlatform>%s' % (namespace_, self.gds_format_string(quote_xml(Platform_).encode(ExternalEncoding), input_name='Platform'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Platform
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Platforms'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Platform=[\n')
        level += 1
        for Platform_ in self.Platform:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Platform_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Platform':
            Platform_ = child_.text
            Platform_ = self.gds_validate_string(Platform_, node, 'Platform')
            self.Platform.append(Platform_)
# end class Platforms


class Platform(GeneratedsSuper):
    """This field outlines the platforms (OS) of the target software where
    the pattern is possible and relevant. In order to assist in
    normalization and classification, this field involves a
    selection from an enumerated list of defined platforms which may
    be currently incomplete and may grow or change as new relevant
    possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Platform.subclass:
            return Platform.subclass(*args_, **kwargs_)
        else:
            return Platform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Platform', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Platform')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Platform'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Platform', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Platform'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Platform


class Languages(GeneratedsSuper):
    """This field outlines the implementation languages of the target
    software where the pattern is possible and relevant. In order to
    assist in normalization and classification, this field involves
    a selection from an enumerated list of defined platforms which
    may be currently incomplete and may grow or change as new
    relevant possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self, Language=None):
        if Language is None:
            self.Language = []
        else:
            self.Language = Language
    def factory(*args_, **kwargs_):
        if Languages.subclass:
            return Languages.subclass(*args_, **kwargs_)
        else:
            return Languages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def add_Language(self, value): self.Language.append(value)
    def insert_Language(self, index, value): self.Language[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Languages', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Languages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Languages'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Languages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Language_ in self.Language:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLanguage>%s</%sLanguage>%s' % (namespace_, self.gds_format_string(quote_xml(Language_).encode(ExternalEncoding), input_name='Language'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Language
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Languages'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Language=[\n')
        level += 1
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Language':
            Language_ = child_.text
            Language_ = self.gds_validate_string(Language_, node, 'Language')
            self.Language.append(Language_)
# end class Languages


class Language(GeneratedsSuper):
    """This field outlines the implementation languages of the target
    software where the pattern is possible and relevant. In order to
    assist in normalization and classification, this field involves
    a selection from an enumerated list of defined platforms which
    may be currently incomplete and may grow or change as new
    relevant possibilities are identified."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Language.subclass:
            return Language.subclass(*args_, **kwargs_)
        else:
            return Language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='capec:', name_='Language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Language')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Language'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Language', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Language'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Language


class Keywords(GeneratedsSuper):
    """This field is intended to be a catch-all field for assisting in
    searching and subsecting a collection of patterns according to
    criteria not contained elsewehre in this schema."""
    subclass = None
    superclass = None
    def __init__(self, Keyword=None):
        if Keyword is None:
            self.Keyword = []
        else:
            self.Keyword = Keyword
    def factory(*args_, **kwargs_):
        if Keywords.subclass:
            return Keywords.subclass(*args_, **kwargs_)
        else:
            return Keywords(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Keyword(self): return self.Keyword
    def set_Keyword(self, Keyword): self.Keyword = Keyword
    def add_Keyword(self, value): self.Keyword.append(value)
    def insert_Keyword(self, index, value): self.Keyword[index] = value
    def export(self, outfile, level, namespace_='capec:', name_='Keywords', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Keywords')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Keywords'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Keywords', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Keyword_ in self.Keyword:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyword>%s</%sKeyword>%s' % (namespace_, self.gds_format_string(quote_xml(Keyword_).encode(ExternalEncoding), input_name='Keyword'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Keyword
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Keywords'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Keyword=[\n')
        level += 1
        for Keyword_ in self.Keyword:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Keyword_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Keyword':
            Keyword_ = child_.text
            Keyword_ = self.gds_validate_string(Keyword_, node, 'Keyword')
            self.Keyword.append(Keyword_)
# end class Keywords


class Common_Attack_Surface(Target_Attack_Surface_DescriptionType):
    subclass = None
    superclass = Target_Attack_Surface_DescriptionType
    def __init__(self, Targeted_OSI_Layers=None, Target_Attack_Surface_Localities=None, Target_Attack_Surface_Types=None, Target_Functional_Services=None, ID=None):
        super(Common_Attack_Surface, self).__init__(Targeted_OSI_Layers, Target_Attack_Surface_Localities, Target_Attack_Surface_Types, Target_Functional_Services, )
        self.ID = _cast(int, ID)
        pass
    def factory(*args_, **kwargs_):
        if Common_Attack_Surface.subclass:
            return Common_Attack_Surface.subclass(*args_, **kwargs_)
        else:
            return Common_Attack_Surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='capec:', name_='Common_Attack_Surface', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_Attack_Surface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_Attack_Surface'):
        super(Common_Attack_Surface, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Common_Attack_Surface')
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_Attack_Surface', fromsubclass_=False, pretty_print=True):
        super(Common_Attack_Surface, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            super(Common_Attack_Surface, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Common_Attack_Surface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        super(Common_Attack_Surface, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Common_Attack_Surface, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(Common_Attack_Surface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Common_Attack_Surface, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Common_Attack_Surface


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Attack_Pattern_Catalog",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from ap_schema_2_5 import *\n\n')
    sys.stdout.write('import stix.bindings.capec.ap_schema_2_5 as ap_binding as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Action",
    "Alternate_Term",
    "Alternate_Terms",
    "Architectural_Paradigm",
    "Architectural_Paradigms",
    "Attack_Execution_Flow",
    "Attack_Motivation_Consequences",
    "Attack_PatternType",
    "Attack_Pattern_Catalog",
    "Attack_Patterns",
    "Attack_Phase",
    "Attack_Phases",
    "Attack_Prerequisites",
    "Attack_Step",
    "Attack_Step_Technique",
    "Attack_Step_Techniques",
    "Attack_Steps",
    "Attacker_Skill_or_Knowledge_Required",
    "Attacker_Skills_or_Knowledge_Required",
    "Availability_Impact",
    "Background_Details",
    "Block",
    "CIA_Impact",
    "Categories",
    "Category",
    "Command_Structure",
    "Command_Structures",
    "Common_Attack_Step",
    "Common_Attack_Steps",
    "Common_Attack_Surface",
    "Common_Attack_Surface_Description",
    "Common_Attack_Surfaces",
    "Common_ConsequenceType",
    "Compound_Element",
    "Compound_Elements",
    "Confidentiality_Impact",
    "Consequence_Scope",
    "Consequence_Technical_Impact",
    "Content_History",
    "Contribution",
    "Contributions",
    "Custom_Attack_StepType",
    "Delta",
    "Description",
    "Ease_of_Obfuscation",
    "Environment",
    "Environments",
    "Event",
    "Example_Instance",
    "Example_Instance_Related_Vulnerabilities",
    "Examples_Instances",
    "Framework",
    "Frameworks",
    "Frequency",
    "Image",
    "Images",
    "Indicator",
    "Indicator_Warning_of_Attack",
    "Indicators",
    "Indicators_Warnings_of_Attack",
    "Integrity_Impact",
    "Keywords",
    "Language",
    "Languages",
    "Leveraged_Attack_Pattern_ID",
    "Leveraged_Attack_Patterns",
    "Location_Sensor",
    "Maintenance_Notes",
    "Method_of_Attack",
    "Methods_of_Attack",
    "Modification",
    "Modifications",
    "Noisiness",
    "Non_Recommended_Design_Patterns",
    "Obfuscation_Technique",
    "Obfuscation_Techniques",
    "Object",
    "Observable",
    "Observable_Evidence",
    "ObservablesType",
    "Other_Notes",
    "Outcome",
    "Outcomes",
    "Payload_Activation_Impact",
    "Platform",
    "Platforms",
    "Previous_Entry_Name",
    "Previous_Entry_Names",
    "Probing_Technique",
    "Probing_Techniques",
    "Protocol",
    "Protocol_Header",
    "Protocol_Structure",
    "Purpose",
    "Purposes",
    "Recommended_Design_Patterns",
    "Reference_List_Type",
    "Reference_Type",
    "References",
    "Related_Attack_Patterns",
    "Related_Guidelines",
    "Related_Protocol",
    "Related_Protocols",
    "Related_Security_Principles",
    "Related_Vulnerabilities",
    "Related_Vulnerability",
    "Related_Weakness",
    "Related_Weaknesses",
    "RelationshipType",
    "Relationship_Chains",
    "Relationship_Nature",
    "Relationship_Notes",
    "Relationship_Target_Form",
    "Relationship_Type",
    "Relationship_View_ID",
    "Relationship_Views",
    "Relationships",
    "Relevant_Attack_Surface_ElementsType",
    "Relevant_Command_Structure_ID",
    "Relevant_Command_Structures",
    "Relevant_Design_Patterns",
    "Relevant_Functional_Service_ID",
    "Relevant_Functional_Services",
    "Relevant_Protocol_Header_ID",
    "Relevant_Protocol_Headers",
    "Relevant_Protocol_ID",
    "Relevant_Protocols",
    "Relevant_Security_Patterns",
    "Relevant_Security_Requirements",
    "Research_Gaps",
    "Security_Control",
    "Security_Controls",
    "Signature",
    "Skill_or_Knowledge_Level",
    "Solutions_and_Mitigations",
    "Stateful_Measure",
    "Structured_Text_Type",
    "Submission",
    "Submissions",
    "Target_Attack_SurfaceType",
    "Target_Attack_Surface_DescriptionType",
    "Target_Attack_Surface_Localities",
    "Target_Attack_Surface_Locality",
    "Target_Attack_Surface_Type",
    "Target_Attack_Surface_Types",
    "Target_Functional_Service",
    "Target_Functional_Services",
    "Targeted_OSI_Layer",
    "Targeted_OSI_Layers",
    "Technical_Context",
    "Trend",
    "Typical_Likelihood_of_Exploit",
    "Typical_Severity",
    "Value",
    "Value_Type",
    "View",
    "Views",
    "Weakness_Relationship_Type"
    ]
