# Copyright (c) 2014, The MITRE Corporation. All rights reserved.
# See LICENSE.txt for complete terms.

#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Apr 11 15:06:23 2013 by generateDS.py version 2.9a.
#

import sys
import getopt
import re as re_

import stix.bindings.stix_common as stix_common_binding
import stix.bindings.data_marking as data_marking_binding

import base64
from datetime import datetime, tzinfo, timedelta

XML_NS = "http://stix.mitre.org/ExploitTarget-1"

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
# lxml
from lxml import etree as etree_
XMLParser_import_library = XMLParser_import_lxml
if Verbose_import_:
    print("running with lxml.etree")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser(huge_tree=True)
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class VulnerabilityType(GeneratedsSuper):
    """Characterizes an individual vulnerability.In addition to capturing
    basic information and references to vulnerability registries,
    this type is intended to be extended to enable the structured
    description of a vulnerability by using the XML Schema extension
    feature. The STIX default extension uses the Common
    Vulnerability Reporting Format (CVRF) schema to do so. The
    extension that defines this is captured in the
    CVRF1.1InstanceType in the
    http://stix.mitre.org/extensions/Vulnerability#CVRF1.1-1
    namespace. This type is defined in the
    extensions/vulnerability/cvrf_1.1_vulnerability.xsd file or at
    the URL http://stix.mitre.org/XMLSchema/extensions/vulnerability
    /cvrf_1.1/1.1/cvrf_1.1_vulnerability.xsd.The @is_known field
    captures whether or not the vulnerability is known (i.e. not a
    0-day) at the time of characterization.The
    @is_publicly_acknowledged field captures whether or not the
    vulnerability is publicly acknowledged by the vendor."""
    subclass = None
    superclass = None
    def __init__(self, is_publicly_acknowledged=None, is_known=None, Title=None, Description=None, Short_Description=None, CVE_ID=None, OSVDB_ID=None, Source=None, CVSS_Score=None, Discovered_DateTime=None, Published_DateTime=None, Affected_Software=None, References=None):
        self.is_publicly_acknowledged = _cast(bool, is_publicly_acknowledged)
        self.is_known = _cast(bool, is_known)
        self.Title = Title
        self.Description = Description
        self.Short_Description = Short_Description
        self.CVE_ID = CVE_ID
        self.OSVDB_ID = OSVDB_ID
        self.Source = Source
        self.CVSS_Score = CVSS_Score
        self.Discovered_DateTime = Discovered_DateTime
        self.Published_DateTime = Published_DateTime
        self.Affected_Software = Affected_Software
        self.References = References
    def factory(*args_, **kwargs_):
        if VulnerabilityType.subclass:
            return VulnerabilityType.subclass(*args_, **kwargs_)
        else:
            return VulnerabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Short_Description(self): return self.Short_Description
    def set_Short_Description(self, Short_Description): self.Short_Description = Short_Description
    def get_CVE_ID(self): return self.CVE_ID
    def set_CVE_ID(self, CVE_ID): self.CVE_ID = CVE_ID
    def get_OSVDB_ID(self): return self.OSVDB_ID
    def set_OSVDB_ID(self, OSVDB_ID): self.OSVDB_ID = OSVDB_ID
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_CVSS_Score(self): return self.CVSS_Score
    def set_CVSS_Score(self, CVSS_Score): self.CVSS_Score = CVSS_Score
    def get_Discovered_DateTime(self): return self.Discovered_DateTime
    def set_Discovered_DateTime(self, Discovered_DateTime): self.Discovered_DateTime = Discovered_DateTime
    def get_Published_DateTime(self): return self.Published_DateTime
    def set_Published_DateTime(self, Published_DateTime): self.Published_DateTime = Published_DateTime
    def get_Affected_Software(self): return self.Affected_Software
    def set_Affected_Software(self, Affected_Software): self.Affected_Software = Affected_Software
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_is_publicly_acknowledged(self): return self.is_publicly_acknowledged
    def set_is_publicly_acknowledged(self, is_publicly_acknowledged): self.is_publicly_acknowledged = is_publicly_acknowledged
    def get_is_known(self): return self.is_known
    def set_is_known(self, is_known): self.is_known = is_known
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Description is not None or
            self.Short_Description is not None or
            self.CVE_ID is not None or
            self.OSVDB_ID is not None or
            self.Source is not None or
            self.CVSS_Score is not None or
            self.Discovered_DateTime is not None or
            self.Published_DateTime is not None or
            self.Affected_Software is not None or
            self.References is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='VulnerabilityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VulnerabilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='VulnerabilityType'):
        if self.is_publicly_acknowledged is not None and 'is_publicly_acknowledged' not in already_processed:
            already_processed.add('is_publicly_acknowledged')
            outfile.write(' is_publicly_acknowledged="%s"' % self.gds_format_boolean(self.is_publicly_acknowledged, input_name='is_publicly_acknowledged'))
        if self.is_known is not None and 'is_known' not in already_processed:
            already_processed.add('is_known')
            outfile.write(' is_known="%s"' % self.gds_format_boolean(self.is_known, input_name='is_known'))
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='VulnerabilityType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:Title>%s</%s:Title>%s' % (nsmap[namespace_],self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), nsmap[namespace_], eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, nsmap, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Short_Description is not None:
            self.Short_Description.export(outfile, level, nsmap, namespace_, name_='Short_Description', pretty_print=pretty_print)
        if self.CVE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:CVE_ID>%s</%s:CVE_ID>%s' % (nsmap[namespace_],self.gds_format_string(quote_xml(self.CVE_ID).encode(ExternalEncoding), input_name='CVE_ID'), nsmap[namespace_], eol_))
        if self.OSVDB_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:OSVDB_ID>%s</%s:OSVDB_ID>%s' % (nsmap[namespace_],self.gds_format_integer(self.OSVDB_ID, input_name='OSVDB_ID'), nsmap[namespace_], eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:Source>%s</%s:Source>%s' % (nsmap[namespace_],self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), nsmap[namespace_], eol_))
        if self.CVSS_Score is not None:
            self.CVSS_Score.export(outfile, level, nsmap, namespace_, name_='CVSS_Score', pretty_print=pretty_print)
        if self.Discovered_DateTime is not None:
            self.Discovered_DateTime.export(outfile, level, nsmap, namespace_, name_='Discovered_DateTime', pretty_print=pretty_print)
        if self.Published_DateTime is not None:
            self.Published_DateTime.export(outfile, level, nsmap, namespace_, name_='Published_DateTime', pretty_print=pretty_print)
        if self.Affected_Software is not None:
            self.Affected_Software.export(outfile, level, nsmap, namespace_, name_='Affected_Software', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, nsmap, namespace_, name_='References', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('is_publicly_acknowledged', node)
        if value is not None and 'is_publicly_acknowledged' not in already_processed:
            already_processed.add('is_publicly_acknowledged')
            if value in ('true', '1'):
                self.is_publicly_acknowledged = True
            elif value in ('false', '0'):
                self.is_publicly_acknowledged = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('is_known', node)
        if value is not None and 'is_known' not in already_processed:
            already_processed.add('is_known')
            if value in ('true', '1'):
                self.is_known = True
            elif value in ('false', '0'):
                self.is_known = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Short_Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Short_Description(obj_)
        elif nodeName_ == 'CVE_ID':
            CVE_ID_ = child_.text
            CVE_ID_ = self.gds_validate_string(CVE_ID_, node, 'CVE_ID')
            self.CVE_ID = CVE_ID_
        elif nodeName_ == 'OSVDB_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'OSVDB_ID')
            self.OSVDB_ID = ival_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
        elif nodeName_ == 'CVSS_Score':
            obj_ = CVSSVectorType.factory()
            obj_.build(child_)
            self.set_CVSS_Score(obj_)
        elif nodeName_ == 'Discovered_DateTime':
            obj_ = stix_common_binding.DateTimeWithPrecisionType.factory()
            obj_.build(child_)
            self.set_Discovered_DateTime(obj_)
        elif nodeName_ == 'Published_DateTime':
            obj_ = stix_common_binding.DateTimeWithPrecisionType.factory()
            obj_.build(child_)
            self.set_Published_DateTime(obj_)
        elif nodeName_ == 'Affected_Software':
            obj_ = AffectedSoftwareType.factory()
            obj_.build(child_)
            self.set_Affected_Software(obj_)
        elif nodeName_ == 'References':
            obj_ = stix_common_binding.ReferencesType.factory()
            obj_.build(child_)
            self.set_References(obj_)
# end class VulnerabilityType

class ConfigurationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Description=None, Short_Description=None, CCE_ID=None):
        self.Short_Description = Short_Description
        self.Description = Description
        self.CCE_ID = CCE_ID
    def factory(*args_, **kwargs_):
        if ConfigurationType.subclass:
            return ConfigurationType.subclass(*args_, **kwargs_)
        else:
            return ConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Short_Description(self): return self.Short_Description
    def set_Short_Description(self, Short_Description): self.Short_Description = Short_Description
    def get_CCE_ID(self): return self.CCE_ID
    def set_CCE_ID(self, CCE_ID): self.CCE_ID = CCE_ID
    def hasContent_(self):
        if (
            self.Description is not None or
            self.CCE_ID is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='ConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='ConfigurationType'):
        pass
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='ConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, nsmap, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Short_Description is not None:
            self.Short_Description.export(outfile, level, nsmap, namespace_, name_='Short_Description', pretty_print=pretty_print)
        if self.CCE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:CCE_ID>%s</%s:CCE_ID>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.CCE_ID).encode(ExternalEncoding), input_name='CCE_ID'), nsmap[namespace_], eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        if nodeName_ == 'Short_Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Short_Description(obj_)
        elif nodeName_ == 'CCE_ID':
            CCE_ID_ = child_.text
            CCE_ID_ = self.gds_validate_string(CCE_ID_, node, 'CCE_ID')
            self.CCE_ID = CCE_ID_
# end class ConfigurationType

class AffectedSoftwareType(stix_common_binding.GenericRelationshipListType):
    subclass = None
    superclass = stix_common_binding.GenericRelationshipListType
    def __init__(self, scope='exclusive', Affected_Software=None):
        super(AffectedSoftwareType, self).__init__(scope=scope)
        if Affected_Software is None:
            self.Affected_Software = []
        else:
            self.Affected_Software = Affected_Software
    def factory(*args_, **kwargs_):
        if AffectedSoftwareType.subclass:
            return AffectedSoftwareType.subclass(*args_, **kwargs_)
        else:
            return AffectedSoftwareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Affected_Software(self): return self.Affected_Software
    def set_Affected_Software(self, Affected_Software): self.Affected_Software = Affected_Software
    def add_Affected_Software(self, value): self.Affected_Software.append(value)
    def insert_Affected_Software(self, index, value): self.Affected_Software[index] = value
    def hasContent_(self):
        if (
            self.Affected_Software or
            super(AffectedSoftwareType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='AffectedSoftwareType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AffectedSoftwareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='AffectedSoftwareType'):
        super(AffectedSoftwareType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AffectedSoftwareType')
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='AffectedSoftwareType', fromsubclass_=False, pretty_print=True):
        super(AffectedSoftwareType, self).exportChildren(outfile, level, nsmap, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Affected_Software_ in self.Affected_Software:
            Affected_Software_.export(outfile, level, nsmap, namespace_, name_='Affected_Software', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AffectedSoftwareType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Affected_Software':
            obj_ = stix_common_binding.RelatedObservableType.factory()
            obj_.build(child_)
            self.Affected_Software.append(obj_)
        super(AffectedSoftwareType, self).buildChildren(child_, node, nodeName_, True)
# end class AffectedSoftwareType

class RelatedExploitTargetsType(stix_common_binding.GenericRelationshipListType):
    subclass = None
    superclass = stix_common_binding.GenericRelationshipListType
    def __init__(self, scope='exclusive', Related_Exploit_Target=None):
        super(RelatedExploitTargetsType, self).__init__(scope=scope)
        if Related_Exploit_Target is None:
            self.Related_Exploit_Target = []
        else:
            self.Related_Exploit_Target = Related_Exploit_Target
    def factory(*args_, **kwargs_):
        if RelatedExploitTargetsType.subclass:
            return RelatedExploitTargetsType.subclass(*args_, **kwargs_)
        else:
            return RelatedExploitTargetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Related_Exploit_Target(self): return self.Related_Exploit_Target
    def set_Related_Exploit_Target(self, Related_Exploit_Target): self.Related_Exploit_Target = Related_Exploit_Target
    def add_Related_Exploit_Target(self, value): self.Related_Exploit_Target.append(value)
    def insert_Related_Exploit_Target(self, index, value): self.Related_Exploit_Target[index] = value
    def hasContent_(self):
        if (
            self.Related_Exploit_Target or
            super(RelatedExploitTargetsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='RelatedExploitTargetsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedExploitTargetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='RelatedExploitTargetsType'):
        super(RelatedExploitTargetsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedExploitTargetsType')
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='RelatedExploitTargetsType', fromsubclass_=False, pretty_print=True):
        super(RelatedExploitTargetsType, self).exportChildren(outfile, level, nsmap, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Related_Exploit_Target_ in self.Related_Exploit_Target:
            Related_Exploit_Target_.export(outfile, level, nsmap, namespace_, name_='Related_Exploit_Target', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(RelatedExploitTargetsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Related_Exploit_Target':
            obj_ = stix_common_binding.RelatedExploitTargetType.factory()
            obj_.build(child_)
            self.Related_Exploit_Target.append(obj_)
        super(RelatedExploitTargetsType, self).buildChildren(child_, node, nodeName_, True)
# end class RelatedExploitTargetsType


class WeaknessType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Description=None, CWE_ID=None):
        self.Description = Description
        self.CWE_ID = CWE_ID
    def factory(*args_, **kwargs_):
        if WeaknessType.subclass:
            return WeaknessType.subclass(*args_, **kwargs_)
        else:
            return WeaknessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_CWE_ID(self): return self.CWE_ID
    def set_CWE_ID(self, CWE_ID): self.CWE_ID = CWE_ID
    def hasContent_(self):
        if (
            self.Description is not None or
            self.CWE_ID is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='WeaknessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WeaknessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='WeaknessType'):
        pass
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='WeaknessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, nsmap, namespace_, name_='Description', pretty_print=pretty_print)
        if self.CWE_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:CWE_ID>%s</%s:CWE_ID>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.CWE_ID).encode(ExternalEncoding), input_name='CWE_ID'), nsmap[namespace_], eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'CWE_ID':
            CWE_ID_ = child_.text
            CWE_ID_ = self.gds_validate_string(CWE_ID_, node, 'CWE_ID')
            self.CWE_ID = CWE_ID_
# end class WeaknessType

class CVSSVectorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Overall_Score=None, Base_Score=None, Base_Vector=None, Temporal_Score=None, Temporal_Vector=None, Environmental_Score=None, Environmental_Vector=None):
        self.Overall_Score = Overall_Score
        self.Base_Score = Base_Score
        self.Base_Vector = Base_Vector
        self.Temporal_Score = Temporal_Score
        self.Temporal_Vector = Temporal_Vector
        self.Environmental_Score = Environmental_Score
        self.Environmental_Vector = Environmental_Vector
    def factory(*args_, **kwargs_):
        if CVSSVectorType.subclass:
            return CVSSVectorType.subclass(*args_, **kwargs_)
        else:
            return CVSSVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Overall_Score(self): return self.Overall_Score
    def set_Overall_Score(self, Overall_Score): self.Overall_Score = Overall_Score
    def validate_CVSSScoreType(self, value):
        # Validate type CVSSScoreType, a restriction on xs:string.
        pass
    def get_Base_Score(self): return self.Base_Score
    def set_Base_Score(self, Base_Score): self.Base_Score = Base_Score
    def get_Base_Vector(self): return self.Base_Vector
    def set_Base_Vector(self, Base_Vector): self.Base_Vector = Base_Vector
    def validate_CVSSBaseVectorType(self, value):
        # Validate type CVSSBaseVectorType, a restriction on xs:string.
        pass
    def get_Temporal_Score(self): return self.Temporal_Score
    def set_Temporal_Score(self, Temporal_Score): self.Temporal_Score = Temporal_Score
    def get_Temporal_Vector(self): return self.Temporal_Vector
    def set_Temporal_Vector(self, Temporal_Vector): self.Temporal_Vector = Temporal_Vector
    def validate_CVSSTemporalVectorType(self, value):
        # Validate type CVSSTemporalVectorType, a restriction on xs:string.
        pass
    def get_Environmental_Score(self): return self.Environmental_Score
    def set_Environmental_Score(self, Environmental_Score): self.Environmental_Score = Environmental_Score
    def get_Environmental_Vector(self): return self.Environmental_Vector
    def set_Environmental_Vector(self, Environmental_Vector): self.Environmental_Vector = Environmental_Vector
    def validate_CVSSEnvironmentalVectorType(self, value):
        # Validate type CVSSEnvironmentalVectorType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Overall_Score is not None or
            self.Base_Score is not None or
            self.Base_Vector is not None or
            self.Temporal_Score is not None or
            self.Temporal_Vector is not None or
            self.Environmental_Score is not None or
            self.Environmental_Vector is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='CVSSVectorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVSSVectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='CVSSVectorType'):
        pass
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='CVSSVectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Overall_Score is not None:
            outfile.write('<%s:Overall_Score>%s</%s:Overall_Score>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Overall_Score).encode(ExternalEncoding), input_name='Overall_Score'), nsmap[namespace_], eol_))
        if self.Base_Score is not None:
            outfile.write('<%s:Base_Score>%s</%s:Base_Score>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Base_Score).encode(ExternalEncoding), input_name='Base_Score'), nsmap[namespace_], eol_))
        if self.Base_Vector is not None:
            outfile.write('<%s:Base_Vector>%s</%s:Base_Vector>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Base_Vector).encode(ExternalEncoding), input_name='Base_Vector'), nsmap[namespace_], eol_))
        if self.Temporal_Score is not None:
            outfile.write('<%s:Temporal_Score>%s</%s:Temporal_Score>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Temporal_Score).encode(ExternalEncoding), input_name='Temporal_Score'), nsmap[namespace_], eol_))
        if self.Temporal_Vector is not None:
            outfile.write('<%s:Temporal_Vector>%s</%s:Temporal_Vector>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Temporal_Vector).encode(ExternalEncoding), input_name='Temporal_Vector'), nsmap[namespace_], eol_))
        if self.Environmental_Score is not None:
            outfile.write('<%s:Environmental_Score>%s</%s:Environmental_Score>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Environmental_Score).encode(ExternalEncoding), input_name='Environmental_Score'), nsmap[namespace_], eol_))
        if self.Environmental_Vector is not None:
            outfile.write('<%s:Environmental_Vector>%s</%s:Environmental_Vector>%s' % (nsmap[namespace_], self.gds_format_string(quote_xml(self.Environmental_Vector).encode(ExternalEncoding), input_name='Environmental_Vector'), nsmap[namespace_], eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Overall_Score':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Overall_Score')
            self.set_Overall_Score(text_)
        elif nodeName_ == 'Base_Score':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Base_Score')
            self.set_Base_Score(text_)
        elif nodeName_ == 'Base_Vector':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Base_Vector')
            self.set_Base_Vector(text_)
        elif nodeName_ == 'Temporal_Score':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Temporal_Score')
            self.set_Temporal_Score(text_)
        elif nodeName_ == 'Temporal_Vector':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Temporal_Vector')
            self.set_Temporal_Vector(text_)
        elif nodeName_ == 'Environmental_Score':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Environmental_Score')
            self.set_Environmental_Score(text_)
        elif nodeName_ == 'Environmental_Vector':
            text_ = child_.text
            text_ = self.gds_validate_string(text_, node, 'Environmental_Vector')
            self.set_Environmental_Vector(text_)
# end class CVSSVectorType

class PotentialCOAsType(stix_common_binding.GenericRelationshipListType):
    subclass = None
    superclass = stix_common_binding.GenericRelationshipListType
    def __init__(self, scope='exclusive', Potential_COA=None):
        super(PotentialCOAsType, self).__init__(scope=scope)
        if Potential_COA is None:
            self.Potential_COA = []
        else:
            self.Potential_COA = Potential_COA
    def factory(*args_, **kwargs_):
        if PotentialCOAsType.subclass:
            return PotentialCOAsType.subclass(*args_, **kwargs_)
        else:
            return PotentialCOAsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Potential_COA(self): return self.Potential_COA
    def set_Potential_COA(self, Potential_COA): self.Potential_COA = Potential_COA
    def add_Potential_COA(self, value): self.Potential_COA.append(value)
    def insert_Potential_COA(self, index, value): self.Potential_COA[index] = value
    def hasContent_(self):
        if (
            self.Potential_COA or
            super(PotentialCOAsType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='PotentialCOAsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PotentialCOAsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='PotentialCOAsType'):
        super(PotentialCOAsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PotentialCOAsType')
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='PotentialCOAsType', fromsubclass_=False, pretty_print=True):
        super(PotentialCOAsType, self).exportChildren(outfile, level, nsmap, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Potential_COA_ in self.Potential_COA:
            Potential_COA_.export(outfile, level, nsmap, namespace_, name_='Potential_COA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PotentialCOAsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Potential_COA':
            obj_ = stix_common_binding.RelatedCourseOfActionType.factory()
            obj_.build(child_)
            self.Potential_COA.append(obj_)
        super(PotentialCOAsType, self).buildChildren(child_, node, nodeName_, True)
# end class PotentialCOAsType

class ExploitTargetType(stix_common_binding.ExploitTargetBaseType):
    """Specifies the relevant STIX-ExploitTarget schema version for this
    content."""
    subclass = None
    superclass = stix_common_binding.ExploitTargetBaseType
    def __init__(self, timestamp=None, idref=None, id=None, version=None, Title=None, Description=None, Short_Description=None, Vulnerability=None, Weakness=None, Configuration=None, Potential_COAs=None, Information_Source=None, Handling=None, Related_Exploit_Targets=None, Related_Packages=None):
        super(ExploitTargetType, self).__init__(timestamp=timestamp, idref=idref, id=id)
        self.xmlns          = "http://stix.mitre.org/ExploitTarget-1"
        self.xmlns_prefix   = "et"
        self.xml_type       = "ExploitTargetType"
        self.version = _cast(None, version)
        self.Title = Title
        self.Description = Description
        self.Short_Description = Short_Description
        if Vulnerability is None:
            self.Vulnerability = []
        else:
            self.Vulnerability = Vulnerability
        if Weakness is None:
            self.Weakness = []
        else:
            self.Weakness = Weakness
        if Configuration is None:
            self.Configuration = []
        else:
            self.Configuration = Configuration
        self.Potential_COAs = Potential_COAs
        self.Information_Source = Information_Source
        self.Handling = Handling
        self.Related_Exploit_Targets = Related_Exploit_Targets
        self.Related_Packages = Related_Packages
    def factory(*args_, **kwargs_):
        if ExploitTargetType.subclass:
            return ExploitTargetType.subclass(*args_, **kwargs_)
        else:
            return ExploitTargetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Short_Description(self): return self.Short_Description
    def set_Short_Description(self, Short_Description): self.Short_Description = Short_Description
    def get_Vulnerability(self): return self.Vulnerability
    def set_Vulnerability(self, Vulnerability): self.Vulnerability = Vulnerability
    def add_Vulnerability(self, value): self.Vulnerability.append(value)
    def insert_Vulnerability(self, index, value): self.Vulnerability[index] = value
    def get_Weakness(self): return self.Weakness
    def set_Weakness(self, Weakness): self.Weakness = Weakness
    def add_Weakness(self, value): self.Weakness.append(value)
    def insert_Weakness(self, index, value): self.Weakness[index] = value
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def add_Configuration(self, value): self.Configuration.append(value)
    def insert_Configuration(self, index, value): self.Configuration[index] = value
    def get_Potential_COAs(self): return self.Potential_COAs
    def set_Potential_COAs(self, Potential_COAs): self.Potential_COAs = Potential_COAs
    def get_Information_Source(self): return self.Information_Source
    def set_Information_Source(self, Information_Source): self.Information_Source = Information_Source
    def get_Handling(self): return self.Handling
    def set_Handling(self, Handling): self.Handling = Handling
    def get_Related_Exploit_Targets(self): return self.Related_Exploit_Targets
    def set_Related_Exploit_Targets(self, Related_Exploit_Targets): self.Related_Exploit_Targets = Related_Exploit_Targets
    def get_Related_Packages(self): return self.Related_Packages
    def set_Related_Packages(self, Related_Packages): self.Related_Packages = Related_Packages
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Description is not None or
            self.Short_Description is not None or
            self.Vulnerability or
            self.Weakness or
            self.Configuration or
            self.Potential_COAs is not None or
            self.Information_Source is not None or
            self.Handling is not None or
            self.Related_Exploit_Targets is not None or
            self.Related_Packages is not None or
            super(ExploitTargetType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, nsmap, namespace_=XML_NS, name_='ExploitTargetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s:%s%s' % (nsmap[namespace_], name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExploitTargetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, nsmap, XML_NS, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s:%s>%s' % (nsmap[namespace_], name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='et:', name_='ExploitTargetType'):
        super(ExploitTargetType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExploitTargetType')
        if 'xmlns' not in already_processed:
            already_processed.add('xmlns')
            xmlns = " xmlns:%s='%s'" % (self.xmlns_prefix, self.xmlns)
            outfile.write(xmlns)   
        if 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            xsi_type = " xsi:type='%s:%s'" % (self.xmlns_prefix, self.xml_type)
            outfile.write(xsi_type)
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
    def exportChildren(self, outfile, level, nsmap, namespace_=XML_NS, name_='ExploitTargetType', fromsubclass_=False, pretty_print=True):
        super(ExploitTargetType, self).exportChildren(outfile, level, nsmap, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%s:Title>%s</%s:Title>%s' % (nsmap[namespace_],self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), nsmap[namespace_], eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, nsmap, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Short_Description is not None:
            self.Short_Description.export(outfile, level, nsmap, namespace_, name_='Short_Description', pretty_print=pretty_print)
        for Vulnerability_ in self.Vulnerability:
            Vulnerability_.export(outfile, level, nsmap, namespace_, name_='Vulnerability', pretty_print=pretty_print)
        for Weakness_ in self.Weakness:
            Weakness_.export(outfile, level, nsmap, namespace_, name_='Weakness', pretty_print=pretty_print)
        for Configuration_ in self.Configuration:
            Configuration_.export(outfile, level, nsmap, namespace_, name_='Configuration', pretty_print=pretty_print)
        if self.Potential_COAs is not None:
            self.Potential_COAs.export(outfile, level, nsmap, namespace_, name_='Potential_COAs', pretty_print=pretty_print)
        if self.Information_Source is not None:
            self.Information_Source.export(outfile, level, nsmap, namespace_, name_='Information_Source', pretty_print=pretty_print)
        if self.Handling is not None:
            self.Handling.export(outfile, level, nsmap, namespace_, name_='Handling', pretty_print=pretty_print)
        if self.Related_Exploit_Targets is not None:
            self.Related_Exploit_Targets.export(outfile, level, nsmap, namespace_, name_='Related_Exploit_Targets', pretty_print=pretty_print)
        if self.Related_Packages is not None:
            self.Related_Packages.export(outfile, level, nsmap, namespace_, name_='Related_Packages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        super(ExploitTargetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Short_Description':
            obj_ = stix_common_binding.StructuredTextType.factory()
            obj_.build(child_)
            self.set_Short_Description(obj_)
        elif nodeName_ == 'Vulnerability':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                    
                if type_name_ == "CVRF1.1InstanceType":
                    import stix.bindings.extensions.vulnerability.cvrf_1_1 as cvrf_1_1_binding
                    obj_ = cvrf_1_1_binding.CVRF1_1InstanceType.factory()
                else:
                    raise NotImplementedError('No implementation class for Vulnerability: ' + type_name_)
            else:
                obj_ = VulnerabilityType.factory() # VulnerabilityType not abstract
            obj_.build(child_)
            self.Vulnerability.append(obj_)
        elif nodeName_ == 'Weakness':
            obj_ = WeaknessType.factory()
            obj_.build(child_)
            self.Weakness.append(obj_)
        elif nodeName_ == 'Configuration':
            obj_ = ConfigurationType.factory()
            obj_.build(child_)
            self.Configuration.append(obj_)
        elif nodeName_ == 'Potential_COAs':
            obj_ = PotentialCOAsType.factory()
            obj_.build(child_)
            self.set_Potential_COAs(obj_)
        elif nodeName_ == 'Information_Source':
            obj_ = stix_common_binding.InformationSourceType.factory()
            obj_.build(child_)
            self.set_Information_Source(obj_)
        elif nodeName_ == 'Handling':
            obj_ = data_marking_binding.MarkingType.factory()
            obj_.build(child_)
            self.set_Handling(obj_)
        elif nodeName_ == 'Related_Exploit_Targets':
            obj_ = RelatedExploitTargetsType.factory()
            obj_.build(child_)
            self.set_Related_Exploit_Targets(obj_)
        elif nodeName_ == 'Related_Packages':
            obj_ = stix_common_binding.RelatedPackageRefsType.factory()
            obj_.build(child_)
            self.set_Related_Packages(obj_)
        super(ExploitTargetType, self).buildChildren(child_, node, nodeName_, True)
# end class ExploitTargetType

GDSClassesMapping = {
    'Information_Source': stix_common_binding.InformationSourceType,
    'Indicator': stix_common_binding.IndicatorBaseType,
    'Exploit_Target': stix_common_binding.ExploitTargetBaseType,
    'Incident': stix_common_binding.IncidentBaseType,
    'Information_Source_Type': stix_common_binding.ControlledVocabularyStringType,
    'Confidence_Assertion_Chain': stix_common_binding.ConfidenceAssertionChainType,
    'Confidence_Assertion': stix_common_binding.ConfidenceType,
    'Campaign': stix_common_binding.CampaignBaseType,
    'Encoding': stix_common_binding.ControlledVocabularyStringType,
    'Source': stix_common_binding.ControlledVocabularyStringType,
    'State': stix_common_binding.ControlledVocabularyStringType,
    'Marking_Structure': data_marking_binding.MarkingStructureType,
    'Type': stix_common_binding.ControlledVocabularyStringType,
    'Tool_Type': stix_common_binding.ControlledVocabularyStringType,
    'Relationship': stix_common_binding.ControlledVocabularyStringType,
    'TTP': stix_common_binding.TTPBaseType,
    'Course_Of_Action': stix_common_binding.CourseOfActionBaseType,
    'Potential_COA': stix_common_binding.RelatedCourseOfActionType,
    'Reference_Description': stix_common_binding.StructuredTextType,
    'Association_Type': stix_common_binding.ControlledVocabularyStringType,
    'Marking': data_marking_binding.MarkingSpecificationType,
    'Related_Identities': stix_common_binding.RelatedIdentitiesType,
    'Identity': stix_common_binding.IdentityType,
    'Usage_Context_Assumption': stix_common_binding.StructuredTextType,
    'Threat_Actor': stix_common_binding.ThreatActorBaseType,
    'Confidence': stix_common_binding.ConfidenceType,
    'Kill_Chain': stix_common_binding.KillChainType,
    'Description': stix_common_binding.StructuredTextType,
    'Handling': data_marking_binding.MarkingType,
    'Name': stix_common_binding.ControlledVocabularyStringType,
    'Kill_Chain_Phase': stix_common_binding.KillChainPhaseReferenceType,
    'Related_Identity': stix_common_binding.RelatedIdentityType,
    'Argument_Name': stix_common_binding.ControlledVocabularyStringType,
    'Dependency_Description': stix_common_binding.StructuredTextType,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)

def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass

def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Exploit_Target'
        rootClass = ExploitTargetType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    # sys.stdout.write('<?xml version="1.0" ?>\n')
    # rootObj.export(sys.stdout, 0, name_=rootTag,
    #     namespacedef_='',
    #     pretty_print=True)
    return rootObj

def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Exploit_Target'
        rootClass = ExploitTargetType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    rootElement = rootObj.to_etree(None, name_=rootTag)
    content = etree_.tostring(rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement

def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Exploit_Target'
        rootClass = ExploitTargetType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    # sys.stdout.write('<?xml version="1.0" ?>\n')
    # rootObj.export(sys.stdout, 0, name_="Exploit_Target",
    #     namespacedef_='')
    return rootObj

def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

__all__ = [
    "VulnerabilityType",
    "ConfigurationType",
    "WeaknessType",
    "CVSSVectorType",
    "PotentialCOAsType",
    "ExploitTargetType"
    ]
