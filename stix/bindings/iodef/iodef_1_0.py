#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Nov 13 16:07:51 2012 by generateDS.py version 2.7c.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class IODEF_Document(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, formatid=None, version=None, Incident=None):
        self.lang = _cast(None, lang)
        self.formatid = _cast(None, formatid)
        self.version = _cast(None, version)
        if Incident is None:
            self.Incident = []
        else:
            self.Incident = Incident
    def factory(*args_, **kwargs_):
        if IODEF_Document.subclass:
            return IODEF_Document.subclass(*args_, **kwargs_)
        else:
            return IODEF_Document(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Incident(self): return self.Incident
    def set_Incident(self, Incident): self.Incident = Incident
    def add_Incident(self, value): self.Incident.append(value)
    def insert_Incident(self, index, value): self.Incident[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_formatid(self): return self.formatid
    def set_formatid(self, formatid): self.formatid = formatid
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='iodef:', name_='IODEF-Document', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IODEF-Document')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='IODEF-Document'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.formatid is not None and 'formatid' not in already_processed:
            already_processed.append('formatid')
            outfile.write(' formatid=%s' % (self.gds_format_string(quote_attrib(self.formatid).encode(ExternalEncoding), input_name='formatid'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='IODEF-Document', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Incident_ in self.Incident:
            Incident_.export(outfile, level, namespace_, name_='Incident', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Incident
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IODEF-Document'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.formatid is not None and 'formatid' not in already_processed:
            already_processed.append('formatid')
            showIndent(outfile, level)
            outfile.write('formatid = "%s",\n' % (self.formatid,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Incident=[\n')
        level += 1
        for Incident_ in self.Incident:
            showIndent(outfile, level)
            outfile.write('model_.Incident(\n')
            Incident_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('formatid', node)
        if value is not None and 'formatid' not in already_processed:
            already_processed.append('formatid')
            self.formatid = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Incident':
            obj_ = Incident.factory()
            obj_.build(child_)
            self.Incident.append(obj_)
# end class IODEF_Document


class Incident(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, restriction='private', ext_purpose=None, purpose=None, IncidentID=None, AlternativeID=None, RelatedActivity=None, DetectTime=None, StartTime=None, EndTime=None, ReportTime=None, Description=None, Assessment=None, Method=None, Contact=None, EventData=None, History=None, AdditionalData=None):
        self.lang = _cast(None, lang)
        self.restriction = _cast(None, restriction)
        self.ext_purpose = _cast(None, ext_purpose)
        self.purpose = _cast(None, purpose)
        self.IncidentID = IncidentID
        self.AlternativeID = AlternativeID
        self.RelatedActivity = RelatedActivity
        self.DetectTime = DetectTime
        self.StartTime = StartTime
        self.EndTime = EndTime
        self.ReportTime = ReportTime
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Assessment is None:
            self.Assessment = []
        else:
            self.Assessment = Assessment
        if Method is None:
            self.Method = []
        else:
            self.Method = Method
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        if EventData is None:
            self.EventData = []
        else:
            self.EventData = EventData
        self.History = History
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if Incident.subclass:
            return Incident.subclass(*args_, **kwargs_)
        else:
            return Incident(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IncidentID(self): return self.IncidentID
    def set_IncidentID(self, IncidentID): self.IncidentID = IncidentID
    def get_AlternativeID(self): return self.AlternativeID
    def set_AlternativeID(self, AlternativeID): self.AlternativeID = AlternativeID
    def get_RelatedActivity(self): return self.RelatedActivity
    def set_RelatedActivity(self, RelatedActivity): self.RelatedActivity = RelatedActivity
    def get_DetectTime(self): return self.DetectTime
    def set_DetectTime(self, DetectTime): self.DetectTime = DetectTime
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_ReportTime(self): return self.ReportTime
    def set_ReportTime(self, ReportTime): self.ReportTime = ReportTime
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_Assessment(self): return self.Assessment
    def set_Assessment(self, Assessment): self.Assessment = Assessment
    def add_Assessment(self, value): self.Assessment.append(value)
    def insert_Assessment(self, index, value): self.Assessment[index] = value
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def add_Method(self, value): self.Method.append(value)
    def insert_Method(self, index, value): self.Method[index] = value
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def add_Contact(self, value): self.Contact.append(value)
    def insert_Contact(self, index, value): self.Contact[index] = value
    def get_EventData(self): return self.EventData
    def set_EventData(self, EventData): self.EventData = EventData
    def add_EventData(self, value): self.EventData.append(value)
    def insert_EventData(self, index, value): self.EventData[index] = value
    def get_History(self): return self.History
    def set_History(self, History): self.History = History
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_ext_purpose(self): return self.ext_purpose
    def set_ext_purpose(self, ext_purpose): self.ext_purpose = ext_purpose
    def get_purpose(self): return self.purpose
    def set_purpose(self, purpose): self.purpose = purpose
    def export(self, outfile, level, namespace_='iodef:', name_='Incident', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Incident')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Incident'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
        if self.ext_purpose is not None and 'ext_purpose' not in already_processed:
            already_processed.append('ext_purpose')
            outfile.write(' ext-purpose=%s' % (self.gds_format_string(quote_attrib(self.ext_purpose).encode(ExternalEncoding), input_name='ext-purpose'), ))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.append('purpose')
            outfile.write(' purpose=%s' % (self.gds_format_string(quote_attrib(self.purpose).encode(ExternalEncoding), input_name='purpose'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Incident', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IncidentID is not None:
            self.IncidentID.export(outfile, level, namespace_, name_='IncidentID', pretty_print=pretty_print)
        if self.AlternativeID is not None:
            self.AlternativeID.export(outfile, level, namespace_, name_='AlternativeID', pretty_print=pretty_print)
        if self.RelatedActivity is not None:
            self.RelatedActivity.export(outfile, level, namespace_, name_='RelatedActivity', pretty_print=pretty_print)
        if self.DetectTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetectTime>%s</%sDetectTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.DetectTime).encode(ExternalEncoding), input_name='DetectTime'), namespace_, eol_))
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), namespace_, eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.EndTime).encode(ExternalEncoding), input_name='EndTime'), namespace_, eol_))
        if self.ReportTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReportTime>%s</%sReportTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReportTime).encode(ExternalEncoding), input_name='ReportTime'), namespace_, eol_))
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Assessment_ in self.Assessment:
            Assessment_.export(outfile, level, namespace_, name_='Assessment', pretty_print=pretty_print)
        for Method_ in self.Method:
            Method_.export(outfile, level, namespace_, name_='Method', pretty_print=pretty_print)
        for Contact_ in self.Contact:
            Contact_.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        for EventData_ in self.EventData:
            EventData_.export(outfile, level, namespace_, name_='EventData', pretty_print=pretty_print)
        if self.History is not None:
            self.History.export(outfile, level, namespace_, name_='History', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IncidentID is not None or
            self.AlternativeID is not None or
            self.RelatedActivity is not None or
            self.DetectTime is not None or
            self.StartTime is not None or
            self.EndTime is not None or
            self.ReportTime is not None or
            self.Description or
            self.Assessment or
            self.Method or
            self.Contact or
            self.EventData or
            self.History is not None or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Incident'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
        if self.ext_purpose is not None and 'ext_purpose' not in already_processed:
            already_processed.append('ext_purpose')
            showIndent(outfile, level)
            outfile.write('ext_purpose = "%s",\n' % (self.ext_purpose,))
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.append('purpose')
            showIndent(outfile, level)
            outfile.write('purpose = "%s",\n' % (self.purpose,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IncidentID is not None:
            showIndent(outfile, level)
            outfile.write('IncidentID=model_.IncidentID(\n')
            self.IncidentID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AlternativeID is not None:
            showIndent(outfile, level)
            outfile.write('AlternativeID=model_.AlternativeID(\n')
            self.AlternativeID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RelatedActivity is not None:
            showIndent(outfile, level)
            outfile.write('RelatedActivity=model_.RelatedActivity(\n')
            self.RelatedActivity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DetectTime is not None:
            showIndent(outfile, level)
            outfile.write('DetectTime=%s,\n' % quote_python(self.DetectTime).encode(ExternalEncoding))
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=%s,\n' % quote_python(self.StartTime).encode(ExternalEncoding))
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=%s,\n' % quote_python(self.EndTime).encode(ExternalEncoding))
        if self.ReportTime is not None:
            showIndent(outfile, level)
            outfile.write('ReportTime=%s,\n' % quote_python(self.ReportTime).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Assessment=[\n')
        level += 1
        for Assessment_ in self.Assessment:
            showIndent(outfile, level)
            outfile.write('model_.Assessment(\n')
            Assessment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Method=[\n')
        level += 1
        for Method_ in self.Method:
            showIndent(outfile, level)
            outfile.write('model_.Method(\n')
            Method_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Contact=[\n')
        level += 1
        for Contact_ in self.Contact:
            showIndent(outfile, level)
            outfile.write('model_.Contact(\n')
            Contact_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EventData=[\n')
        level += 1
        for EventData_ in self.EventData:
            showIndent(outfile, level)
            outfile.write('model_.EventData(\n')
            EventData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.History is not None:
            showIndent(outfile, level)
            outfile.write('History=model_.History(\n')
            self.History.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
        value = find_attr_value_('ext-purpose', node)
        if value is not None and 'ext-purpose' not in already_processed:
            already_processed.append('ext-purpose')
            self.ext_purpose = value
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.append('purpose')
            self.purpose = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IncidentID':
            obj_ = IncidentIDType.factory()
            obj_.build(child_)
            self.set_IncidentID(obj_)
        elif nodeName_ == 'AlternativeID':
            obj_ = AlternativeID.factory()
            obj_.build(child_)
            self.set_AlternativeID(obj_)
        elif nodeName_ == 'RelatedActivity':
            obj_ = RelatedActivity.factory()
            obj_.build(child_)
            self.set_RelatedActivity(obj_)
        elif nodeName_ == 'DetectTime':
            DetectTime_ = child_.text
            DetectTime_ = self.gds_validate_string(DetectTime_, node, 'DetectTime')
            self.DetectTime = DetectTime_
        elif nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
        elif nodeName_ == 'ReportTime':
            ReportTime_ = child_.text
            ReportTime_ = self.gds_validate_string(ReportTime_, node, 'ReportTime')
            self.ReportTime = ReportTime_
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'Assessment':
            obj_ = Assessment.factory()
            obj_.build(child_)
            self.Assessment.append(obj_)
        elif nodeName_ == 'Method':
            obj_ = Method.factory()
            obj_.build(child_)
            self.Method.append(obj_)
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact.append(obj_)
        elif nodeName_ == 'EventData':
            obj_ = EventData.factory()
            obj_.build(child_)
            self.EventData.append(obj_)
        elif nodeName_ == 'History':
            obj_ = History.factory()
            obj_.build(child_)
            self.set_History(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class Incident


class IncidentIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, instance=None, name=None, restriction='public', valueOf_=None):
        self.instance = _cast(None, instance)
        self.name = _cast(None, name)
        self.restriction = _cast(None, restriction)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IncidentIDType.subclass:
            return IncidentIDType.subclass(*args_, **kwargs_)
        else:
            return IncidentIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='IncidentIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncidentIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='IncidentIDType'):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='IncidentIDType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IncidentIDType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = "%s",\n' % (self.instance,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            self.instance = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IncidentIDType


class AlternativeID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction=None, IncidentID=None):
        self.restriction = _cast(None, restriction)
        if IncidentID is None:
            self.IncidentID = []
        else:
            self.IncidentID = IncidentID
    def factory(*args_, **kwargs_):
        if AlternativeID.subclass:
            return AlternativeID.subclass(*args_, **kwargs_)
        else:
            return AlternativeID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IncidentID(self): return self.IncidentID
    def set_IncidentID(self, IncidentID): self.IncidentID = IncidentID
    def add_IncidentID(self, value): self.IncidentID.append(value)
    def insert_IncidentID(self, index, value): self.IncidentID[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='AlternativeID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternativeID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='AlternativeID'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='AlternativeID', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IncidentID_ in self.IncidentID:
            IncidentID_.export(outfile, level, namespace_, name_='IncidentID', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IncidentID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AlternativeID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IncidentID=[\n')
        level += 1
        for IncidentID_ in self.IncidentID:
            showIndent(outfile, level)
            outfile.write('model_.IncidentID(\n')
            IncidentID_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IncidentID':
            obj_ = IncidentIDType.factory()
            obj_.build(child_)
            self.IncidentID.append(obj_)
# end class AlternativeID


class RelatedActivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction=None, IncidentID=None, URL=None):
        self.restriction = _cast(None, restriction)
        if IncidentID is None:
            self.IncidentID = []
        else:
            self.IncidentID = IncidentID
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
    def factory(*args_, **kwargs_):
        if RelatedActivity.subclass:
            return RelatedActivity.subclass(*args_, **kwargs_)
        else:
            return RelatedActivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IncidentID(self): return self.IncidentID
    def set_IncidentID(self, IncidentID): self.IncidentID = IncidentID
    def add_IncidentID(self, value): self.IncidentID.append(value)
    def insert_IncidentID(self, index, value): self.IncidentID[index] = value
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL(self, index, value): self.URL[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='RelatedActivity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedActivity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='RelatedActivity'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='RelatedActivity', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IncidentID_ in self.IncidentID:
            IncidentID_.export(outfile, level, namespace_, name_='IncidentID', pretty_print=pretty_print)
        for URL_ in self.URL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(URL_).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.IncidentID or
            self.URL
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RelatedActivity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IncidentID=[\n')
        level += 1
        for IncidentID_ in self.IncidentID:
            showIndent(outfile, level)
            outfile.write('model_.IncidentID(\n')
            IncidentID_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(URL_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IncidentID':
            obj_ = IncidentIDType.factory()
            obj_.build(child_)
            self.IncidentID.append(obj_)
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL.append(URL_)
# end class RelatedActivity


class Contact(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, role=None, ext_type=None, ext_role=None, restriction=None, ContactName=None, Description=None, RegistryHandle=None, PostalAddress=None, Email=None, Telephone=None, Fax=None, Timezone=None, Contact=None, AdditionalData=None):
        self.type_ = _cast(None, type_)
        self.role = _cast(None, role)
        self.ext_type = _cast(None, ext_type)
        self.ext_role = _cast(None, ext_role)
        self.restriction = _cast(None, restriction)
        self.ContactName = ContactName
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if RegistryHandle is None:
            self.RegistryHandle = []
        else:
            self.RegistryHandle = RegistryHandle
        self.PostalAddress = PostalAddress
        if Email is None:
            self.Email = []
        else:
            self.Email = Email
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        self.Fax = Fax
        self.Timezone = Timezone
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if Contact.subclass:
            return Contact.subclass(*args_, **kwargs_)
        else:
            return Contact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactName(self): return self.ContactName
    def set_ContactName(self, ContactName): self.ContactName = ContactName
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_RegistryHandle(self): return self.RegistryHandle
    def set_RegistryHandle(self, RegistryHandle): self.RegistryHandle = RegistryHandle
    def add_RegistryHandle(self, value): self.RegistryHandle.append(value)
    def insert_RegistryHandle(self, index, value): self.RegistryHandle[index] = value
    def get_PostalAddress(self): return self.PostalAddress
    def set_PostalAddress(self, PostalAddress): self.PostalAddress = PostalAddress
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def add_Email(self, value): self.Email.append(value)
    def insert_Email(self, index, value): self.Email[index] = value
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone(self, index, value): self.Telephone[index] = value
    def get_Fax(self): return self.Fax
    def set_Fax(self, Fax): self.Fax = Fax
    def get_Timezone(self): return self.Timezone
    def set_Timezone(self, Timezone): self.Timezone = Timezone
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def add_Contact(self, value): self.Contact.append(value)
    def insert_Contact(self, index, value): self.Contact[index] = value
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_ext_type(self): return self.ext_type
    def set_ext_type(self, ext_type): self.ext_type = ext_type
    def get_ext_role(self): return self.ext_role
    def set_ext_role(self, ext_role): self.ext_role = ext_role
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='Contact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Contact')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Contact'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            outfile.write(' ext-type=%s' % (self.gds_format_string(quote_attrib(self.ext_type).encode(ExternalEncoding), input_name='ext-type'), ))
        if self.ext_role is not None and 'ext_role' not in already_processed:
            already_processed.append('ext_role')
            outfile.write(' ext-role=%s' % (self.gds_format_string(quote_attrib(self.ext_role).encode(ExternalEncoding), input_name='ext-role'), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Contact', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactName is not None:
            self.ContactName.export(outfile, level, namespace_, name_='ContactName', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for RegistryHandle_ in self.RegistryHandle:
            RegistryHandle_.export(outfile, level, namespace_, name_='RegistryHandle', pretty_print=pretty_print)
        if self.PostalAddress is not None:
            self.PostalAddress.export(outfile, level, namespace_, name_='PostalAddress', pretty_print=pretty_print)
        for Email_ in self.Email:
            Email_.export(outfile, level, namespace_, name_='Email', pretty_print=pretty_print)
        for Telephone_ in self.Telephone:
            Telephone_.export(outfile, level, namespace_, name_='Telephone', pretty_print=pretty_print)
        if self.Fax is not None:
            self.Fax.export(outfile, level, namespace_, name_='Fax', pretty_print=pretty_print)
        if self.Timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimezone>%s</%sTimezone>%s' % (namespace_, self.gds_format_string(quote_xml(self.Timezone).encode(ExternalEncoding), input_name='Timezone'), namespace_, eol_))
        for Contact_ in self.Contact:
            Contact_.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ContactName is not None or
            self.Description or
            self.RegistryHandle or
            self.PostalAddress is not None or
            self.Email or
            self.Telephone or
            self.Fax is not None or
            self.Timezone is not None or
            self.Contact or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Contact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            showIndent(outfile, level)
            outfile.write('ext_type = "%s",\n' % (self.ext_type,))
        if self.ext_role is not None and 'ext_role' not in already_processed:
            already_processed.append('ext_role')
            showIndent(outfile, level)
            outfile.write('ext_role = "%s",\n' % (self.ext_role,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContactName is not None:
            showIndent(outfile, level)
            outfile.write('ContactName=model_.ContactName(\n')
            self.ContactName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RegistryHandle=[\n')
        level += 1
        for RegistryHandle_ in self.RegistryHandle:
            showIndent(outfile, level)
            outfile.write('model_.RegistryHandle(\n')
            RegistryHandle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PostalAddress is not None:
            showIndent(outfile, level)
            outfile.write('PostalAddress=model_.PostalAddress(\n')
            self.PostalAddress.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Email=[\n')
        level += 1
        for Email_ in self.Email:
            showIndent(outfile, level)
            outfile.write('model_.Email(\n')
            Email_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('model_.Telephone(\n')
            Telephone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Fax is not None:
            showIndent(outfile, level)
            outfile.write('Fax=model_.Fax(\n')
            self.Fax.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Timezone is not None:
            showIndent(outfile, level)
            outfile.write('Timezone=%s,\n' % quote_python(self.Timezone).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Contact=[\n')
        level += 1
        for Contact_ in self.Contact:
            showIndent(outfile, level)
            outfile.write('model_.Contact(\n')
            Contact_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('ext-type', node)
        if value is not None and 'ext-type' not in already_processed:
            already_processed.append('ext-type')
            self.ext_type = value
        value = find_attr_value_('ext-role', node)
        if value is not None and 'ext-role' not in already_processed:
            already_processed.append('ext-role')
            self.ext_role = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactName':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ContactName(obj_)
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'RegistryHandle':
            obj_ = RegistryHandle.factory()
            obj_.build(child_)
            self.RegistryHandle.append(obj_)
        elif nodeName_ == 'PostalAddress':
            obj_ = PostalAddress.factory()
            obj_.build(child_)
            self.set_PostalAddress(obj_)
        elif nodeName_ == 'Email':
            obj_ = ContactMeansType.factory()
            obj_.build(child_)
            self.Email.append(obj_)
        elif nodeName_ == 'Telephone':
            obj_ = ContactMeansType.factory()
            obj_.build(child_)
            self.Telephone.append(obj_)
        elif nodeName_ == 'Fax':
            obj_ = ContactMeansType.factory()
            obj_.build(child_)
            self.set_Fax(obj_)
        elif nodeName_ == 'Timezone':
            Timezone_ = child_.text
            Timezone_ = self.gds_validate_string(Timezone_, node, 'Timezone')
            self.Timezone = Timezone_
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact.append(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class Contact


class RegistryHandle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, registry=None, ext_registry=None, valueOf_=None):
        self.registry = _cast(None, registry)
        self.ext_registry = _cast(None, ext_registry)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RegistryHandle.subclass:
            return RegistryHandle.subclass(*args_, **kwargs_)
        else:
            return RegistryHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_registry(self): return self.registry
    def set_registry(self, registry): self.registry = registry
    def get_ext_registry(self): return self.ext_registry
    def set_ext_registry(self, ext_registry): self.ext_registry = ext_registry
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='RegistryHandle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegistryHandle')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='RegistryHandle'):
        if self.registry is not None and 'registry' not in already_processed:
            already_processed.append('registry')
            outfile.write(' registry=%s' % (self.gds_format_string(quote_attrib(self.registry).encode(ExternalEncoding), input_name='registry'), ))
        if self.ext_registry is not None and 'ext_registry' not in already_processed:
            already_processed.append('ext_registry')
            outfile.write(' ext-registry=%s' % (self.gds_format_string(quote_attrib(self.ext_registry).encode(ExternalEncoding), input_name='ext-registry'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='RegistryHandle', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegistryHandle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.registry is not None and 'registry' not in already_processed:
            already_processed.append('registry')
            showIndent(outfile, level)
            outfile.write('registry = "%s",\n' % (self.registry,))
        if self.ext_registry is not None and 'ext_registry' not in already_processed:
            already_processed.append('ext_registry')
            showIndent(outfile, level)
            outfile.write('ext_registry = "%s",\n' % (self.ext_registry,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('registry', node)
        if value is not None and 'registry' not in already_processed:
            already_processed.append('registry')
            self.registry = value
        value = find_attr_value_('ext-registry', node)
        if value is not None and 'ext-registry' not in already_processed:
            already_processed.append('ext-registry')
            self.ext_registry = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RegistryHandle


class ContactMeansType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, meaning=None, valueOf_=None):
        self.meaning = _cast(None, meaning)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ContactMeansType.subclass:
            return ContactMeansType.subclass(*args_, **kwargs_)
        else:
            return ContactMeansType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meaning(self): return self.meaning
    def set_meaning(self, meaning): self.meaning = meaning
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='ContactMeansType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactMeansType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='ContactMeansType'):
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            outfile.write(' meaning=%s' % (self.gds_format_string(quote_attrib(self.meaning).encode(ExternalEncoding), input_name='meaning'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='ContactMeansType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactMeansType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            showIndent(outfile, level)
            outfile.write('meaning = "%s",\n' % (self.meaning,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meaning', node)
        if value is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            self.meaning = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactMeansType


class History(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction='default', HistoryItem=None):
        self.restriction = _cast(None, restriction)
        if HistoryItem is None:
            self.HistoryItem = []
        else:
            self.HistoryItem = HistoryItem
    def factory(*args_, **kwargs_):
        if History.subclass:
            return History.subclass(*args_, **kwargs_)
        else:
            return History(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HistoryItem(self): return self.HistoryItem
    def set_HistoryItem(self, HistoryItem): self.HistoryItem = HistoryItem
    def add_HistoryItem(self, value): self.HistoryItem.append(value)
    def insert_HistoryItem(self, index, value): self.HistoryItem[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='History', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='History')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='History'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='History', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HistoryItem_ in self.HistoryItem:
            HistoryItem_.export(outfile, level, namespace_, name_='HistoryItem', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.HistoryItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='History'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('HistoryItem=[\n')
        level += 1
        for HistoryItem_ in self.HistoryItem:
            showIndent(outfile, level)
            outfile.write('model_.HistoryItem(\n')
            HistoryItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HistoryItem':
            obj_ = HistoryItem.factory()
            obj_.build(child_)
            self.HistoryItem.append(obj_)
# end class History


class HistoryItem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None, restriction=None, ext_action=None, DateTime=None, IncidentID=None, Contact=None, Description=None, AdditionalData=None):
        self.action = _cast(None, action)
        self.restriction = _cast(None, restriction)
        self.ext_action = _cast(None, ext_action)
        self.DateTime = DateTime
        self.IncidentID = IncidentID
        self.Contact = Contact
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if HistoryItem.subclass:
            return HistoryItem.subclass(*args_, **kwargs_)
        else:
            return HistoryItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_IncidentID(self): return self.IncidentID
    def set_IncidentID(self, IncidentID): self.IncidentID = IncidentID
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_ext_action(self): return self.ext_action
    def set_ext_action(self, ext_action): self.ext_action = ext_action
    def export(self, outfile, level, namespace_='iodef:', name_='HistoryItem', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoryItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='HistoryItem'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
        if self.ext_action is not None and 'ext_action' not in already_processed:
            already_processed.append('ext_action')
            outfile.write(' ext-action=%s' % (self.gds_format_string(quote_attrib(self.ext_action).encode(ExternalEncoding), input_name='ext-action'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='HistoryItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateTime>%s</%sDateTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.DateTime).encode(ExternalEncoding), input_name='DateTime'), namespace_, eol_))
        if self.IncidentID is not None:
            self.IncidentID.export(outfile, level, namespace_, name_='IncidentID', pretty_print=pretty_print)
        if self.Contact is not None:
            self.Contact.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.DateTime is not None or
            self.IncidentID is not None or
            self.Contact is not None or
            self.Description or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HistoryItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
        if self.ext_action is not None and 'ext_action' not in already_processed:
            already_processed.append('ext_action')
            showIndent(outfile, level)
            outfile.write('ext_action = "%s",\n' % (self.ext_action,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('DateTime=%s,\n' % quote_python(self.DateTime).encode(ExternalEncoding))
        if self.IncidentID is not None:
            showIndent(outfile, level)
            outfile.write('IncidentID=model_.IncidentID(\n')
            self.IncidentID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Contact is not None:
            showIndent(outfile, level)
            outfile.write('Contact=model_.Contact(\n')
            self.Contact.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
        value = find_attr_value_('ext-action', node)
        if value is not None and 'ext-action' not in already_processed:
            already_processed.append('ext-action')
            self.ext_action = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateTime':
            DateTime_ = child_.text
            DateTime_ = self.gds_validate_string(DateTime_, node, 'DateTime')
            self.DateTime = DateTime_
        elif nodeName_ == 'IncidentID':
            obj_ = IncidentIDType.factory()
            obj_.build(child_)
            self.set_IncidentID(obj_)
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.set_Contact(obj_)
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class HistoryItem


class Expectation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action='other', restriction='default', ext_action=None, severity=None, Description=None, StartTime=None, EndTime=None, Contact=None):
        self.action = _cast(None, action)
        self.restriction = _cast(None, restriction)
        self.ext_action = _cast(None, ext_action)
        self.severity = _cast(None, severity)
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.StartTime = StartTime
        self.EndTime = EndTime
        self.Contact = Contact
    def factory(*args_, **kwargs_):
        if Expectation.subclass:
            return Expectation.subclass(*args_, **kwargs_)
        else:
            return Expectation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_ext_action(self): return self.ext_action
    def set_ext_action(self, ext_action): self.ext_action = ext_action
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def export(self, outfile, level, namespace_='iodef:', name_='Expectation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Expectation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Expectation'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
        if self.ext_action is not None and 'ext_action' not in already_processed:
            already_processed.append('ext_action')
            outfile.write(' ext-action=%s' % (self.gds_format_string(quote_attrib(self.ext_action).encode(ExternalEncoding), input_name='ext-action'), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Expectation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), namespace_, eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.EndTime).encode(ExternalEncoding), input_name='EndTime'), namespace_, eol_))
        if self.Contact is not None:
            self.Contact.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description or
            self.StartTime is not None or
            self.EndTime is not None or
            self.Contact is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Expectation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.append('action')
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
        if self.ext_action is not None and 'ext_action' not in already_processed:
            already_processed.append('ext_action')
            showIndent(outfile, level)
            outfile.write('ext_action = "%s",\n' % (self.ext_action,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            showIndent(outfile, level)
            outfile.write('severity = %s,\n' % (self.severity,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=%s,\n' % quote_python(self.StartTime).encode(ExternalEncoding))
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=%s,\n' % quote_python(self.EndTime).encode(ExternalEncoding))
        if self.Contact is not None:
            showIndent(outfile, level)
            outfile.write('Contact=model_.Contact(\n')
            self.Contact.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.append('action')
            self.action = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
        value = find_attr_value_('ext-action', node)
        if value is not None and 'ext-action' not in already_processed:
            already_processed.append('ext-action')
            self.ext_action = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            self.severity = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.set_Contact(obj_)
# end class Expectation


class Method(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction=None, Reference=None, Description=None, AdditionalData=None):
        self.restriction = _cast(None, restriction)
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if Method.subclass:
            return Method.subclass(*args_, **kwargs_)
        else:
            return Method(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='Method', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Method')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Method'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Method', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Reference or
            self.Description or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Method'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference(\n')
            Reference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = Reference.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class Method


class Reference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReferenceName=None, URL=None, Description=None):
        self.ReferenceName = ReferenceName
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
    def factory(*args_, **kwargs_):
        if Reference.subclass:
            return Reference.subclass(*args_, **kwargs_)
        else:
            return Reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReferenceName(self): return self.ReferenceName
    def set_ReferenceName(self, ReferenceName): self.ReferenceName = ReferenceName
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL(self, index, value): self.URL[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def export(self, outfile, level, namespace_='iodef:', name_='Reference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Reference'):
        pass
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Reference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReferenceName is not None:
            self.ReferenceName.export(outfile, level, namespace_, name_='ReferenceName', pretty_print=pretty_print)
        for URL_ in self.URL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(URL_).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ReferenceName is not None or
            self.URL or
            self.Description
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Reference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ReferenceName is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceName=model_.MLStringType(\n')
            self.ReferenceName.exportLiteral(outfile, level, name_='ReferenceName')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(URL_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReferenceName':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_ReferenceName(obj_)
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL.append(URL_)
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
# end class Reference


class Assessment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction=None, occurrence=None, Impact=None, TimeImpact=None, MonetaryImpact=None, Counter=None, Confidence=None, AdditionalData=None):
        self.restriction = _cast(None, restriction)
        self.occurrence = _cast(None, occurrence)
        if Impact is None:
            self.Impact = []
        else:
            self.Impact = Impact
        if TimeImpact is None:
            self.TimeImpact = []
        else:
            self.TimeImpact = TimeImpact
        if MonetaryImpact is None:
            self.MonetaryImpact = []
        else:
            self.MonetaryImpact = MonetaryImpact
        if Counter is None:
            self.Counter = []
        else:
            self.Counter = Counter
        self.Confidence = Confidence
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if Assessment.subclass:
            return Assessment.subclass(*args_, **kwargs_)
        else:
            return Assessment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Impact(self): return self.Impact
    def set_Impact(self, Impact): self.Impact = Impact
    def add_Impact(self, value): self.Impact.append(value)
    def insert_Impact(self, index, value): self.Impact[index] = value
    def get_TimeImpact(self): return self.TimeImpact
    def set_TimeImpact(self, TimeImpact): self.TimeImpact = TimeImpact
    def add_TimeImpact(self, value): self.TimeImpact.append(value)
    def insert_TimeImpact(self, index, value): self.TimeImpact[index] = value
    def get_MonetaryImpact(self): return self.MonetaryImpact
    def set_MonetaryImpact(self, MonetaryImpact): self.MonetaryImpact = MonetaryImpact
    def add_MonetaryImpact(self, value): self.MonetaryImpact.append(value)
    def insert_MonetaryImpact(self, index, value): self.MonetaryImpact[index] = value
    def get_Counter(self): return self.Counter
    def set_Counter(self, Counter): self.Counter = Counter
    def add_Counter(self, value): self.Counter.append(value)
    def insert_Counter(self, index, value): self.Counter[index] = value
    def get_Confidence(self): return self.Confidence
    def set_Confidence(self, Confidence): self.Confidence = Confidence
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_occurrence(self): return self.occurrence
    def set_occurrence(self, occurrence): self.occurrence = occurrence
    def export(self, outfile, level, namespace_='iodef:', name_='Assessment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Assessment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Assessment'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.append('occurrence')
            outfile.write(' occurrence=%s' % (self.gds_format_string(quote_attrib(self.occurrence).encode(ExternalEncoding), input_name='occurrence'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Assessment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Impact_ in self.Impact:
            Impact_.export(outfile, level, namespace_, name_='Impact', pretty_print=pretty_print)
        for TimeImpact_ in self.TimeImpact:
            TimeImpact_.export(outfile, level, namespace_, name_='TimeImpact', pretty_print=pretty_print)
        for MonetaryImpact_ in self.MonetaryImpact:
            MonetaryImpact_.export(outfile, level, namespace_, name_='MonetaryImpact', pretty_print=pretty_print)
        for Counter_ in self.Counter:
            Counter_.export(outfile, level, namespace_, name_='Counter', pretty_print=pretty_print)
        if self.Confidence is not None:
            self.Confidence.export(outfile, level, namespace_, name_='Confidence', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Impact or
            self.TimeImpact or
            self.MonetaryImpact or
            self.Counter or
            self.Confidence is not None or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Assessment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
        if self.occurrence is not None and 'occurrence' not in already_processed:
            already_processed.append('occurrence')
            showIndent(outfile, level)
            outfile.write('occurrence = "%s",\n' % (self.occurrence,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Impact=[\n')
        level += 1
        for Impact_ in self.Impact:
            showIndent(outfile, level)
            outfile.write('model_.Impact(\n')
            Impact_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TimeImpact=[\n')
        level += 1
        for TimeImpact_ in self.TimeImpact:
            showIndent(outfile, level)
            outfile.write('model_.TimeImpact(\n')
            TimeImpact_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MonetaryImpact=[\n')
        level += 1
        for MonetaryImpact_ in self.MonetaryImpact:
            showIndent(outfile, level)
            outfile.write('model_.MonetaryImpact(\n')
            MonetaryImpact_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Counter=[\n')
        level += 1
        for Counter_ in self.Counter:
            showIndent(outfile, level)
            outfile.write('model_.Counter(\n')
            Counter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Confidence is not None:
            showIndent(outfile, level)
            outfile.write('Confidence=model_.Confidence(\n')
            self.Confidence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
        value = find_attr_value_('occurrence', node)
        if value is not None and 'occurrence' not in already_processed:
            already_processed.append('occurrence')
            self.occurrence = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Impact':
            obj_ = Impact.factory()
            obj_.build(child_)
            self.Impact.append(obj_)
        elif nodeName_ == 'TimeImpact':
            obj_ = TimeImpact.factory()
            obj_.build(child_)
            self.TimeImpact.append(obj_)
        elif nodeName_ == 'MonetaryImpact':
            obj_ = MonetaryImpact.factory()
            obj_.build(child_)
            self.MonetaryImpact.append(obj_)
        elif nodeName_ == 'Counter':
            obj_ = Counter.factory()
            obj_.build(child_)
            self.Counter.append(obj_)
        elif nodeName_ == 'Confidence':
            obj_ = Confidence.factory()
            obj_.build(child_)
            self.set_Confidence(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class Assessment


class TimeImpact(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ext_metric=None, duration=None, metric=None, severity=None, ext_duration=None, valueOf_=None):
        self.ext_metric = _cast(None, ext_metric)
        self.duration = _cast(None, duration)
        self.metric = _cast(None, metric)
        self.severity = _cast(None, severity)
        self.ext_duration = _cast(None, ext_duration)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimeImpact.subclass:
            return TimeImpact.subclass(*args_, **kwargs_)
        else:
            return TimeImpact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ext_metric(self): return self.ext_metric
    def set_ext_metric(self, ext_metric): self.ext_metric = ext_metric
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_metric(self): return self.metric
    def set_metric(self, metric): self.metric = metric
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_ext_duration(self): return self.ext_duration
    def set_ext_duration(self, ext_duration): self.ext_duration = ext_duration
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='TimeImpact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeImpact')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='TimeImpact'):
        if self.ext_metric is not None and 'ext_metric' not in already_processed:
            already_processed.append('ext_metric')
            outfile.write(' ext-metric=%s' % (self.gds_format_string(quote_attrib(self.ext_metric).encode(ExternalEncoding), input_name='ext-metric'), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration=%s' % (quote_attrib(self.duration), ))
        if self.metric is not None and 'metric' not in already_processed:
            already_processed.append('metric')
            outfile.write(' metric=%s' % (self.gds_format_string(quote_attrib(self.metric).encode(ExternalEncoding), input_name='metric'), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
        if self.ext_duration is not None and 'ext_duration' not in already_processed:
            already_processed.append('ext_duration')
            outfile.write(' ext-duration=%s' % (self.gds_format_string(quote_attrib(self.ext_duration).encode(ExternalEncoding), input_name='ext-duration'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='TimeImpact', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeImpact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ext_metric is not None and 'ext_metric' not in already_processed:
            already_processed.append('ext_metric')
            showIndent(outfile, level)
            outfile.write('ext_metric = "%s",\n' % (self.ext_metric,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = %s,\n' % (self.duration,))
        if self.metric is not None and 'metric' not in already_processed:
            already_processed.append('metric')
            showIndent(outfile, level)
            outfile.write('metric = "%s",\n' % (self.metric,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            showIndent(outfile, level)
            outfile.write('severity = %s,\n' % (self.severity,))
        if self.ext_duration is not None and 'ext_duration' not in already_processed:
            already_processed.append('ext_duration')
            showIndent(outfile, level)
            outfile.write('ext_duration = "%s",\n' % (self.ext_duration,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ext-metric', node)
        if value is not None and 'ext-metric' not in already_processed:
            already_processed.append('ext-metric')
            self.ext_metric = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            self.duration = value
        value = find_attr_value_('metric', node)
        if value is not None and 'metric' not in already_processed:
            already_processed.append('metric')
            self.metric = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            self.severity = value
        value = find_attr_value_('ext-duration', node)
        if value is not None and 'ext-duration' not in already_processed:
            already_processed.append('ext-duration')
            self.ext_duration = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeImpact


class MonetaryImpact(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, currency=None, severity=None, valueOf_=None):
        self.currency = _cast(None, currency)
        self.severity = _cast(None, severity)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MonetaryImpact.subclass:
            return MonetaryImpact.subclass(*args_, **kwargs_)
        else:
            return MonetaryImpact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='MonetaryImpact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonetaryImpact')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='MonetaryImpact'):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='MonetaryImpact', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MonetaryImpact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            showIndent(outfile, level)
            outfile.write('currency = "%s",\n' % (self.currency,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            showIndent(outfile, level)
            outfile.write('severity = %s,\n' % (self.severity,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            self.currency = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            self.severity = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MonetaryImpact


class Confidence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rating=None, valueOf_=None, mixedclass_=None, content_=None):
        self.rating = _cast(None, rating)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Confidence.subclass:
            return Confidence.subclass(*args_, **kwargs_)
        else:
            return Confidence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rating(self): return self.rating
    def set_rating(self, rating): self.rating = rating
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='Confidence', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Confidence')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Confidence'):
        if self.rating is not None and 'rating' not in already_processed:
            already_processed.append('rating')
            outfile.write(' rating=%s' % (self.gds_format_string(quote_attrib(self.rating).encode(ExternalEncoding), input_name='rating'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Confidence', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Confidence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rating is not None and 'rating' not in already_processed:
            already_processed.append('rating')
            showIndent(outfile, level)
            outfile.write('rating = "%s",\n' % (self.rating,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rating', node)
        if value is not None and 'rating' not in already_processed:
            already_processed.append('rating')
            self.rating = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class Confidence


class EventData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction='default', Description=None, DetectTime=None, StartTime=None, EndTime=None, Contact=None, Assessment=None, Method=None, Flow=None, Expectation=None, Record=None, EventData=None, AdditionalData=None):
        self.restriction = _cast(None, restriction)
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.DetectTime = DetectTime
        self.StartTime = StartTime
        self.EndTime = EndTime
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
        self.Assessment = Assessment
        if Method is None:
            self.Method = []
        else:
            self.Method = Method
        if Flow is None:
            self.Flow = []
        else:
            self.Flow = Flow
        if Expectation is None:
            self.Expectation = []
        else:
            self.Expectation = Expectation
        self.Record = Record
        if EventData is None:
            self.EventData = []
        else:
            self.EventData = EventData
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if EventData.subclass:
            return EventData.subclass(*args_, **kwargs_)
        else:
            return EventData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_DetectTime(self): return self.DetectTime
    def set_DetectTime(self, DetectTime): self.DetectTime = DetectTime
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def add_Contact(self, value): self.Contact.append(value)
    def insert_Contact(self, index, value): self.Contact[index] = value
    def get_Assessment(self): return self.Assessment
    def set_Assessment(self, Assessment): self.Assessment = Assessment
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def add_Method(self, value): self.Method.append(value)
    def insert_Method(self, index, value): self.Method[index] = value
    def get_Flow(self): return self.Flow
    def set_Flow(self, Flow): self.Flow = Flow
    def add_Flow(self, value): self.Flow.append(value)
    def insert_Flow(self, index, value): self.Flow[index] = value
    def get_Expectation(self): return self.Expectation
    def set_Expectation(self, Expectation): self.Expectation = Expectation
    def add_Expectation(self, value): self.Expectation.append(value)
    def insert_Expectation(self, index, value): self.Expectation[index] = value
    def get_Record(self): return self.Record
    def set_Record(self, Record): self.Record = Record
    def get_EventData(self): return self.EventData
    def set_EventData(self, EventData): self.EventData = EventData
    def add_EventData(self, value): self.EventData.append(value)
    def insert_EventData(self, index, value): self.EventData[index] = value
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='EventData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='EventData'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='EventData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.DetectTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetectTime>%s</%sDetectTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.DetectTime).encode(ExternalEncoding), input_name='DetectTime'), namespace_, eol_))
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), namespace_, eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.EndTime).encode(ExternalEncoding), input_name='EndTime'), namespace_, eol_))
        for Contact_ in self.Contact:
            Contact_.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
        if self.Assessment is not None:
            self.Assessment.export(outfile, level, namespace_, name_='Assessment', pretty_print=pretty_print)
        for Method_ in self.Method:
            Method_.export(outfile, level, namespace_, name_='Method', pretty_print=pretty_print)
        for Flow_ in self.Flow:
            Flow_.export(outfile, level, namespace_, name_='Flow', pretty_print=pretty_print)
        for Expectation_ in self.Expectation:
            Expectation_.export(outfile, level, namespace_, name_='Expectation', pretty_print=pretty_print)
        if self.Record is not None:
            self.Record.export(outfile, level, namespace_, name_='Record', pretty_print=pretty_print)
        for EventData_ in self.EventData:
            EventData_.export(outfile, level, namespace_, name_='EventData', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Description or
            self.DetectTime is not None or
            self.StartTime is not None or
            self.EndTime is not None or
            self.Contact or
            self.Assessment is not None or
            self.Method or
            self.Flow or
            self.Expectation or
            self.Record is not None or
            self.EventData or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EventData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DetectTime is not None:
            showIndent(outfile, level)
            outfile.write('DetectTime=%s,\n' % quote_python(self.DetectTime).encode(ExternalEncoding))
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=%s,\n' % quote_python(self.StartTime).encode(ExternalEncoding))
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=%s,\n' % quote_python(self.EndTime).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Contact=[\n')
        level += 1
        for Contact_ in self.Contact:
            showIndent(outfile, level)
            outfile.write('model_.Contact(\n')
            Contact_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Assessment is not None:
            showIndent(outfile, level)
            outfile.write('Assessment=model_.Assessment(\n')
            self.Assessment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Method=[\n')
        level += 1
        for Method_ in self.Method:
            showIndent(outfile, level)
            outfile.write('model_.Method(\n')
            Method_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Flow=[\n')
        level += 1
        for Flow_ in self.Flow:
            showIndent(outfile, level)
            outfile.write('model_.Flow(\n')
            Flow_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Expectation=[\n')
        level += 1
        for Expectation_ in self.Expectation:
            showIndent(outfile, level)
            outfile.write('model_.Expectation(\n')
            Expectation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Record is not None:
            showIndent(outfile, level)
            outfile.write('Record=model_.Record(\n')
            self.Record.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('EventData=[\n')
        level += 1
        for EventData_ in self.EventData:
            showIndent(outfile, level)
            outfile.write('model_.EventData(\n')
            EventData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'DetectTime':
            DetectTime_ = child_.text
            DetectTime_ = self.gds_validate_string(DetectTime_, node, 'DetectTime')
            self.DetectTime = DetectTime_
        elif nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
        elif nodeName_ == 'Contact':
            obj_ = Contact.factory()
            obj_.build(child_)
            self.Contact.append(obj_)
        elif nodeName_ == 'Assessment':
            obj_ = Assessment.factory()
            obj_.build(child_)
            self.set_Assessment(obj_)
        elif nodeName_ == 'Method':
            obj_ = Method.factory()
            obj_.build(child_)
            self.Method.append(obj_)
        elif nodeName_ == 'Flow':
            obj_ = Flow.factory()
            obj_.build(child_)
            self.Flow.append(obj_)
        elif nodeName_ == 'Expectation':
            obj_ = Expectation.factory()
            obj_.build(child_)
            self.Expectation.append(obj_)
        elif nodeName_ == 'Record':
            obj_ = Record.factory()
            obj_.build(child_)
            self.set_Record(obj_)
        elif nodeName_ == 'EventData':
            obj_ = EventData.factory()
            obj_.build(child_)
            self.EventData.append(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class EventData


class Flow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, System=None):
        if System is None:
            self.System = []
        else:
            self.System = System
    def factory(*args_, **kwargs_):
        if Flow.subclass:
            return Flow.subclass(*args_, **kwargs_)
        else:
            return Flow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def add_System(self, value): self.System.append(value)
    def insert_System(self, index, value): self.System[index] = value
    def export(self, outfile, level, namespace_='iodef:', name_='Flow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Flow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Flow'):
        pass
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Flow', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for System_ in self.System:
            System_.export(outfile, level, namespace_, name_='System', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.System
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Flow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('System=[\n')
        level += 1
        for System_ in self.System:
            showIndent(outfile, level)
            outfile.write('model_.System(\n')
            System_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'System':
            obj_ = System.factory()
            obj_.build(child_)
            self.System.append(obj_)
# end class Flow


class System(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, interface=None, restriction=None, ext_category=None, category=None, spoofed='unknown', Node=None, Service=None, OperatingSystem=None, Counter=None, Description=None, AdditionalData=None):
        self.interface = _cast(None, interface)
        self.restriction = _cast(None, restriction)
        self.ext_category = _cast(None, ext_category)
        self.category = _cast(None, category)
        self.spoofed = _cast(None, spoofed)
        self.Node = Node
        if Service is None:
            self.Service = []
        else:
            self.Service = Service
        if OperatingSystem is None:
            self.OperatingSystem = []
        else:
            self.OperatingSystem = OperatingSystem
        if Counter is None:
            self.Counter = []
        else:
            self.Counter = Counter
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if System.subclass:
            return System.subclass(*args_, **kwargs_)
        else:
            return System(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Node(self): return self.Node
    def set_Node(self, Node): self.Node = Node
    def get_Service(self): return self.Service
    def set_Service(self, Service): self.Service = Service
    def add_Service(self, value): self.Service.append(value)
    def insert_Service(self, index, value): self.Service[index] = value
    def get_OperatingSystem(self): return self.OperatingSystem
    def set_OperatingSystem(self, OperatingSystem): self.OperatingSystem = OperatingSystem
    def add_OperatingSystem(self, value): self.OperatingSystem.append(value)
    def insert_OperatingSystem(self, index, value): self.OperatingSystem[index] = value
    def get_Counter(self): return self.Counter
    def set_Counter(self, Counter): self.Counter = Counter
    def add_Counter(self, value): self.Counter.append(value)
    def insert_Counter(self, index, value): self.Counter[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_interface(self): return self.interface
    def set_interface(self, interface): self.interface = interface
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_ext_category(self): return self.ext_category
    def set_ext_category(self, ext_category): self.ext_category = ext_category
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_spoofed(self): return self.spoofed
    def set_spoofed(self, spoofed): self.spoofed = spoofed
    def export(self, outfile, level, namespace_='iodef:', name_='System', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='System')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='System'):
        if self.interface is not None and 'interface' not in already_processed:
            already_processed.append('interface')
            outfile.write(' interface=%s' % (self.gds_format_string(quote_attrib(self.interface).encode(ExternalEncoding), input_name='interface'), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
        if self.ext_category is not None and 'ext_category' not in already_processed:
            already_processed.append('ext_category')
            outfile.write(' ext-category=%s' % (self.gds_format_string(quote_attrib(self.ext_category).encode(ExternalEncoding), input_name='ext-category'), ))
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            outfile.write(' category=%s' % (self.gds_format_string(quote_attrib(self.category).encode(ExternalEncoding), input_name='category'), ))
        if self.spoofed is not None and 'spoofed' not in already_processed:
            already_processed.append('spoofed')
            outfile.write(' spoofed=%s' % (self.gds_format_string(quote_attrib(self.spoofed).encode(ExternalEncoding), input_name='spoofed'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='System', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Node is not None:
            self.Node.export(outfile, level, namespace_, name_='Node', pretty_print=pretty_print)
        for Service_ in self.Service:
            Service_.export(outfile, level, namespace_, name_='Service', pretty_print=pretty_print)
        for OperatingSystem_ in self.OperatingSystem:
            OperatingSystem_.export(outfile, level, namespace_, name_='OperatingSystem', pretty_print=pretty_print)
        for Counter_ in self.Counter:
            Counter_.export(outfile, level, namespace_, name_='Counter', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Node is not None or
            self.Service or
            self.OperatingSystem or
            self.Counter or
            self.Description or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='System'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interface is not None and 'interface' not in already_processed:
            already_processed.append('interface')
            showIndent(outfile, level)
            outfile.write('interface = "%s",\n' % (self.interface,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
        if self.ext_category is not None and 'ext_category' not in already_processed:
            already_processed.append('ext_category')
            showIndent(outfile, level)
            outfile.write('ext_category = "%s",\n' % (self.ext_category,))
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            showIndent(outfile, level)
            outfile.write('category = "%s",\n' % (self.category,))
        if self.spoofed is not None and 'spoofed' not in already_processed:
            already_processed.append('spoofed')
            showIndent(outfile, level)
            outfile.write('spoofed = "%s",\n' % (self.spoofed,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Node is not None:
            showIndent(outfile, level)
            outfile.write('Node=model_.Node(\n')
            self.Node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Service=[\n')
        level += 1
        for Service_ in self.Service:
            showIndent(outfile, level)
            outfile.write('model_.Service(\n')
            Service_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OperatingSystem=[\n')
        level += 1
        for OperatingSystem_ in self.OperatingSystem:
            showIndent(outfile, level)
            outfile.write('model_.OperatingSystem(\n')
            OperatingSystem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Counter=[\n')
        level += 1
        for Counter_ in self.Counter:
            showIndent(outfile, level)
            outfile.write('model_.Counter(\n')
            Counter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interface', node)
        if value is not None and 'interface' not in already_processed:
            already_processed.append('interface')
            self.interface = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
        value = find_attr_value_('ext-category', node)
        if value is not None and 'ext-category' not in already_processed:
            already_processed.append('ext-category')
            self.ext_category = value
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.append('category')
            self.category = value
        value = find_attr_value_('spoofed', node)
        if value is not None and 'spoofed' not in already_processed:
            already_processed.append('spoofed')
            self.spoofed = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Node':
            obj_ = Node.factory()
            obj_.build(child_)
            self.set_Node(obj_)
        elif nodeName_ == 'Service':
            obj_ = Service.factory()
            obj_.build(child_)
            self.Service.append(obj_)
        elif nodeName_ == 'OperatingSystem':
            obj_ = SoftwareType.factory()
            obj_.build(child_)
            self.OperatingSystem.append(obj_)
        elif nodeName_ == 'Counter':
            obj_ = Counter.factory()
            obj_.build(child_)
            self.Counter.append(obj_)
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class System


class Node(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NodeName=None, Address=None, Location=None, DateTime=None, NodeRole=None, Counter=None):
        if NodeName is None:
            self.NodeName = []
        else:
            self.NodeName = NodeName
        if Address is None:
            self.Address = []
        else:
            self.Address = Address
        self.Location = Location
        self.DateTime = DateTime
        if NodeRole is None:
            self.NodeRole = []
        else:
            self.NodeRole = NodeRole
        if Counter is None:
            self.Counter = []
        else:
            self.Counter = Counter
    def factory(*args_, **kwargs_):
        if Node.subclass:
            return Node.subclass(*args_, **kwargs_)
        else:
            return Node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NodeName(self): return self.NodeName
    def set_NodeName(self, NodeName): self.NodeName = NodeName
    def add_NodeName(self, value): self.NodeName.append(value)
    def insert_NodeName(self, index, value): self.NodeName[index] = value
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def add_Address(self, value): self.Address.append(value)
    def insert_Address(self, index, value): self.Address[index] = value
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_NodeRole(self): return self.NodeRole
    def set_NodeRole(self, NodeRole): self.NodeRole = NodeRole
    def add_NodeRole(self, value): self.NodeRole.append(value)
    def insert_NodeRole(self, index, value): self.NodeRole[index] = value
    def get_Counter(self): return self.Counter
    def set_Counter(self, Counter): self.Counter = Counter
    def add_Counter(self, value): self.Counter.append(value)
    def insert_Counter(self, index, value): self.Counter[index] = value
    def export(self, outfile, level, namespace_='iodef:', name_='Node', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Node')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Node'):
        pass
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Node', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NodeName_ in self.NodeName:
            NodeName_.export(outfile, level, namespace_, name_='NodeName', pretty_print=pretty_print)
        for Address_ in self.Address:
            Address_.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location', pretty_print=pretty_print)
        if self.DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateTime>%s</%sDateTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.DateTime).encode(ExternalEncoding), input_name='DateTime'), namespace_, eol_))
        for NodeRole_ in self.NodeRole:
            NodeRole_.export(outfile, level, namespace_, name_='NodeRole', pretty_print=pretty_print)
        for Counter_ in self.Counter:
            Counter_.export(outfile, level, namespace_, name_='Counter', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.NodeName or
            self.Address or
            self.Location is not None or
            self.DateTime is not None or
            self.NodeRole or
            self.Counter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Node'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NodeName=[\n')
        level += 1
        for NodeName_ in self.NodeName:
            showIndent(outfile, level)
            outfile.write('model_.MLStringType(\n')
            NodeName_.exportLiteral(outfile, level, name_='MLStringType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Address=[\n')
        level += 1
        for Address_ in self.Address:
            showIndent(outfile, level)
            outfile.write('model_.Address(\n')
            Address_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.Location(\n')
            self.Location.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('DateTime=%s,\n' % quote_python(self.DateTime).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('NodeRole=[\n')
        level += 1
        for NodeRole_ in self.NodeRole:
            showIndent(outfile, level)
            outfile.write('model_.NodeRole(\n')
            NodeRole_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Counter=[\n')
        level += 1
        for Counter_ in self.Counter:
            showIndent(outfile, level)
            outfile.write('model_.Counter(\n')
            Counter_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NodeName':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NodeName.append(obj_)
        elif nodeName_ == 'Address':
            obj_ = Address.factory()
            obj_.build(child_)
            self.Address.append(obj_)
        elif nodeName_ == 'Location':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DateTime':
            DateTime_ = child_.text
            DateTime_ = self.gds_validate_string(DateTime_, node, 'DateTime')
            self.DateTime = DateTime_
        elif nodeName_ == 'NodeRole':
            obj_ = NodeRole.factory()
            obj_.build(child_)
            self.NodeRole.append(obj_)
        elif nodeName_ == 'Counter':
            obj_ = Counter.factory()
            obj_.build(child_)
            self.Counter.append(obj_)
# end class Node


class Address(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, category='ipv4-addr', vlan_name=None, ext_category=None, vlan_num=None, valueOf_=None):
        self.category = _cast(None, category)
        self.vlan_name = _cast(None, vlan_name)
        self.ext_category = _cast(None, ext_category)
        self.vlan_num = _cast(int, vlan_num)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Address.subclass:
            return Address.subclass(*args_, **kwargs_)
        else:
            return Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_vlan_name(self): return self.vlan_name
    def set_vlan_name(self, vlan_name): self.vlan_name = vlan_name
    def get_ext_category(self): return self.ext_category
    def set_ext_category(self, ext_category): self.ext_category = ext_category
    def get_vlan_num(self): return self.vlan_num
    def set_vlan_num(self, vlan_num): self.vlan_num = vlan_num
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='Address', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Address')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Address'):
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            outfile.write(' category=%s' % (self.gds_format_string(quote_attrib(self.category).encode(ExternalEncoding), input_name='category'), ))
        if self.vlan_name is not None and 'vlan_name' not in already_processed:
            already_processed.append('vlan_name')
            outfile.write(' vlan-name=%s' % (self.gds_format_string(quote_attrib(self.vlan_name).encode(ExternalEncoding), input_name='vlan-name'), ))
        if self.ext_category is not None and 'ext_category' not in already_processed:
            already_processed.append('ext_category')
            outfile.write(' ext-category=%s' % (self.gds_format_string(quote_attrib(self.ext_category).encode(ExternalEncoding), input_name='ext-category'), ))
        if self.vlan_num is not None and 'vlan_num' not in already_processed:
            already_processed.append('vlan_num')
            outfile.write(' vlan-num="%s"' % self.gds_format_integer(self.vlan_num, input_name='vlan-num'))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Address', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Address'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            showIndent(outfile, level)
            outfile.write('category = "%s",\n' % (self.category,))
        if self.vlan_name is not None and 'vlan_name' not in already_processed:
            already_processed.append('vlan_name')
            showIndent(outfile, level)
            outfile.write('vlan_name = "%s",\n' % (self.vlan_name,))
        if self.ext_category is not None and 'ext_category' not in already_processed:
            already_processed.append('ext_category')
            showIndent(outfile, level)
            outfile.write('ext_category = "%s",\n' % (self.ext_category,))
        if self.vlan_num is not None and 'vlan_num' not in already_processed:
            already_processed.append('vlan_num')
            showIndent(outfile, level)
            outfile.write('vlan_num = %d,\n' % (self.vlan_num,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.append('category')
            self.category = value
        value = find_attr_value_('vlan-name', node)
        if value is not None and 'vlan-name' not in already_processed:
            already_processed.append('vlan-name')
            self.vlan_name = value
        value = find_attr_value_('ext-category', node)
        if value is not None and 'ext-category' not in already_processed:
            already_processed.append('ext-category')
            self.ext_category = value
        value = find_attr_value_('vlan-num', node)
        if value is not None and 'vlan-num' not in already_processed:
            already_processed.append('vlan-num')
            try:
                self.vlan_num = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Address


class Service(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ip_protocol=None, Port=None, Portlist=None, ProtoType=None, ProtoCode=None, ProtoField=None, Application=None):
        self.ip_protocol = _cast(int, ip_protocol)
        self.Port = Port
        self.Portlist = Portlist
        self.ProtoType = ProtoType
        self.ProtoCode = ProtoCode
        self.ProtoField = ProtoField
        self.Application = Application
    def factory(*args_, **kwargs_):
        if Service.subclass:
            return Service.subclass(*args_, **kwargs_)
        else:
            return Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_Portlist(self): return self.Portlist
    def set_Portlist(self, Portlist): self.Portlist = Portlist
    def validate_PortlistType(self, value):
        # Validate type PortlistType, a restriction on xs:string.
        pass
    def get_ProtoType(self): return self.ProtoType
    def set_ProtoType(self, ProtoType): self.ProtoType = ProtoType
    def get_ProtoCode(self): return self.ProtoCode
    def set_ProtoCode(self, ProtoCode): self.ProtoCode = ProtoCode
    def get_ProtoField(self): return self.ProtoField
    def set_ProtoField(self, ProtoField): self.ProtoField = ProtoField
    def get_Application(self): return self.Application
    def set_Application(self, Application): self.Application = Application
    def get_ip_protocol(self): return self.ip_protocol
    def set_ip_protocol(self, ip_protocol): self.ip_protocol = ip_protocol
    def export(self, outfile, level, namespace_='iodef:', name_='Service', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Service'):
        if self.ip_protocol is not None and 'ip_protocol' not in already_processed:
            already_processed.append('ip_protocol')
            outfile.write(' ip_protocol="%s"' % self.gds_format_integer(self.ip_protocol, input_name='ip_protocol'))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Service', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_integer(self.Port, input_name='Port'), namespace_, eol_))
        if self.Portlist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortlist>%s</%sPortlist>%s' % (namespace_, self.gds_format_string(quote_xml(self.Portlist).encode(ExternalEncoding), input_name='Portlist'), namespace_, eol_))
        if self.ProtoType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtoType>%s</%sProtoType>%s' % (namespace_, self.gds_format_integer(self.ProtoType, input_name='ProtoType'), namespace_, eol_))
        if self.ProtoCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtoCode>%s</%sProtoCode>%s' % (namespace_, self.gds_format_integer(self.ProtoCode, input_name='ProtoCode'), namespace_, eol_))
        if self.ProtoField is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtoField>%s</%sProtoField>%s' % (namespace_, self.gds_format_integer(self.ProtoField, input_name='ProtoField'), namespace_, eol_))
        if self.Application is not None:
            self.Application.export(outfile, level, namespace_, name_='Application', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Port is not None or
            self.Portlist is not None or
            self.ProtoType is not None or
            self.ProtoCode is not None or
            self.ProtoField is not None or
            self.Application is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Service'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ip_protocol is not None and 'ip_protocol' not in already_processed:
            already_processed.append('ip_protocol')
            showIndent(outfile, level)
            outfile.write('ip_protocol = %d,\n' % (self.ip_protocol,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%d,\n' % self.Port)
        if self.Portlist is not None:
            showIndent(outfile, level)
            outfile.write('Portlist=%s,\n' % quote_python(self.Portlist).encode(ExternalEncoding))
        if self.ProtoType is not None:
            showIndent(outfile, level)
            outfile.write('ProtoType=%d,\n' % self.ProtoType)
        if self.ProtoCode is not None:
            showIndent(outfile, level)
            outfile.write('ProtoCode=%d,\n' % self.ProtoCode)
        if self.ProtoField is not None:
            showIndent(outfile, level)
            outfile.write('ProtoField=%d,\n' % self.ProtoField)
        if self.Application is not None:
            showIndent(outfile, level)
            outfile.write('Application=model_.Application(\n')
            self.Application.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ip_protocol', node)
        if value is not None and 'ip_protocol' not in already_processed:
            already_processed.append('ip_protocol')
            try:
                self.ip_protocol = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Port')
            self.Port = ival_
        elif nodeName_ == 'Portlist':
            Portlist_ = child_.text
            Portlist_ = self.gds_validate_string(Portlist_, node, 'Portlist')
            self.Portlist = Portlist_
            self.validate_PortlistType(self.Portlist)    # validate type PortlistType
        elif nodeName_ == 'ProtoType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ProtoType')
            self.ProtoType = ival_
        elif nodeName_ == 'ProtoCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ProtoCode')
            self.ProtoCode = ival_
        elif nodeName_ == 'ProtoField':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ProtoField')
            self.ProtoField = ival_
        elif nodeName_ == 'Application':
            obj_ = SoftwareType.factory()
            obj_.build(child_)
            self.set_Application(obj_)
# end class Service


class Counter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, duration=None, meaning=None, type_=None, ext_duration=None, ext_type=None, valueOf_=None):
        self.duration = _cast(None, duration)
        self.meaning = _cast(None, meaning)
        self.type_ = _cast(None, type_)
        self.ext_duration = _cast(None, ext_duration)
        self.ext_type = _cast(None, ext_type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Counter.subclass:
            return Counter.subclass(*args_, **kwargs_)
        else:
            return Counter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_meaning(self): return self.meaning
    def set_meaning(self, meaning): self.meaning = meaning
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ext_duration(self): return self.ext_duration
    def set_ext_duration(self, ext_duration): self.ext_duration = ext_duration
    def get_ext_type(self): return self.ext_type
    def set_ext_type(self, ext_type): self.ext_type = ext_type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='Counter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Counter')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Counter'):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            outfile.write(' duration=%s' % (quote_attrib(self.duration), ))
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            outfile.write(' meaning=%s' % (self.gds_format_string(quote_attrib(self.meaning).encode(ExternalEncoding), input_name='meaning'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ext_duration is not None and 'ext_duration' not in already_processed:
            already_processed.append('ext_duration')
            outfile.write(' ext-duration=%s' % (self.gds_format_string(quote_attrib(self.ext_duration).encode(ExternalEncoding), input_name='ext-duration'), ))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            outfile.write(' ext-type=%s' % (self.gds_format_string(quote_attrib(self.ext_type).encode(ExternalEncoding), input_name='ext-type'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Counter', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Counter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            showIndent(outfile, level)
            outfile.write('duration = %s,\n' % (self.duration,))
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            showIndent(outfile, level)
            outfile.write('meaning = "%s",\n' % (self.meaning,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ext_duration is not None and 'ext_duration' not in already_processed:
            already_processed.append('ext_duration')
            showIndent(outfile, level)
            outfile.write('ext_duration = "%s",\n' % (self.ext_duration,))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            showIndent(outfile, level)
            outfile.write('ext_type = "%s",\n' % (self.ext_type,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.append('duration')
            self.duration = value
        value = find_attr_value_('meaning', node)
        if value is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            self.meaning = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ext-duration', node)
        if value is not None and 'ext-duration' not in already_processed:
            already_processed.append('ext-duration')
            self.ext_duration = value
        value = find_attr_value_('ext-type', node)
        if value is not None and 'ext-type' not in already_processed:
            already_processed.append('ext-type')
            self.ext_type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Counter


class Record(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction=None, RecordData=None):
        self.restriction = _cast(None, restriction)
        if RecordData is None:
            self.RecordData = []
        else:
            self.RecordData = RecordData
    def factory(*args_, **kwargs_):
        if Record.subclass:
            return Record.subclass(*args_, **kwargs_)
        else:
            return Record(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RecordData(self): return self.RecordData
    def set_RecordData(self, RecordData): self.RecordData = RecordData
    def add_RecordData(self, value): self.RecordData.append(value)
    def insert_RecordData(self, index, value): self.RecordData[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='Record', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Record')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Record'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Record', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RecordData_ in self.RecordData:
            RecordData_.export(outfile, level, namespace_, name_='RecordData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.RecordData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Record'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RecordData=[\n')
        level += 1
        for RecordData_ in self.RecordData:
            showIndent(outfile, level)
            outfile.write('model_.RecordData(\n')
            RecordData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RecordData':
            obj_ = RecordData.factory()
            obj_.build(child_)
            self.RecordData.append(obj_)
# end class Record


class RecordData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, restriction=None, DateTime=None, Description=None, Application=None, RecordPattern=None, RecordItem=None, AdditionalData=None):
        self.restriction = _cast(None, restriction)
        self.DateTime = DateTime
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Application = Application
        if RecordPattern is None:
            self.RecordPattern = []
        else:
            self.RecordPattern = RecordPattern
        if RecordItem is None:
            self.RecordItem = []
        else:
            self.RecordItem = RecordItem
        if AdditionalData is None:
            self.AdditionalData = []
        else:
            self.AdditionalData = AdditionalData
    def factory(*args_, **kwargs_):
        if RecordData.subclass:
            return RecordData.subclass(*args_, **kwargs_)
        else:
            return RecordData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateTime(self): return self.DateTime
    def set_DateTime(self, DateTime): self.DateTime = DateTime
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_Application(self): return self.Application
    def set_Application(self, Application): self.Application = Application
    def get_RecordPattern(self): return self.RecordPattern
    def set_RecordPattern(self, RecordPattern): self.RecordPattern = RecordPattern
    def add_RecordPattern(self, value): self.RecordPattern.append(value)
    def insert_RecordPattern(self, index, value): self.RecordPattern[index] = value
    def get_RecordItem(self): return self.RecordItem
    def set_RecordItem(self, RecordItem): self.RecordItem = RecordItem
    def add_RecordItem(self, value): self.RecordItem.append(value)
    def insert_RecordItem(self, index, value): self.RecordItem[index] = value
    def get_AdditionalData(self): return self.AdditionalData
    def set_AdditionalData(self, AdditionalData): self.AdditionalData = AdditionalData
    def add_AdditionalData(self, value): self.AdditionalData.append(value)
    def insert_AdditionalData(self, index, value): self.AdditionalData[index] = value
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def export(self, outfile, level, namespace_='iodef:', name_='RecordData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecordData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='RecordData'):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='RecordData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateTime>%s</%sDateTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.DateTime).encode(ExternalEncoding), input_name='DateTime'), namespace_, eol_))
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Application is not None:
            self.Application.export(outfile, level, namespace_, name_='Application', pretty_print=pretty_print)
        for RecordPattern_ in self.RecordPattern:
            RecordPattern_.export(outfile, level, namespace_, name_='RecordPattern', pretty_print=pretty_print)
        for RecordItem_ in self.RecordItem:
            RecordItem_.export(outfile, level, namespace_, name_='RecordItem', pretty_print=pretty_print)
        for AdditionalData_ in self.AdditionalData:
            AdditionalData_.export(outfile, level, namespace_, name_='AdditionalData', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.DateTime is not None or
            self.Description or
            self.Application is not None or
            self.RecordPattern or
            self.RecordItem or
            self.AdditionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RecordData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DateTime is not None:
            showIndent(outfile, level)
            outfile.write('DateTime=%s,\n' % quote_python(self.DateTime).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.Description(\n')
            Description_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Application is not None:
            showIndent(outfile, level)
            outfile.write('Application=model_.Application(\n')
            self.Application.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('RecordPattern=[\n')
        level += 1
        for RecordPattern_ in self.RecordPattern:
            showIndent(outfile, level)
            outfile.write('model_.RecordPattern(\n')
            RecordPattern_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RecordItem=[\n')
        level += 1
        for RecordItem_ in self.RecordItem:
            showIndent(outfile, level)
            outfile.write('model_.RecordItem(\n')
            RecordItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AdditionalData=[\n')
        level += 1
        for AdditionalData_ in self.AdditionalData:
            showIndent(outfile, level)
            outfile.write('model_.AdditionalData(\n')
            AdditionalData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateTime':
            DateTime_ = child_.text
            DateTime_ = self.gds_validate_string(DateTime_, node, 'DateTime')
            self.DateTime = DateTime_
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, MLStringType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'Application':
            obj_ = SoftwareType.factory()
            obj_.build(child_)
            self.set_Application(obj_)
        elif nodeName_ == 'RecordPattern':
            obj_ = RecordPattern.factory()
            obj_.build(child_)
            self.RecordPattern.append(obj_)
        elif nodeName_ == 'RecordItem':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.RecordItem.append(obj_)
        elif nodeName_ == 'AdditionalData':
            obj_ = ExtensionType.factory()
            obj_.build(child_)
            self.AdditionalData.append(obj_)
# end class RecordData


class RecordPattern(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, offsetunit='line', instance=None, ext_type=None, offset=None, ext_offsetunit=None, type_=None, valueOf_=None):
        self.offsetunit = _cast(None, offsetunit)
        self.instance = _cast(int, instance)
        self.ext_type = _cast(None, ext_type)
        self.offset = _cast(int, offset)
        self.ext_offsetunit = _cast(None, ext_offsetunit)
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RecordPattern.subclass:
            return RecordPattern.subclass(*args_, **kwargs_)
        else:
            return RecordPattern(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_offsetunit(self): return self.offsetunit
    def set_offsetunit(self, offsetunit): self.offsetunit = offsetunit
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_ext_type(self): return self.ext_type
    def set_ext_type(self, ext_type): self.ext_type = ext_type
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_ext_offsetunit(self): return self.ext_offsetunit
    def set_ext_offsetunit(self, ext_offsetunit): self.ext_offsetunit = ext_offsetunit
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='RecordPattern', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecordPattern')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='RecordPattern'):
        if self.offsetunit is not None and 'offsetunit' not in already_processed:
            already_processed.append('offsetunit')
            outfile.write(' offsetunit=%s' % (self.gds_format_string(quote_attrib(self.offsetunit).encode(ExternalEncoding), input_name='offsetunit'), ))
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            outfile.write(' instance="%s"' % self.gds_format_integer(self.instance, input_name='instance'))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            outfile.write(' ext-type=%s' % (self.gds_format_string(quote_attrib(self.ext_type).encode(ExternalEncoding), input_name='ext-type'), ))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
        if self.ext_offsetunit is not None and 'ext_offsetunit' not in already_processed:
            already_processed.append('ext_offsetunit')
            outfile.write(' ext-offsetunit=%s' % (self.gds_format_string(quote_attrib(self.ext_offsetunit).encode(ExternalEncoding), input_name='ext-offsetunit'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='RecordPattern', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RecordPattern'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.offsetunit is not None and 'offsetunit' not in already_processed:
            already_processed.append('offsetunit')
            showIndent(outfile, level)
            outfile.write('offsetunit = "%s",\n' % (self.offsetunit,))
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            showIndent(outfile, level)
            outfile.write('instance = %d,\n' % (self.instance,))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            showIndent(outfile, level)
            outfile.write('ext_type = "%s",\n' % (self.ext_type,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            showIndent(outfile, level)
            outfile.write('offset = %d,\n' % (self.offset,))
        if self.ext_offsetunit is not None and 'ext_offsetunit' not in already_processed:
            already_processed.append('ext_offsetunit')
            showIndent(outfile, level)
            outfile.write('ext_offsetunit = "%s",\n' % (self.ext_offsetunit,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('offsetunit', node)
        if value is not None and 'offsetunit' not in already_processed:
            already_processed.append('offsetunit')
            self.offsetunit = value
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.append('instance')
            try:
                self.instance = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ext-type', node)
        if value is not None and 'ext-type' not in already_processed:
            already_processed.append('ext-type')
            self.ext_type = value
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            try:
                self.offset = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ext-offsetunit', node)
        if value is not None and 'ext-offsetunit' not in already_processed:
            already_processed.append('ext-offsetunit')
            self.ext_offsetunit = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RecordPattern


class SoftwareType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vendor=None, name=None, family=None, swid='0', patch=None, version=None, configid='0', URL=None):
        self.vendor = _cast(None, vendor)
        self.name = _cast(None, name)
        self.family = _cast(None, family)
        self.swid = _cast(None, swid)
        self.patch = _cast(None, patch)
        self.version = _cast(None, version)
        self.configid = _cast(None, configid)
        self.URL = URL
    def factory(*args_, **kwargs_):
        if SoftwareType.subclass:
            return SoftwareType.subclass(*args_, **kwargs_)
        else:
            return SoftwareType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def get_swid(self): return self.swid
    def set_swid(self, swid): self.swid = swid
    def get_patch(self): return self.patch
    def set_patch(self, patch): self.patch = patch
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_configid(self): return self.configid
    def set_configid(self, configid): self.configid = configid
    def export(self, outfile, level, namespace_='iodef:', name_='SoftwareType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SoftwareType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='SoftwareType'):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.append('vendor')
            outfile.write(' vendor=%s' % (self.gds_format_string(quote_attrib(self.vendor).encode(ExternalEncoding), input_name='vendor'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.family is not None and 'family' not in already_processed:
            already_processed.append('family')
            outfile.write(' family=%s' % (self.gds_format_string(quote_attrib(self.family).encode(ExternalEncoding), input_name='family'), ))
        if self.swid is not None and 'swid' not in already_processed:
            already_processed.append('swid')
            outfile.write(' swid=%s' % (self.gds_format_string(quote_attrib(self.swid).encode(ExternalEncoding), input_name='swid'), ))
        if self.patch is not None and 'patch' not in already_processed:
            already_processed.append('patch')
            outfile.write(' patch=%s' % (self.gds_format_string(quote_attrib(self.patch).encode(ExternalEncoding), input_name='patch'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.configid is not None and 'configid' not in already_processed:
            already_processed.append('configid')
            outfile.write(' configid=%s' % (self.gds_format_string(quote_attrib(self.configid).encode(ExternalEncoding), input_name='configid'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='SoftwareType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.URL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SoftwareType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.append('vendor')
            showIndent(outfile, level)
            outfile.write('vendor = "%s",\n' % (self.vendor,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.family is not None and 'family' not in already_processed:
            already_processed.append('family')
            showIndent(outfile, level)
            outfile.write('family = "%s",\n' % (self.family,))
        if self.swid is not None and 'swid' not in already_processed:
            already_processed.append('swid')
            showIndent(outfile, level)
            outfile.write('swid = "%s",\n' % (self.swid,))
        if self.patch is not None and 'patch' not in already_processed:
            already_processed.append('patch')
            showIndent(outfile, level)
            outfile.write('patch = "%s",\n' % (self.patch,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.configid is not None and 'configid' not in already_processed:
            already_processed.append('configid')
            showIndent(outfile, level)
            outfile.write('configid = "%s",\n' % (self.configid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.append('vendor')
            self.vendor = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('family', node)
        if value is not None and 'family' not in already_processed:
            already_processed.append('family')
            self.family = value
        value = find_attr_value_('swid', node)
        if value is not None and 'swid' not in already_processed:
            already_processed.append('swid')
            self.swid = value
        value = find_attr_value_('patch', node)
        if value is not None and 'patch' not in already_processed:
            already_processed.append('patch')
            self.patch = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('configid', node)
        if value is not None and 'configid' not in already_processed:
            already_processed.append('configid')
            self.configid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class SoftwareType


class MLStringType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, extensiontype_=None):
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MLStringType.subclass:
            return MLStringType.subclass(*args_, **kwargs_)
        else:
            return MLStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='iodef:', name_='MLStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MLStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='MLStringType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='MLStringType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MLStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MLStringType


class ExtensionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dtype=None, meaning=None, restriction=None, formatid=None, ext_dtype=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.dtype = _cast(None, dtype)
        self.meaning = _cast(None, meaning)
        self.restriction = _cast(None, restriction)
        self.formatid = _cast(None, formatid)
        self.ext_dtype = _cast(None, ext_dtype)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ExtensionType.subclass:
            return ExtensionType.subclass(*args_, **kwargs_)
        else:
            return ExtensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_dtype(self): return self.dtype
    def set_dtype(self, dtype): self.dtype = dtype
    def get_meaning(self): return self.meaning
    def set_meaning(self, meaning): self.meaning = meaning
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def get_formatid(self): return self.formatid
    def set_formatid(self, formatid): self.formatid = formatid
    def get_ext_dtype(self): return self.ext_dtype
    def set_ext_dtype(self, ext_dtype): self.ext_dtype = ext_dtype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='ExtensionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='ExtensionType'):
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            outfile.write(' dtype=%s' % (quote_attrib(self.dtype), ))
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            outfile.write(' meaning=%s' % (self.gds_format_string(quote_attrib(self.meaning).encode(ExternalEncoding), input_name='meaning'), ))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            outfile.write(' restriction=%s' % (quote_attrib(self.restriction), ))
        if self.formatid is not None and 'formatid' not in already_processed:
            already_processed.append('formatid')
            outfile.write(' formatid=%s' % (self.gds_format_string(quote_attrib(self.formatid).encode(ExternalEncoding), input_name='formatid'), ))
        if self.ext_dtype is not None and 'ext_dtype' not in already_processed:
            already_processed.append('ext_dtype')
            outfile.write(' ext-dtype=%s' % (self.gds_format_string(quote_attrib(self.ext_dtype).encode(ExternalEncoding), input_name='ext-dtype'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='ExtensionType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExtensionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dtype is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            showIndent(outfile, level)
            outfile.write('dtype = %s,\n' % (self.dtype,))
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            showIndent(outfile, level)
            outfile.write('meaning = "%s",\n' % (self.meaning,))
        if self.restriction is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            showIndent(outfile, level)
            outfile.write('restriction = %s,\n' % (self.restriction,))
        if self.formatid is not None and 'formatid' not in already_processed:
            already_processed.append('formatid')
            showIndent(outfile, level)
            outfile.write('formatid = "%s",\n' % (self.formatid,))
        if self.ext_dtype is not None and 'ext_dtype' not in already_processed:
            already_processed.append('ext_dtype')
            showIndent(outfile, level)
            outfile.write('ext_dtype = "%s",\n' % (self.ext_dtype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dtype', node)
        if value is not None and 'dtype' not in already_processed:
            already_processed.append('dtype')
            self.dtype = value
        value = find_attr_value_('meaning', node)
        if value is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            self.meaning = value
        value = find_attr_value_('restriction', node)
        if value is not None and 'restriction' not in already_processed:
            already_processed.append('restriction')
            self.restriction = value
        value = find_attr_value_('formatid', node)
        if value is not None and 'formatid' not in already_processed:
            already_processed.append('formatid')
            self.formatid = value
        value = find_attr_value_('ext-dtype', node)
        if value is not None and 'ext-dtype' not in already_processed:
            already_processed.append('ext-dtype')
            self.ext_dtype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class ExtensionType


class NodeRole(MLStringType):
    subclass = None
    superclass = MLStringType
    def __init__(self, lang=None, category=None, ext_category=None, valueOf_=None):
        super(NodeRole, self).__init__(lang, valueOf_, )
        self.category = _cast(None, category)
        self.ext_category = _cast(None, ext_category)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NodeRole.subclass:
            return NodeRole.subclass(*args_, **kwargs_)
        else:
            return NodeRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_ext_category(self): return self.ext_category
    def set_ext_category(self, ext_category): self.ext_category = ext_category
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='NodeRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NodeRole')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='NodeRole'):
        super(NodeRole, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NodeRole')
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            outfile.write(' category=%s' % (self.gds_format_string(quote_attrib(self.category).encode(ExternalEncoding), input_name='category'), ))
        if self.ext_category is not None and 'ext_category' not in already_processed:
            already_processed.append('ext_category')
            outfile.write(' ext-category=%s' % (self.gds_format_string(quote_attrib(self.ext_category).encode(ExternalEncoding), input_name='ext-category'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='NodeRole', fromsubclass_=False, pretty_print=True):
        super(NodeRole, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NodeRole, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NodeRole'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            showIndent(outfile, level)
            outfile.write('category = "%s",\n' % (self.category,))
        if self.ext_category is not None and 'ext_category' not in already_processed:
            already_processed.append('ext_category')
            showIndent(outfile, level)
            outfile.write('ext_category = "%s",\n' % (self.ext_category,))
        super(NodeRole, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NodeRole, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.append('category')
            self.category = value
        value = find_attr_value_('ext-category', node)
        if value is not None and 'ext-category' not in already_processed:
            already_processed.append('ext-category')
            self.ext_category = value
        super(NodeRole, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NodeRole


class Impact(MLStringType):
    subclass = None
    superclass = MLStringType
    def __init__(self, lang=None, completion=None, type_='unknown', severity=None, ext_type=None, valueOf_=None):
        super(Impact, self).__init__(lang, valueOf_, )
        self.completion = _cast(None, completion)
        self.type_ = _cast(None, type_)
        self.severity = _cast(None, severity)
        self.ext_type = _cast(None, ext_type)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Impact.subclass:
            return Impact.subclass(*args_, **kwargs_)
        else:
            return Impact(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_completion(self): return self.completion
    def set_completion(self, completion): self.completion = completion
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_ext_type(self): return self.ext_type
    def set_ext_type(self, ext_type): self.ext_type = ext_type
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='Impact', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Impact')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='Impact'):
        super(Impact, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Impact')
        if self.completion is not None and 'completion' not in already_processed:
            already_processed.append('completion')
            outfile.write(' completion=%s' % (self.gds_format_string(quote_attrib(self.completion).encode(ExternalEncoding), input_name='completion'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            outfile.write(' ext-type=%s' % (self.gds_format_string(quote_attrib(self.ext_type).encode(ExternalEncoding), input_name='ext-type'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='Impact', fromsubclass_=False, pretty_print=True):
        super(Impact, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Impact, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Impact'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.completion is not None and 'completion' not in already_processed:
            already_processed.append('completion')
            showIndent(outfile, level)
            outfile.write('completion = "%s",\n' % (self.completion,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            showIndent(outfile, level)
            outfile.write('severity = %s,\n' % (self.severity,))
        if self.ext_type is not None and 'ext_type' not in already_processed:
            already_processed.append('ext_type')
            showIndent(outfile, level)
            outfile.write('ext_type = "%s",\n' % (self.ext_type,))
        super(Impact, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Impact, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('completion', node)
        if value is not None and 'completion' not in already_processed:
            already_processed.append('completion')
            self.completion = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.append('severity')
            self.severity = value
        value = find_attr_value_('ext-type', node)
        if value is not None and 'ext-type' not in already_processed:
            already_processed.append('ext-type')
            self.ext_type = value
        super(Impact, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Impact


class PostalAddress(MLStringType):
    subclass = None
    superclass = MLStringType
    def __init__(self, lang=None, meaning=None, valueOf_=None):
        super(PostalAddress, self).__init__(lang, valueOf_, )
        self.meaning = _cast(None, meaning)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PostalAddress.subclass:
            return PostalAddress.subclass(*args_, **kwargs_)
        else:
            return PostalAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meaning(self): return self.meaning
    def set_meaning(self, meaning): self.meaning = meaning
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='iodef:', name_='PostalAddress', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostalAddress')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='iodef:', name_='PostalAddress'):
        super(PostalAddress, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PostalAddress')
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            outfile.write(' meaning=%s' % (self.gds_format_string(quote_attrib(self.meaning).encode(ExternalEncoding), input_name='meaning'), ))
    def exportChildren(self, outfile, level, namespace_='iodef:', name_='PostalAddress', fromsubclass_=False, pretty_print=True):
        super(PostalAddress, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(PostalAddress, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostalAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.meaning is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            showIndent(outfile, level)
            outfile.write('meaning = "%s",\n' % (self.meaning,))
        super(PostalAddress, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PostalAddress, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('meaning', node)
        if value is not None and 'meaning' not in already_processed:
            already_processed.append('meaning')
            self.meaning = value
        super(PostalAddress, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PostalAddress


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'IODEF-Document'
        rootClass = IODEF_Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'IODEF-Document'
        rootClass = IODEF_Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="IODEF-Document",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'IODEF-Document'
        rootClass = IODEF_Document
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from iodef_1_0 import *\n\n')
    sys.stdout.write('import stix.bindings.iodef.iodef_1_0 as iodef_binding as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Address",
    "AlternativeID",
    "Assessment",
    "Confidence",
    "Contact",
    "ContactMeansType",
    "Counter",
    "EventData",
    "Expectation",
    "ExtensionType",
    "Flow",
    "History",
    "HistoryItem",
    "IODEF_Document",
    "Impact",
    "Incident",
    "IncidentIDType",
    "MLStringType",
    "Method",
    "MonetaryImpact",
    "Node",
    "NodeRole",
    "PostalAddress",
    "Record",
    "RecordData",
    "RecordPattern",
    "Reference",
    "RegistryHandle",
    "RelatedActivity",
    "Service",
    "SoftwareType",
    "System",
    "TimeImpact"
    ]
